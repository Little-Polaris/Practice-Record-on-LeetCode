; Listing generated by Microsoft (R) Optimizing Compiler Version 19.36.32535.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_C@_0BB@GCADKGJO@map?1set?5too?5long@		; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp___std_terminate:PROC
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__imp___std_exception_copy:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	__imp___std_exception_destroy:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp___CxxFrameHandler4:PROC
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BB@GCADKGJO@map?1set?5too?5long@ DB 'map/set too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??$?RAEBHAEBH@?$less@X@std@@QEBA_NAEBH0@Z	; std::less<void>::operator()<int const &,int const &>
PUBLIC	??$lexicographical_compare@PEBHPEBHU?$less@X@std@@@std@@YA_NQEBH000U?$less@X@0@@Z ; std::lexicographical_compare<int const *,int const *,std::less<void> >
PUBLIC	??$forward@AEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * &>
PUBLIC	??$lexicographical_compare@PEBHPEBH@std@@YA_NQEBH000@Z ; std::lexicographical_compare<int const *,int const *>
PUBLIC	??$forward@AEAPEAU?$_Tree_node@HPEAX@std@@@std@@YAAEAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<int,void *> * &>
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@AEBV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<int> > const >
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > const >
PUBLIC	??$?RAEBHAEBH@?$equal_to@X@std@@QEBA_NAEBH0@Z	; std::equal_to<void>::operator()<int const &,int const &>
PUBLIC	??$_Memcmp_ranges@PEBHPEBH@std@@YAHPEBH00@Z	; std::_Memcmp_ranges<int const *,int const *>
PUBLIC	??$_Adl_verify_range@PEBHPEBH@std@@YAXAEBQEBH0@Z ; std::_Adl_verify_range<int const *,int const *>
PUBLIC	??$_Construct_in_place@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *,std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * &>
PUBLIC	??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > &>
PUBLIC	??$_Lower_bound_duplicate@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Lower_bound_duplicate<std::vector<int,std::allocator<int> > >
PUBLIC	??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Find_lower_bound<std::vector<int,std::allocator<int> > >
PUBLIC	??$?MHV?$allocator@H@std@@@std@@YA_NAEBV?$vector@HV?$allocator@H@std@@@0@0@Z ; std::operator<<int,std::allocator<int> >
PUBLIC	??$_Construct_in_place@PEAU?$_Tree_node@HPEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@HPEAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
PUBLIC	??$construct@HAEAH@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@QEAHAEAH@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int &>
PUBLIC	??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@HPEAX@1@AEBH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Lower_bound_duplicate<int>
PUBLIC	??$_Find_lower_bound@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@HPEAX@std@@@1@AEBH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_lower_bound<int>
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPEAU?$_Tree_node@HPEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Max
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@H@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_first
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Max
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::less<std::vector<int,std::allocator<int> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>,1>::_Get_first
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::_Allocate
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Allocate
PUBLIC	?_Kfn@?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@SAAEBHAEBH@Z ; std::_Tset_traits<int,std::less<int>,std::allocator<int>,0>::_Kfn
PUBLIC	?_Getcomp@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBAAEBU?$less@H@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getcomp
PUBLIC	?_Get_scary@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Get_scary
PUBLIC	??R?$less@H@std@@QEBA_NAEBH0@Z			; std::less<int>::operator()
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator--
PUBLIC	?_Kfn@?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@SAAEBV?$vector@HV?$allocator@H@std@@@2@AEBV32@@Z ; std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0>::_Kfn
PUBLIC	?_Getcomp@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Getcomp
PUBLIC	?_Get_scary@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Get_scary
PUBLIC	??R?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEBA_NAEBV?$vector@HV?$allocator@H@std@@@1@0@Z ; std::less<std::vector<int,std::allocator<int> > >::operator()
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator--
PUBLIC	??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
PUBLIC	??$exchange@PEAU?$_Tree_node@HPEAX@std@@$$T@std@@YAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Tree_node<int,void *> *,std::nullptr_t>
PUBLIC	??$exchange@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *,std::nullptr_t>
PUBLIC	??$forward@PEAH@std@@YA$$QEAPEAHAEAPEAH@Z	; std::forward<int *>
PUBLIC	??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH$$QEAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>
PUBLIC	??$forward@H@std@@YA$$QEAHAEAH@Z		; std::forward<int>
PUBLIC	??$equal@PEBHPEBHU?$equal_to@X@std@@@std@@YA_NQEBH00U?$equal_to@X@0@@Z ; std::equal<int const *,int const *,std::equal_to<void> >
PUBLIC	??$_Get_unwrapped_n@AEBQEBH_J@std@@YA?A_TAEBQEBH_J@Z ; std::_Get_unwrapped_n<int const * const &,__int64>
PUBLIC	??$_Idl_distance@PEBHPEBH@std@@YA?A_PAEBQEBH0@Z	; std::_Idl_distance<int const *,int const *>
PUBLIC	??$_Get_unwrapped@AEBQEBH@std@@YA?A_TAEBQEBH@Z	; std::_Get_unwrapped<int const * const &>
PUBLIC	??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>
PUBLIC	??$forward@AEBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAAEBV?$vector@HV?$allocator@H@std@@@0@AEBV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
PUBLIC	??$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > ><std::vector<int,std::allocator<int> > &>
PUBLIC	??$forward@AEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAAEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z ; std::forward<std::vector<int,std::allocator<int> > &>
PUBLIC	??$_Find_hint@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Find_hint<std::vector<int,std::allocator<int> > >
PUBLIC	??$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > ><int &>
PUBLIC	??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_hint<int>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@HPEAX@std@@@std@@QEAAXQEAU?$_Tree_node@HPEAX@2@_K@Z ; std::allocator<std::_Tree_node<int,void *> >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@HPEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::max_size
PUBLIC	?_Getal@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getal
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::max_size
PUBLIC	?_Getal@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Getal
PUBLIC	?max_size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::max_size
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXPEAU?$_Tree_node@HPEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXPEAU?$_Tree_node@HPEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Rrotate
PUBLIC	?max_size@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::max_size
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Rrotate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAA@PEAH00@Z ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Check_grow_by_1
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@U?$_Tree_id@PEAU?$_Tree_node@HPEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Insert_node
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Check_grow_by_1
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Insert_node
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::_Release
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	?_Extract@?$_In_place_key_extract_set@HH@std@@SAAEBHAEBH@Z ; std::_In_place_key_extract_set<int,int>::_Extract
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Release
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
PUBLIC	?_Extract@?$_In_place_key_extract_set@V?$vector@HV?$allocator@H@std@@@std@@V12@@std@@SAAEBV?$vector@HV?$allocator@H@std@@@2@AEBV32@@Z ; std::_In_place_key_extract_set<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > >::_Extract
PUBLIC	??$?0V?$allocator@H@std@@PEAHPEAHPEAH@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@H@1@$$QEAPEAH22@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int>,int *,int *,int *>
PUBLIC	??$exchange@PEAH$$T@std@@YAPEAHAEAPEAH$$QEA$$T@Z ; std::exchange<int *,std::nullptr_t>
PUBLIC	??$_Copy_n_unchecked4@PEAH_KPEAH@std@@YAPEAHPEAH_K0@Z ; std::_Copy_n_unchecked4<int *,unsigned __int64,int *>
PUBLIC	??$_Copy_memmove_n@PEAHPEAH@std@@YAPEAHPEAH_K0@Z ; std::_Copy_memmove_n<int *,int *>
PUBLIC	??$_Uninitialized_copy_n@PEAHV?$allocator@H@std@@@std@@YAPEAHPEAH_K0AEAV?$allocator@H@0@@Z ; std::_Uninitialized_copy_n<int *,std::allocator<int> >
PUBLIC	??$forward@AEBQEAU?$_Tree_node@HPEAX@std@@@std@@YAAEBQEAU?$_Tree_node@HPEAX@0@AEBQEAU10@@Z ; std::forward<std::_Tree_node<int,void *> * const &>
PUBLIC	??$_Voidify_iter@PEAPEAU?$_Tree_node@HPEAX@std@@@std@@YAPEAXPEAPEAU?$_Tree_node@HPEAX@0@@Z ; std::_Voidify_iter<std::_Tree_node<int,void *> * *>
PUBLIC	??$addressof@PEAU?$_Tree_node@HPEAX@std@@@std@@YAPEAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@@Z ; std::addressof<std::_Tree_node<int,void *> *>
PUBLIC	??$forward@AEBQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::forward<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * const &>
PUBLIC	??$_Voidify_iter@PEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAPEAXPEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@@Z ; std::_Voidify_iter<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * *>
PUBLIC	??$addressof@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *>
PUBLIC	??$construct@HAEAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAHAEAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>
PUBLIC	??$forward@AEAH@std@@YAAEAHAEAH@Z		; std::forward<int &>
PUBLIC	??$_Voidify_iter@PEAH@std@@YAPEAXPEAH@Z		; std::_Voidify_iter<int *>
PUBLIC	??$construct@H$$V@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int>
PUBLIC	??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAX$$QEAH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int>
PUBLIC	??$_Emplace_back@V?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > >
PUBLIC	??$_Voidify_iter@PEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEAXPEAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
PUBLIC	??$destroy@H@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@QEAH@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::destroy<int>
PUBLIC	??$addressof@H@std@@YAPEAHAEAH@Z		; std::addressof<int>
PUBLIC	??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::destroy<std::vector<int,std::allocator<int> > >
PUBLIC	??$equal@PEBHPEBH@std@@YA_NQEBH00@Z		; std::equal<int const *,int const *>
PUBLIC	??$_Emplace_back@AEBV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEBV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>
PUBLIC	??$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Emplace_hint<std::vector<int,std::allocator<int> > &>
PUBLIC	??$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Emplace_hint<int &>
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QEBAPEBHXZ ; std::vector<int,std::allocator<int> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QEBAPEBHXZ ; std::vector<int,std::allocator<int> >::_Unchecked_end
PUBLIC	??0?$allocator@U?$_Tree_node@HPEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_Tree_node<int,void *> >::allocator<std::_Tree_node<int,void *> >
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAA@XZ ; std::_Tree_val<std::_Tree_simple_types<int> >::_Tree_val<std::_Tree_simple_types<int> >
PUBLIC	??0?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
PUBLIC	??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z ; std::vector<int,std::allocator<int> >::_Assign_counted_range<int *>
PUBLIC	??$_Pocca@V?$allocator@H@std@@@std@@YAXAEAV?$allocator@H@0@AEBV10@@Z ; std::_Pocca<std::allocator<int> >
PUBLIC	??$addressof@$$CBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEBV?$vector@HV?$allocator@H@std@@@0@AEBV10@@Z ; std::addressof<std::vector<int,std::allocator<int> > const >
PUBLIC	??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z		; std::_Get_size_of_n<24>
PUBLIC	??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z		; std::_Get_size_of_n<32>
PUBLIC	??$_Refancy@PEAV?$vector@HV?$allocator@H@std@@@std@@$0A@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@@Z ; std::_Refancy<std::vector<int,std::allocator<int> > *,0>
PUBLIC	??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z		; std::_Get_size_of_n<56>
PUBLIC	??$_Construct_in_place@PEAU?$_Tree_node@HPEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@HPEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>
PUBLIC	??$_Construct_in_place@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEBQEAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *,std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@AEBU?$less@H@std@@@std@@YAAEBU?$less@H@0@AEBU10@@Z ; std::forward<std::less<int> const &>
PUBLIC	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
PUBLIC	??$forward@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAAEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@0@AEBU10@@Z ; std::forward<std::less<std::vector<int,std::allocator<int> > > const &>
PUBLIC	??$_Fill_zero_memset@PEAH@std@@YAXPEAH_K@Z	; std::_Fill_zero_memset<int *>
PUBLIC	??$_Is_all_bits_zero@H@std@@YA_NAEBH@Z		; std::_Is_all_bits_zero<int>
PUBLIC	??$_Emplace_back@AEAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAXAEAH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>
PUBLIC	??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$move@AEAPEAH@std@@YA$$QEAPEAHAEAPEAH@Z	; std::move<int * &>
PUBLIC	??$construct@HAEBH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAHAEBH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
PUBLIC	??$_Construct_in_place@HAEBH@std@@YAXAEAHAEBH@Z	; std::_Construct_in_place<int,int const &>
PUBLIC	??$_To_address@PEBH@std@@YA?A_PAEBQEBH@Z	; std::_To_address<int const *>
PUBLIC	??$_Copy_memmove@PEBHPEAH@std@@YAPEAHPEBH0PEAH@Z ; std::_Copy_memmove<int const *,int *>
PUBLIC	??$_Emplace_back@AEBH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAXAEBH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAXXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<>
PUBLIC	??$_Zero_range@PEAH@std@@YAPEAHQEAH0@Z		; std::_Zero_range<int *>
PUBLIC	??$_Uninitialized_move@PEAHV?$allocator@H@std@@@std@@YAPEAHQEAH0PEAHAEAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
PUBLIC	??$_Get_unwrapped@AEBQEAH@std@@YA?A_TAEBQEAH@Z	; std::_Get_unwrapped<int * const &>
PUBLIC	??$_Uninitialized_move@PEAV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<int,std::allocator<int> > *,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??$_Get_unwrapped@AEBQEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > * const &>
PUBLIC	??$construct@V?$vector@HV?$allocator@H@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@$$QEAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > >
PUBLIC	??$_Construct_in_place@V?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAXAEAV?$vector@HV?$allocator@H@std@@@0@$$QEAV10@@Z ; std::_Construct_in_place<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > >
PUBLIC	??$_Destroy_in_place@PEAU?$_Tree_node@HPEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@HPEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<int,void *>::_Freenode<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??$exchange@PEAU?$_Tree_node@HPEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@0@Z ; std::exchange<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
PUBLIC	??$_Destroy_in_place@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *>
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::vector<int,std::allocator<int> >,void *>::_Freenode<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
PUBLIC	??$exchange@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@0@Z ; std::exchange<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *,std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * &>
PUBLIC	??$?8HV?$allocator@H@std@@@std@@YA_NAEBV?$vector@HV?$allocator@H@std@@@0@0@Z ; std::operator==<int,std::allocator<int> >
PUBLIC	??$_Copy_n_unchecked4@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@_KPEAV?$vector@HV?$allocator@H@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@@Z ; std::_Copy_n_unchecked4<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>,unsigned __int64,std::vector<int,std::allocator<int> > *>
PUBLIC	??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_copy_n<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??$_Get_unwrapped@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_T$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> >
PUBLIC	??$move@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z ; std::move<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> &>
PUBLIC	??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> >
PUBLIC	??$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Insert_range_unchecked<std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *>
PUBLIC	??$_Copy_n_unchecked4@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@_KPEAH@std@@YAPEAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@_KPEAH@Z ; std::_Copy_n_unchecked4<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>,unsigned __int64,int *>
PUBLIC	??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@H@2@@std@@YAPEAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@_KPEAHAEAV?$allocator@H@0@@Z ; std::_Uninitialized_copy_n<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>,std::allocator<int> >
PUBLIC	??$_Get_unwrapped@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_T$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$move@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z ; std::move<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> &>
PUBLIC	??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_range_unchecked<int *,int *>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1><>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size
PUBLIC	?capacity@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::capacity
PUBLIC	?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw
PUBLIC	?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPEAU?$_Tree_node@HPEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Min
PUBLIC	??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator==
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Min
PUBLIC	??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator==
PUBLIC	??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<int,std::allocator<int> >::operator=
PUBLIC	?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AEAAXQEAH_K1@Z ; std::vector<int,std::allocator<int> >::_Change_array
PUBLIC	?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@_K@Z ; std::allocator<std::vector<int,std::allocator<int> > >::allocate
PUBLIC	?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Clear_and_reserve_geometric
PUBLIC	?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
PUBLIC	?_Calculate_growth@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEBA_K_K@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXQEAV?$vector@HV?$allocator@H@std@@@2@_K1@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Change_array
PUBLIC	?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
PUBLIC	?allocate@?$allocator@U?$_Tree_node@HPEAX@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@_K@Z ; std::allocator<std::_Tree_node<int,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@2@QEAU?$_Tree_node@HPEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::deallocate
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAPEAHXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Unwrapped
PUBLIC	??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBHXZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator++
PUBLIC	??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator!=
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAXPEBV?$vector@HV?$allocator@H@std@@@2@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Seek_to
PUBLIC	?allocate@?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::deallocate
PUBLIC	??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBV?$vector@HV?$allocator@H@std@@@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator++
PUBLIC	??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator!=
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@PEAHAEAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAPEAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAX_K@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z ; std::_Tree_node<int,void *>::_Buyheadnode<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z ; std::_Tree_node<std::vector<int,std::allocator<int> >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
PUBLIC	??$_Get_size_of_n@$03@std@@YA_K_K@Z		; std::_Get_size_of_n<4>
PUBLIC	??$?0AEBU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@H@1@$$QEAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$?0AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<std::vector<int,std::allocator<int> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>,1>::_Compressed_pair<std::less<std::vector<int,std::allocator<int> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>,1><std::less<std::vector<int,std::allocator<int> > > const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$_Uninitialized_fill_n@V?$allocator@H@std@@@std@@YAPEAHPEAH_KAEBHAEAV?$allocator@H@0@@Z ; std::_Uninitialized_fill_n<std::allocator<int> >
PUBLIC	??$forward@AEBV?$allocator@H@std@@@std@@YAAEBV?$allocator@H@0@AEBV10@@Z ; std::forward<std::allocator<int> const &>
PUBLIC	??$_To_address@PEAH@std@@YA?A_PAEBQEAH@Z	; std::_To_address<int *>
PUBLIC	??$_Uninitialized_copy@PEAHPEAHV?$allocator@H@std@@@std@@YAPEAHPEAH00AEAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
PUBLIC	??$_Get_unwrapped@PEAH@std@@YA?A_T$$QEAPEAH@Z	; std::_Get_unwrapped<int *>
PUBLIC	??$forward@AEBQEAH@std@@YAAEBQEAHAEBQEAH@Z	; std::forward<int * const &>
PUBLIC	??$forward@V?$allocator@H@std@@@std@@YA$$QEAV?$allocator@H@0@AEAV10@@Z ; std::forward<std::allocator<int> >
PUBLIC	??$move@AEAV?$allocator@H@std@@@std@@YA$$QEAV?$allocator@H@0@AEAV10@@Z ; std::move<std::allocator<int> &>
PUBLIC	??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAHAEBH@Z ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int const &>
PUBLIC	??$forward@AEBH@std@@YAAEBHAEBH@Z		; std::forward<int const &>
PUBLIC	??$_Copy_n_unchecked4@PEBH_KPEAH@std@@YAPEAHPEBH_KPEAH@Z ; std::_Copy_n_unchecked4<int const *,unsigned __int64,int *>
PUBLIC	??$_Copy_memmove_n@PEBHPEAH@std@@YAPEAHPEBH_KPEAH@Z ; std::_Copy_memmove_n<int const *,int *>
PUBLIC	??$_Uninitialized_copy_n@PEBHV?$allocator@H@std@@@std@@YAPEAHPEBH_KPEAHAEAV?$allocator@H@0@@Z ; std::_Uninitialized_copy_n<int const *,std::allocator<int> >
PUBLIC	??$_Get_unwrapped@PEBH@std@@YA?A_T$$QEAPEBH@Z	; std::_Get_unwrapped<int const *>
PUBLIC	??$move@AEAPEBH@std@@YA$$QEAPEBHAEAPEBH@Z	; std::move<int const * &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@H@std@@@std@@YAPEAHPEAH_KAEAV?$allocator@H@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<int> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$forward@PEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QEAPEAV?$vector@HV?$allocator@H@std@@@0@AEAPEAV10@@Z ; std::forward<std::vector<int,std::allocator<int> > *>
PUBLIC	??$forward@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@AEAV10@@Z ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_reallocate<std::vector<int,std::allocator<int> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAAEAV?$vector@HV?$allocator@H@std@@@1@$$QEAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back_with_unused_capacity<std::vector<int,std::allocator<int> > >
PUBLIC	??$forward@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z ; std::forward<std::vector<int,std::allocator<int> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<int,void *>::_Freenode0<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU01@@Z ; std::_Tree_node<std::vector<int,std::allocator<int> >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Erase_tree<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@PEAV?$vector@HV?$allocator@H@std@@@2@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@$$QEAPEAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >,std::vector<int,std::allocator<int> > *>
PUBLIC	??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z ; std::_Find_unchecked<std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > >
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >
PUBLIC	??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@_K@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Assign_counted_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> >
PUBLIC	??$_Get_unwrapped@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> &>
PUBLIC	??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> >
PUBLIC	??$_Adl_verify_range@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > > >
PUBLIC	??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >
PUBLIC	??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@_K@Z ; std::vector<int,std::allocator<int> >::_Assign_counted_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$_Get_unwrapped@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> &>
PUBLIC	??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$_Adl_verify_range@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >
PUBLIC	??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > &>
PUBLIC	??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
PUBLIC	??$move@AEAH@std@@YA$$QEAHAEAH@Z		; std::move<int &>
PUBLIC	?allocate@?$allocator@H@std@@QEAAPEAH_K@Z	; std::allocator<int>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA_KAEBV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@AEBA_K_K@Z ; std::vector<int,std::allocator<int> >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Clear_and_reserve_geometric@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Clear_and_reserve_geometric
PUBLIC	?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Buy_nonzero
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@00@Z ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
PUBLIC	??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
PUBLIC	?_Unwrapped@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::_Unwrapped
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBAPEAV?$vector@HV?$allocator@H@std@@@2@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Unwrapped
PUBLIC	??0?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >
PUBLIC	?_Unwrapped@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >::_Unwrapped
PUBLIC	??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
PUBLIC	??_G?$vector@HV?$allocator@H@std@@@std@@QEAAPEAXI@Z ; std::vector<int,std::allocator<int> >::`scalar deleting destructor'
PUBLIC	?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::__autoclassinit2
PUBLIC	?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::__autoclassinit2
PUBLIC	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z	; std::_Deallocate<16,0>
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPEAHQEAHAEAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@AEAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<int> > >
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
PUBLIC	??$_Construct_n@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBH@Z ; std::vector<int,std::allocator<int> >::_Construct_n<int const &>
PUBLIC	??$?0AEBV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
PUBLIC	??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z ; std::vector<int,std::allocator<int> >::_Construct_n<int * const &,int * const &>
PUBLIC	??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >
PUBLIC	??$_Pocma@V?$allocator@H@std@@@std@@YAXAEAV?$allocator@H@0@0@Z ; std::_Pocma<std::allocator<int> >
PUBLIC	??$addressof@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z ; std::addressof<std::vector<int,std::allocator<int> > >
PUBLIC	??$_Emplace_one_at_back@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAHAEBH@Z ; std::vector<int,std::allocator<int> >::_Emplace_one_at_back<int const &>
PUBLIC	??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z ; std::vector<int,std::allocator<int> >::_Assign_counted_range<int const *>
PUBLIC	??$_Convert_size@_K_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64,unsigned __int64>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize<std::_Value_init_tag>
PUBLIC	??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::destroy<int>
PUBLIC	??$_Unfancy@H@std@@YAPEAHPEAH@Z			; std::_Unfancy<int>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><>
PUBLIC	??$?0V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@PEAV?$vector@HV?$allocator@H@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@$$QEAPEAV?$vector@HV?$allocator@H@std@@@1@22@Z ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > >,std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *>
PUBLIC	??$exchange@PEAV?$vector@HV?$allocator@H@std@@@std@@$$T@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::vector<int,std::allocator<int> > *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@AEAV10@@Z ; std::move<std::allocator<std::vector<int,std::allocator<int> > > &>
PUBLIC	??$_Emplace_one_at_back@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAAEAV?$vector@HV?$allocator@H@std@@@1@$$QEAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_one_at_back<std::vector<int,std::allocator<int> > >
PUBLIC	??$move@AEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z ; std::move<std::vector<int,std::allocator<int> > &>
PUBLIC	??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >
PUBLIC	??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@@Z ; std::_Unfancy<std::vector<int,std::allocator<int> > >
PUBLIC	??$_Move_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@00@Z ; std::_Move_unchecked<std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >
PUBLIC	??$_Erase_head@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_head<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??$_Erase_head@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Erase_head<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > const &>
PUBLIC	??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > &>
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >,std::vector<int,std::allocator<int> > >
PUBLIC	??$_Get_unwrapped@AEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > > &>
PUBLIC	??$assign@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@$0A@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAXV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::assign<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >,0>
PUBLIC	??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z ; std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >
PUBLIC	??$_Get_unwrapped@AEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &>
PUBLIC	??$assign@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@$0A@@?$vector@HV?$allocator@H@std@@@std@@QEAAXV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@0@Z ; std::vector<int,std::allocator<int> >::assign<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,0>
PUBLIC	??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z ; std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBAX_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Verify_offset
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator+=
PUBLIC	?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z	; std::allocator<int>::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAAAEAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEBAAEBV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAAXQEAV?$vector@HV?$allocator@H@std@@@2@_K@Z ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_first
PUBLIC	??Z?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator-=
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AEAAXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@AEBAXPEAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEBAAEBV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	?_Take_contents@?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAAXAEAV12@@Z ; std::_Vector_val<std::_Simple_types<int> >::_Take_contents
PUBLIC	?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy
PUBLIC	?_Orphan_range@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEBAXPEAV?$vector@HV?$allocator@H@std@@@2@0@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Orphan_range
PUBLIC	?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
PUBLIC	?_Getal@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getal
PUBLIC	?_Get_scary@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Get_scary
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	?begin@?$initializer_list@H@std@@QEBAPEBHXZ	; std::initializer_list<int>::begin
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@HPEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Compat
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator-=
PUBLIC	?_Getal@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Getal
PUBLIC	?_Get_scary@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Get_scary
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@HPEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >
PUBLIC	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAX_K@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::__autoclassinit2
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >
PUBLIC	??0?$allocator@H@std@@QEAA@XZ			; std::allocator<int>::allocator<int>
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QEAA@_KAEBHAEBV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::vector<int,std::allocator<int> >::operator=
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QEAAXAEBH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	?size@?$initializer_list@H@std@@QEBA_KXZ	; std::initializer_list<int>::size
PUBLIC	??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@V?$initializer_list@H@1@@Z ; std::vector<int,std::allocator<int> >::operator=
PUBLIC	?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z ; std::vector<int,std::allocator<int> >::resize
PUBLIC	?pop_back@?$vector@HV?$allocator@H@std@@@std@@QEAAXXZ ; std::vector<int,std::allocator<int> >::pop_back
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ ; std::vector<int,std::allocator<int> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ ; std::vector<int,std::allocator<int> >::_Unchecked_end
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QEAAAEAH_K@Z ; std::vector<int,std::allocator<int> >::operator[]
PUBLIC	?back@?$vector@HV?$allocator@H@std@@@std@@QEAAAEAHXZ ; std::vector<int,std::allocator<int> >::back
PUBLIC	??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	?push_back@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAX$$QEAV?$vector@HV?$allocator@H@std@@@2@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::push_back
PUBLIC	?erase@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::erase
PUBLIC	?begin@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::begin
PUBLIC	?end@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::end
PUBLIC	?_Unchecked_begin@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Unchecked_end
PUBLIC	?back@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAAEAV?$vector@HV?$allocator@H@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::back
PUBLIC	??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
PUBLIC	?begin@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::end
PUBLIC	??0?$initializer_list@H@std@@QEAA@PEBH0@Z	; std::initializer_list<int>::initializer_list<int>
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator==
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator-
PUBLIC	??1?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::~_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::end
PUBLIC	??1Solution@@QEAA@XZ				; Solution::~Solution
PUBLIC	?__autoclassinit2@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z ; std::vector<int,std::allocator<int> >::__autoclassinit2
PUBLIC	??0Solution@@QEAA@XZ				; Solution::Solution
PUBLIC	main
PUBLIC	?__autoclassinit2@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAX_K@Z ; std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
PUBLIC	??1?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ ; std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::~set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAX_K@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAAX_K@Z ; std::set<int,std::less<int>,std::allocator<int> >::__autoclassinit2
PUBLIC	??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@XZ ; std::set<int,std::less<int>,std::allocator<int> >::~set<int,std::less<int>,std::allocator<int> >
PUBLIC	?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z ; Solution::dfs
PUBLIC	?combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z ; Solution::combinationSum2
PUBLIC	?_Throw_tree_length_error@std@@YAXXZ		; std::_Throw_tree_length_error
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Getcont@_Iterator_base0@std@@QEBAPEBU_Container_base0@2@XZ ; std::_Iterator_base0::_Getcont
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?max@?$numeric_limits@_J@std@@SA_JXZ		; std::numeric_limits<__int64>::max
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	__xmm@00000001000000010000000100000001
PUBLIC	__xmm@00000001000000020000000200000004
PUBLIC	__xmm@00000001000000020000000400000004
PUBLIC	__xmm@00000001000000050000000400000005
PUBLIC	__xmm@00000004000000010000000300000005
EXTRN	__std_terminate:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	memcmp:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z DD imagerel $LN65
	DD	imagerel $LN65+63
	DD	imagerel $unwind$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z DD imagerel $LN65+63
	DD	imagerel $LN65+114
	DD	imagerel $chain$0$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z DD imagerel $LN65+114
	DD	imagerel $LN65+131
	DD	imagerel $chain$1$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z DD imagerel $LN47
	DD	imagerel $LN47+37
	DD	imagerel $unwind$??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z DD imagerel $LN47+37
	DD	imagerel $LN47+138
	DD	imagerel $chain$0$??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z DD imagerel $LN47+138
	DD	imagerel $LN47+148
	DD	imagerel $chain$1$??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN28
	DD	imagerel $LN28+37
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD imagerel $LN28
	DD	imagerel $LN28+37
	DD	imagerel $unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z DD imagerel $LN35
	DD	imagerel $LN35+43
	DD	imagerel $unwind$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z DD imagerel $LN35
	DD	imagerel $LN35+43
	DD	imagerel $unwind$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$equal@PEBHPEBHU?$equal_to@X@std@@@std@@YA_NQEBH00U?$equal_to@X@0@@Z DD imagerel $LN15
	DD	imagerel $LN15+31
	DD	imagerel $unwind$??$equal@PEBHPEBHU?$equal_to@X@std@@@std@@YA_NQEBH00U?$equal_to@X@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z DD imagerel $LN65
	DD	imagerel $LN65+63
	DD	imagerel $unwind$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z DD imagerel $LN65+63
	DD	imagerel $LN65+114
	DD	imagerel $chain$0$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z DD imagerel $LN65+114
	DD	imagerel $LN65+131
	DD	imagerel $chain$1$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z DD imagerel $LN47
	DD	imagerel $LN47+120
	DD	imagerel $unwind$??$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_hint@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z DD imagerel $LN359
	DD	imagerel $LN359+1020
	DD	imagerel $unwind$??$_Find_hint@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z DD imagerel $LN45
	DD	imagerel $LN45+113
	DD	imagerel $unwind$??$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z DD imagerel $LN129
	DD	imagerel $LN129+165
	DD	imagerel $unwind$??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z DD imagerel $LN129+165
	DD	imagerel $LN129+247
	DD	imagerel $chain$2$??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z DD imagerel $LN129+247
	DD	imagerel $LN129+652
	DD	imagerel $chain$3$??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+31
	DD	imagerel $unwind$?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+31
	DD	imagerel $unwind$?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD imagerel $LN69
	DD	imagerel $LN69+131
	DD	imagerel $unwind$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEAH_KPEAH@std@@YAPEAHPEAH_K0@Z DD imagerel $LN11
	DD	imagerel $LN11+50
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEAH_KPEAH@std@@YAPEAHPEAH_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove_n@PEAHPEAH@std@@YAPEAHPEAH_K0@Z DD imagerel $LN6
	DD	imagerel $LN6+50
	DD	imagerel $unwind$??$_Copy_memmove_n@PEAHPEAH@std@@YAPEAHPEAH_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEAHV?$allocator@H@std@@@std@@YAPEAHPEAH_K0AEAV?$allocator@H@0@@Z DD imagerel $LN20
	DD	imagerel $LN20+50
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEAHV?$allocator@H@std@@@std@@YAPEAHPEAH_K0AEAV?$allocator@H@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@@Z DD imagerel $LN38
	DD	imagerel $LN38+92
	DD	imagerel $unwind$??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$equal@PEBHPEBH@std@@YA_NQEBH00@Z DD imagerel $LN17
	DD	imagerel $LN17+59
	DD	imagerel $unwind$??$equal@PEBHPEBH@std@@YA_NQEBH00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEBV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEBV?$vector@HV?$allocator@H@std@@@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+29
	DD	imagerel $unwind$??$_Emplace_back@AEBV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEBV?$vector@HV?$allocator@H@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z DD imagerel $LN116
	DD	imagerel $LN116+214
	DD	imagerel $unwind$??$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z DD imagerel $LN83
	DD	imagerel $LN83+180
	DD	imagerel $unwind$??$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z DD imagerel $LN68
	DD	imagerel $LN68+75
	DD	imagerel $unwind$??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z DD imagerel $LN68+75
	DD	imagerel $LN68+160
	DD	imagerel $chain$0$??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z DD imagerel $LN68+160
	DD	imagerel $LN68+180
	DD	imagerel $chain$1$??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+59
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEBHPEAH@std@@YAPEAHPEBH0PEAH@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEBHPEAH@std@@YAPEAHPEBH0PEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Zero_range@PEAH@std@@YAPEAHQEAH0@Z DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$??$_Zero_range@PEAH@std@@YAPEAHQEAH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAHV?$allocator@H@std@@@std@@YAPEAHQEAH0PEAHAEAV?$allocator@H@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+52
	DD	imagerel $unwind$??$_Uninitialized_move@PEAHV?$allocator@H@std@@@std@@YAPEAHQEAH0PEAHAEAV?$allocator@H@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD imagerel $LN37
	DD	imagerel $LN37+103
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Freenode@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD imagerel $LN61
	DD	imagerel $LN61+106
	DD	imagerel $unwind$??$_Freenode@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?8HV?$allocator@H@std@@@std@@YA_NAEBV?$vector@HV?$allocator@H@std@@@0@0@Z DD imagerel $LN24
	DD	imagerel $LN24+63
	DD	imagerel $unwind$??$?8HV?$allocator@H@std@@@std@@YA_NAEBV?$vector@HV?$allocator@H@std@@@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@_KPEAV?$vector@HV?$allocator@H@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@@Z DD imagerel $LN40
	DD	imagerel $LN40+152
	DD	imagerel $unwind$??$_Copy_n_unchecked4@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@_KPEAV?$vector@HV?$allocator@H@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD imagerel $LN48
	DD	imagerel $LN48+224
	DD	imagerel $unwind$??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z DD imagerel $LN128
	DD	imagerel $LN128+253
	DD	imagerel $unwind$??$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z DD imagerel $LN95
	DD	imagerel $LN95+237
	DD	imagerel $unwind$??$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN39
	DD	imagerel $LN39+140
	DD	imagerel $unwind$?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN77
	DD	imagerel $LN77+18
	DD	imagerel $unwind$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN77+18
	DD	imagerel $LN77+120
	DD	imagerel $chain$3$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN77+120
	DD	imagerel $LN77+209
	DD	imagerel $chain$4$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN77+209
	DD	imagerel $LN77+235
	DD	imagerel $chain$5$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN77+235
	DD	imagerel $LN77+244
	DD	imagerel $chain$6$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AEAAXQEAH_K1@Z DD imagerel $LN28
	DD	imagerel $LN28+136
	DD	imagerel $unwind$?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AEAAXQEAH_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@_K@Z DD imagerel $LN31
	DD	imagerel $LN31+116
	DD	imagerel $unwind$?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN77
	DD	imagerel $LN77+42
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN77+42
	DD	imagerel $LN77+348
	DD	imagerel $chain$2$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN77+348
	DD	imagerel $LN77+354
	DD	imagerel $chain$3$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z DD imagerel $LN77+354
	DD	imagerel $LN77+360
	DD	imagerel $chain$4$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXQEAV?$vector@HV?$allocator@H@std@@@2@_K1@Z DD imagerel $LN28
	DD	imagerel $LN28+189
	DD	imagerel $unwind$?_Change_array@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXQEAV?$vector@HV?$allocator@H@std@@@2@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z DD imagerel $LN28
	DD	imagerel $LN28+36
	DD	imagerel $unwind$??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Buyheadnode@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z DD imagerel $LN28
	DD	imagerel $LN28+36
	DD	imagerel $unwind$??$_Buyheadnode@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN24
	DD	imagerel $LN24+89
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$03@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$03@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_fill_n@V?$allocator@H@std@@@std@@YAPEAHPEAH_KAEBHAEAV?$allocator@H@0@@Z DD imagerel $LN29
	DD	imagerel $LN29+79
	DD	imagerel $unwind$??$_Uninitialized_fill_n@V?$allocator@H@std@@@std@@YAPEAHPEAH_KAEBHAEAV?$allocator@H@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAHPEAHV?$allocator@H@std@@@std@@YAPEAHPEAH00AEAV?$allocator@H@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+52
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAHPEAHV?$allocator@H@std@@@std@@YAPEAHPEAH00AEAV?$allocator@H@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z DD imagerel $LN133
	DD	imagerel $LN133+70
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z DD imagerel $LN133+70
	DD	imagerel $LN133+381
	DD	imagerel $chain$2$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z DD imagerel $LN133+381
	DD	imagerel $LN133+388
	DD	imagerel $chain$4$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z DD imagerel $LN133+388
	DD	imagerel $LN133+394
	DD	imagerel $chain$5$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z DD imagerel $LN133+394
	DD	imagerel $LN133+400
	DD	imagerel $chain$6$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_n_unchecked4@PEBH_KPEAH@std@@YAPEAHPEBH_KPEAH@Z DD imagerel $LN11
	DD	imagerel $LN11+50
	DD	imagerel $unwind$??$_Copy_n_unchecked4@PEBH_KPEAH@std@@YAPEAHPEBH_KPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove_n@PEBHPEAH@std@@YAPEAHPEBH_KPEAH@Z DD imagerel $LN6
	DD	imagerel $LN6+50
	DD	imagerel $unwind$??$_Copy_memmove_n@PEBHPEAH@std@@YAPEAHPEBH_KPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy_n@PEBHV?$allocator@H@std@@@std@@YAPEAHPEBH_KPEAHAEAV?$allocator@H@0@@Z DD imagerel $LN20
	DD	imagerel $LN20+50
	DD	imagerel $unwind$??$_Uninitialized_copy_n@PEBHV?$allocator@H@std@@@std@@YAPEAHPEBH_KPEAHAEAV?$allocator@H@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@V?$allocator@H@std@@@std@@YAPEAHPEAH_KAEAV?$allocator@H@0@@Z DD imagerel $LN20
	DD	imagerel $LN20+46
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@V?$allocator@H@std@@@std@@YAPEAHPEAH_KAEAV?$allocator@H@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN111
	DD	imagerel $LN111+347
	DD	imagerel $unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN204
	DD	imagerel $LN204+118
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN204+118
	DD	imagerel $LN204+753
	DD	imagerel $chain$3$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN204+753
	DD	imagerel $LN204+760
	DD	imagerel $chain$5$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN204+760
	DD	imagerel $LN204+766
	DD	imagerel $chain$6$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z DD imagerel $LN204+766
	DD	imagerel $LN204+772
	DD	imagerel $chain$7$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase_tree@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@@Z DD imagerel $LN38
	DD	imagerel $LN38+77
	DD	imagerel $unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z DD imagerel $LN76
	DD	imagerel $LN76+28
	DD	imagerel $unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z DD imagerel $LN76+28
	DD	imagerel $LN76+168
	DD	imagerel $chain$1$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z DD imagerel $LN76+168
	DD	imagerel $LN76+176
	DD	imagerel $chain$2$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z DD imagerel $LN76+176
	DD	imagerel $LN76+183
	DD	imagerel $chain$3$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z DD imagerel $LN43
	DD	imagerel $LN43+21
	DD	imagerel $unwind$??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z DD imagerel $LN43+21
	DD	imagerel $LN43+115
	DD	imagerel $chain$1$??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z DD imagerel $LN43+115
	DD	imagerel $LN43+129
	DD	imagerel $chain$2$??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@_K@Z DD imagerel $LN80
	DD	imagerel $LN80+456
	DD	imagerel $unwind$??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z DD imagerel $LN131
	DD	imagerel $LN131+260
	DD	imagerel $unwind$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@_K@Z DD imagerel $LN169
	DD	imagerel $LN169+582
	DD	imagerel $unwind$??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z DD imagerel $LN98
	DD	imagerel $LN98+237
	DD	imagerel $unwind$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@H@std@@QEAAPEAH_K@Z DD imagerel $LN31
	DD	imagerel $LN31+112
	DD	imagerel $unwind$?allocate@?$allocator@H@std@@QEAAPEAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD imagerel $LN39
	DD	imagerel $LN39+136
	DD	imagerel $unwind$?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN31
	DD	imagerel $LN31+45
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN31
	DD	imagerel $LN31+45
	DD	imagerel $unwind$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clear_and_reserve_geometric@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD imagerel $LN38
	DD	imagerel $LN38+175
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD imagerel $LN7
	DD	imagerel $LN7+34
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z DD imagerel $LN41
	DD	imagerel $LN41+55
	DD	imagerel $unwind$??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z DD imagerel $LN41
	DD	imagerel $LN41+55
	DD	imagerel $unwind$??0?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+97
	DD	imagerel $unwind$??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$vector@HV?$allocator@H@std@@@std@@QEAAPEAXI@Z DD imagerel $LN35
	DD	imagerel $LN35+95
	DD	imagerel $unwind$??_G?$vector@HV?$allocator@H@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN18
	DD	imagerel $LN18+53
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD imagerel $LN52
	DD	imagerel $LN52+15
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD imagerel $LN52+15
	DD	imagerel $LN52+124
	DD	imagerel $chain$0$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD imagerel $LN52+124
	DD	imagerel $LN52+125
	DD	imagerel $chain$1$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD imagerel $LN52+125
	DD	imagerel $LN52+132
	DD	imagerel $chain$2$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBH@Z DD imagerel $LN63
	DD	imagerel $LN63+125
	DD	imagerel $unwind$??$_Construct_n@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z DD imagerel $LN56
	DD	imagerel $LN56+37
	DD	imagerel $unwind$??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z DD imagerel $LN56+37
	DD	imagerel $LN56+95
	DD	imagerel $chain$0$??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z DD imagerel $LN56+95
	DD	imagerel $LN56+102
	DD	imagerel $chain$1$??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z DD imagerel $LN68
	DD	imagerel $LN68+75
	DD	imagerel $unwind$??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z DD imagerel $LN68+75
	DD	imagerel $LN68+160
	DD	imagerel $chain$0$??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z DD imagerel $LN68+160
	DD	imagerel $LN68+180
	DD	imagerel $chain$1$??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN29
	DD	imagerel $LN29+100
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN29+100
	DD	imagerel $LN29+142
	DD	imagerel $chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN29+142
	DD	imagerel $LN29+153
	DD	imagerel $chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@@Z DD imagerel $LN38
	DD	imagerel $LN38+92
	DD	imagerel $unwind$??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Move_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@00@Z DD imagerel $LN48
	DD	imagerel $LN48+174
	DD	imagerel $unwind$??$_Move_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase_head@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z DD imagerel $LN61
	DD	imagerel $LN61+113
	DD	imagerel $unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Erase_head@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z DD imagerel $LN26
	DD	imagerel $LN26+39
	DD	imagerel $unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN104
	DD	imagerel $LN104+432
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+59
	DD	imagerel $unwind$?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z DD imagerel $LN45
	DD	imagerel $LN45+22
	DD	imagerel $unwind$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z DD imagerel $LN45+22
	DD	imagerel $LN45+115
	DD	imagerel $chain$1$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z DD imagerel $LN45+115
	DD	imagerel $LN45+129
	DD	imagerel $chain$2$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$assign@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@$0A@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAXV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z DD imagerel $LN57
	DD	imagerel $LN57+145
	DD	imagerel $unwind$??$assign@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@$0A@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAXV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z DD imagerel $LN172
	DD	imagerel $LN172+314
	DD	imagerel $unwind$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$assign@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@$0A@@?$vector@HV?$allocator@H@std@@@std@@QEAAXV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@0@Z DD imagerel $LN57
	DD	imagerel $LN57+145
	DD	imagerel $unwind$??$assign@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@$0A@@?$vector@HV?$allocator@H@std@@@std@@QEAAXV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z DD imagerel $LN139
	DD	imagerel $LN139+291
	DD	imagerel $unwind$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAAXQEAV?$vector@HV?$allocator@H@std@@@2@_K@Z DD imagerel $LN21
	DD	imagerel $LN21+67
	DD	imagerel $unwind$?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAAXQEAV?$vector@HV?$allocator@H@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN11
	DD	imagerel $LN11+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+36
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AEAAXXZ DD imagerel $LN28
	DD	imagerel $LN28+92
	DD	imagerel $unwind$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXXZ DD imagerel $LN28
	DD	imagerel $LN28+135
	DD	imagerel $unwind$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN18
	DD	imagerel $LN18+133
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+62
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@HV?$allocator@H@std@@@std@@QEAA@_KAEBHAEBV?$allocator@H@1@@Z DD imagerel $LN70
	DD	imagerel $LN70+144
	DD	imagerel $unwind$??0?$vector@HV?$allocator@H@std@@@std@@QEAA@_KAEBHAEBV?$allocator@H@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN62
	DD	imagerel $LN62+60
	DD	imagerel $unwind$??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN62+60
	DD	imagerel $LN62+111
	DD	imagerel $chain$0$??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN62+111
	DD	imagerel $LN62+131
	DD	imagerel $chain$1$??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN37
	DD	imagerel $LN37+24
	DD	imagerel $unwind$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN37+24
	DD	imagerel $LN37+134
	DD	imagerel $chain$0$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN37+134
	DD	imagerel $LN37+148
	DD	imagerel $chain$1$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN37+148
	DD	imagerel $LN37+155
	DD	imagerel $chain$2$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ DD imagerel $LN31
	DD	imagerel $LN31+92
	DD	imagerel $unwind$??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@V?$initializer_list@H@1@@Z DD imagerel $LN71
	DD	imagerel $LN71+205
	DD	imagerel $unwind$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@V?$initializer_list@H@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z DD imagerel $LN31
	DD	imagerel $LN31+100
	DD	imagerel $unwind$?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z DD imagerel $LN31+100
	DD	imagerel $LN31+142
	DD	imagerel $chain$0$?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z DD imagerel $LN31+142
	DD	imagerel $LN31+153
	DD	imagerel $chain$1$?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN31
	DD	imagerel $LN31+135
	DD	imagerel $unwind$??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN88
	DD	imagerel $LN88+285
	DD	imagerel $unwind$?erase@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN64
	DD	imagerel $LN64+92
	DD	imagerel $unwind$??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN29
	DD	imagerel $LN29+42
	DD	imagerel $unwind$??1?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Solution@@QEAA@XZ DD imagerel $LN34
	DD	imagerel $LN34+92
	DD	imagerel $unwind$??1Solution@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN453
	DD	imagerel $LN453+1202
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN32
	DD	imagerel $LN32+42
	DD	imagerel $unwind$??1?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@XZ DD imagerel $LN67
	DD	imagerel $LN67+92
	DD	imagerel $unwind$??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z DD imagerel $LN545
	DD	imagerel $LN545+1342
	DD	imagerel $unwind$?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z DD imagerel $LN721
	DD	imagerel $LN721+1395
	DD	imagerel $unwind$?combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA DD imagerel ?dtor$1@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA
	DD	imagerel ?dtor$1@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_tree_length_error@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Throw_tree_length_error@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN13
	DD	imagerel $LN13+43
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+61
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN10
	DD	imagerel $LN10+61
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN16
	DD	imagerel $LN16+67
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN13
	DD	imagerel $LN13+67
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+67
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT __xmm@00000004000000010000000300000005
CONST	SEGMENT
__xmm@00000004000000010000000300000005 DB 05H, 00H, 00H, 00H, 03H, 00H, 00H
	DB	00H, 01H, 00H, 00H, 00H, 04H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000001000000050000000400000005
CONST	SEGMENT
__xmm@00000001000000050000000400000005 DB 05H, 00H, 00H, 00H, 04H, 00H, 00H
	DB	00H, 05H, 00H, 00H, 00H, 01H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000001000000020000000400000004
CONST	SEGMENT
__xmm@00000001000000020000000400000004 DB 04H, 00H, 00H, 00H, 04H, 00H, 00H
	DB	00H, 02H, 00H, 00H, 00H, 01H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000001000000020000000200000004
CONST	SEGMENT
__xmm@00000001000000020000000200000004 DB 04H, 00H, 00H, 00H, 02H, 00H, 00H
	DB	00H, 02H, 00H, 00H, 00H, 01H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000001000000010000000100000001
CONST	SEGMENT
__xmm@00000001000000010000000100000001 DB 01H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 01H, 00H, 00H, 00H, 01H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_tree_length_error@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z DB 016H
	DB	011H, 02H
	DB	02H
	DB	')', 02H
	DB	04H
	DB	0a8H
	DB	06H
	DB	0e1H, 02H
	DB	08H
	DB	0b9H, 05H
	DB	0aH
	DB	0baH
	DB	0cH
	DB	'&'
	DB	0eH
	DB	015H, 03H
	DB	010H
	DB	09H, 02H
	DB	02H
	DB	'P'
	DB	0aH
	DB	0cH
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z DB 010H
	DB	0eH
	DD	imagerel ?dtor$1@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA
	DB	02aH
	DD	imagerel ??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ
	DB	070H
	DB	092H
	DD	imagerel ??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@XZ
	DB	0a1H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
	DB	061H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	070H
	DB	06aH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	070H
	DB	0d2H
	DD	imagerel ??1?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ
	DB	061H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z DB 028H
	DD	imagerel $stateUnwindMap$?combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z
	DD	imagerel $ip2state$?combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z DD 0d3219H
	DD	0c6824H
	DD	025341cH
	DD	01a011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z
	DD	0baH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z DB 0cH
	DB	0f6H
	DB	02H
	DB	0cdH, 02H
	DB	00H
	DB	')', 09H
	DB	02H
	DB	'f'
	DB	00H
	DB	01dH, 04H
	DB	02H
	DB	'f'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z DB 028H
	DD	imagerel $stateUnwindMap$?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z
	DD	imagerel $ip2state$?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z DD 091411H
	DD	0f00da214H
	DD	0d009e00bH
	DD	07005c007H
	DD	030036004H
	DD	05002H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@XZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$main DB 0eH
	DB	0d4H
	DB	02H
	DB	'I', 07H
	DB	04H
	DB	'$'
	DB	08H
	DB	'i', 03H
	DB	0aH
	DB	'z'
	DB	08H
	DB	085H, 04H
	DB	00H
	DB	'L'
	DB	08H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$main DB 0aH
	DB	0aH
	DD	imagerel ??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ
	DB	0a0H
	DB	032H
	DD	imagerel ??1Solution@@QEAA@XZ
	DB	040H
	DB	032H
	DD	imagerel ??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ
	DB	0d0H
	DB	092H
	DD	imagerel ??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ
	DB	0d0H
	DB	032H
	DD	imagerel ??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ
	DB	01H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$main DB 028H
	DD	imagerel $stateUnwindMap$main
	DD	imagerel $ip2state$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	0d3219H
	DD	01c7424H
	DD	01b6424H
	DD	01a3424H
	DD	0140124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$main
	DD	09aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Solution@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@XZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@@Z DD 0a1401H
	DD	0e3414H
	DD	0f0103214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+100
	DD	imagerel $unwind$?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z DD 020521H
	DD	073405H
	DD	imagerel $LN31
	DD	imagerel $LN31+100
	DD	imagerel $unwind$?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@V?$initializer_list@H@1@@Z DD 086e01H
	DD	0ce46eH
	DD	0f007320bH
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020021H
	DD	086400H
	DD	imagerel $LN37
	DD	imagerel $LN37+24
	DD	imagerel $unwind$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+24
	DD	imagerel $unwind$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020521H
	DD	086405H
	DD	imagerel $LN37
	DD	imagerel $LN37+24
	DD	imagerel $unwind$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z DD 021H
	DD	imagerel $LN62
	DD	imagerel $LN62+60
	DD	imagerel $unwind$??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z DD 020521H
	DD	087405H
	DD	imagerel $LN62
	DD	imagerel $LN62+60
	DD	imagerel $unwind$??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@HV?$allocator@H@std@@@std@@QEAA@_KAEBHAEBV?$allocator@H@1@@Z DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'h'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 04H
	DB	'X'
	DB	00H
	DB	'\'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0cH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAAXQEAV?$vector@HV?$allocator@H@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z DB 06H
	DB	'l'
	DB	00H
	DB	0feH
	DB	04H
	DB	0d0H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@XZ
	DB	080H
	DB	032H
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z
	DD	imagerel $ip2state$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z DD 0a1911H
	DD	0185419H
	DD	0173419H
	DD	0f012f219H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$assign@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@$0A@@?$vector@HV?$allocator@H@std@@@std@@QEAAXV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@0@Z DD 011319H
	DD	06204H
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z DB 08H
	DB	'v'
	DB	00H
	DB	0fcH
	DB	04H
	DB	'('
	DB	06H
	DB	0ceH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z DB 06H
	DB	0cH
	DD	imagerel ??1?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
	DB	080H
	DB	032H
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	062H
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z
	DD	imagerel $ip2state$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z DD 0c1f11H
	DD	019641fH
	DD	018541fH
	DD	017341fH
	DD	0f018f21fH
	DD	0d014e016H
	DD	07010c012H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$assign@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@$0A@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAXV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z DD 011319H
	DD	06204H
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+22
	DD	imagerel $unwind$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z DD 040e21H
	DD	0ae40eH
	DD	095405H
	DD	imagerel $LN45
	DD	imagerel $LN45+22
	DD	imagerel $unwind$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0cH
	DB	09cH
	DB	00H
	DB	'\'
	DB	02H
	DB	0b4H
	DB	06H
	DB	0eeH
	DB	04H
	DB	'L'
	DB	00H
	DB	'P'
	DB	0aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DB	'=', 05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0aH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 061719H
	DD	0c3417H
	DD	0e0135217H
	DD	060107011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase_head@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Move_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@00@Z DD 060c01H
	DD	09340cH
	DD	07008320cH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 021H
	DD	imagerel $LN29
	DD	imagerel $LN29+100
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 020521H
	DD	073405H
	DD	imagerel $LN29
	DD	imagerel $LN29+100
	DD	imagerel $unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z DD 021H
	DD	imagerel $LN68
	DD	imagerel $LN68+75
	DD	imagerel $unwind$??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z DD 020521H
	DD	0d6405H
	DD	imagerel $LN68
	DD	imagerel $LN68+75
	DD	imagerel $unwind$??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z DD 060c01H
	DD	0f008320cH
	DD	07004e006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z DD 021H
	DD	imagerel $LN56
	DD	imagerel $LN56+37
	DD	imagerel $unwind$??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z DD 020521H
	DD	057405H
	DD	imagerel $LN56
	DD	imagerel $LN56+37
	DD	imagerel $unwind$??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z DD 040d01H
	DD	0e009520dH
	DD	030066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBH@Z DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 020021H
	DD	076400H
	DD	imagerel $LN52
	DD	imagerel $LN52+15
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 021H
	DD	imagerel $LN52
	DD	imagerel $LN52+15
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 020521H
	DD	076405H
	DD	imagerel $LN52
	DD	imagerel $LN52+15
	DD	imagerel $unwind$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 040f01H
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$vector@HV?$allocator@H@std@@@std@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@H@std@@QEAAPEAH_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z DB 04H
	DB	015H, 02H
	DB	02H
	DB	0c4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z DB 028H
	DD	imagerel $stateUnwindMap$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z
	DD	imagerel $ip2state$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z DD 0a1f11H
	DD	016541fH
	DD	015341fH
	DD	0f01bd21fH
	DD	0c017e019H
	DD	060147015H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@_K@Z DD 061e19H
	DD	0b640fH
	DD	09340fH
	DD	0700b520fH
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z DB 06H
	DB	'%', 02H
	DB	02H
	DB	'('
	DB	04H
	DB	0c2H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z DB 028H
	DD	imagerel $stateUnwindMap$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z
	DD	imagerel $ip2state$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z DD 0c2511H
	DD	0176425H
	DD	0165425H
	DD	0153425H
	DD	0f021d225H
	DD	0d01de01fH
	DD	07019c01bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@_K@Z DD 087d01H
	DD	09547dH
	DD	0b340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z DD 021H
	DD	imagerel $LN43
	DD	imagerel $LN43+21
	DD	imagerel $unwind$??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z DD 040d21H
	DD	07740dH
	DD	065405H
	DD	imagerel $LN43
	DD	imagerel $LN43+21
	DD	imagerel $unwind$??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z DD 040021H
	DD	04e400H
	DD	053400H
	DD	imagerel $LN76
	DD	imagerel $LN76+28
	DD	imagerel $unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z DD 021H
	DD	imagerel $LN76
	DD	imagerel $LN76+28
	DD	imagerel $unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z DD 040a21H
	DD	04e40aH
	DD	053405H
	DD	imagerel $LN76
	DD	imagerel $LN76+28
	DD	imagerel $unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z DD 040801H
	DD	070045208H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Erase_tree@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z DD 080021H
	DD	04e400H
	DD	05d400H
	DD	065400H
	DD	0f3400H
	DD	imagerel $LN204
	DD	imagerel $LN204+118
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z DD 021H
	DD	imagerel $LN204
	DD	imagerel $LN204+118
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z DD 080021H
	DD	04e400H
	DD	05d400H
	DD	065400H
	DD	0f3400H
	DD	imagerel $LN204
	DD	imagerel $LN204+118
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z DD 082221H
	DD	04e422H
	DD	05d416H
	DD	06540aH
	DD	0f3405H
	DD	imagerel $LN204
	DD	imagerel $LN204+118
	DD	imagerel $unwind$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z DD 050b01H
	DD	0f007620bH
	DD	07003c005H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@V?$allocator@H@std@@@std@@YAPEAHPEAH_KAEAV?$allocator@H@0@@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEBHV?$allocator@H@std@@@std@@YAPEAHPEBH_KPEAHAEAV?$allocator@H@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove_n@PEBHPEAH@std@@YAPEAHPEBH_KPEAH@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEBH_KPEAH@std@@YAPEAHPEBH_KPEAH@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z DD 060021H
	DD	04f400H
	DD	0d6400H
	DD	0c3400H
	DD	imagerel $LN133
	DD	imagerel $LN133+70
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z DD 021H
	DD	imagerel $LN133
	DD	imagerel $LN133+70
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z DD 060021H
	DD	04f400H
	DD	0d6400H
	DD	0c3400H
	DD	imagerel $LN133
	DD	imagerel $LN133+70
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z DD 061921H
	DD	04f419H
	DD	0d640eH
	DD	0c3405H
	DD	imagerel $LN133
	DD	imagerel $LN133+70
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z DD 050b01H
	DD	0e007420bH
	DD	07003c005H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAHPEAHV?$allocator@H@std@@@std@@YAPEAHPEAH00AEAV?$allocator@H@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_fill_n@V?$allocator@H@std@@@std@@YAPEAHPEAH_KAEBHAEAV?$allocator@H@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$03@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Buyheadnode@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXQEAV?$vector@HV?$allocator@H@std@@@2@_K1@Z DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z DD 060021H
	DD	04e400H
	DD	0b7400H
	DD	0a3400H
	DD	imagerel $LN77
	DD	imagerel $LN77+42
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z DD 021H
	DD	imagerel $LN77
	DD	imagerel $LN77+42
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z DD 060f21H
	DD	04e40fH
	DD	0b740aH
	DD	0a3405H
	DD	imagerel $LN77
	DD	imagerel $LN77+42
	DD	imagerel $unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z DD 030701H
	DD	060034207H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AEAAXQEAH_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN77
	DD	imagerel $LN77+18
	DD	imagerel $unwind$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN77+18
	DD	imagerel $LN77+120
	DD	imagerel $chain$3$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	05e405H
	DD	imagerel $LN77+18
	DD	imagerel $LN77+120
	DD	imagerel $chain$3$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 083021H
	DD	0c3430H
	DD	04f41aH
	DD	06740eH
	DD	075405H
	DD	imagerel $LN77
	DD	imagerel $LN77+18
	DD	imagerel $unwind$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	060027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z DB 04H
	DB	015H, 02H
	DB	02H
	DB	0c4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z
	DD	imagerel $ip2state$??$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z DD 0a1f11H
	DD	017541fH
	DD	016341fH
	DD	0f01bd21fH
	DD	0c017e019H
	DD	060147015H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z DB 06H
	DB	'%', 02H
	DB	02H
	DB	'('
	DB	04H
	DB	0b4H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z
	DD	imagerel $ip2state$??$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z DD 0a1d11H
	DD	018341dH
	DD	0f019d21dH
	DD	0d015e017H
	DD	07011c013H
	DD	0500f6010H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DB 04H
	DB	094H
	DB	02H
	DB	05H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 061e19H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
	DD	03aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@_KPEAV?$vector@HV?$allocator@H@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?8HV?$allocator@H@std@@@std@@YA_NAEBV?$vector@HV?$allocator@H@std@@@0@0@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Freenode@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAHV?$allocator@H@std@@@std@@YAPEAHQEAH0PEAHAEAV?$allocator@H@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Zero_range@PEAH@std@@YAPEAHQEAH0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEBHPEAH@std@@YAPEAHPEBH0PEAH@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z DD 021H
	DD	imagerel $LN68
	DD	imagerel $LN68+75
	DD	imagerel $unwind$??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z DD 020521H
	DD	0d6405H
	DD	imagerel $LN68
	DD	imagerel $LN68+75
	DD	imagerel $unwind$??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z DD 060c01H
	DD	0f008320cH
	DD	07004e006H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z DB 04H
	DB	0e0H
	DB	02H
	DB	'|'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z
	DD	imagerel $ip2state$??$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z DD 040811H
	DD	07004d208H
	DD	030026003H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z DB 06H
	DB	0f8H
	DB	02H
	DB	'('
	DB	04H
	DB	080H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z
	DD	imagerel $ip2state$??$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z DD 060c11H
	DD	015340cH
	DD	07008d20cH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEBV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEBV?$vector@HV?$allocator@H@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$equal@PEBHPEBH@std@@YA_NQEBH00@Z DD 011319H
	DD	06204H
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy_n@PEAHV?$allocator@H@std@@@std@@YAPEAHPEAH_K0AEAV?$allocator@H@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove_n@PEAHPEAH@std@@YAPEAHPEAH_K0@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_n_unchecked4@PEAH_KPEAH@std@@YAPEAHPEAH_K0@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z DD 021H
	DD	imagerel $LN129
	DD	imagerel $LN129+165
	DD	imagerel $unwind$??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z DD 061521H
	DD	0ae415H
	DD	09640dH
	DD	085405H
	DD	imagerel $LN129
	DD	imagerel $LN129+165
	DD	imagerel $unwind$??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z DD 040901H
	DD	0f0053209H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z DB 02H
	DB	'R'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z
	DD	imagerel $ip2state$??$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z DD 060f11H
	DD	0a640fH
	DD	09340fH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_hint@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z DD 0a1601H
	DD	0c5416H
	DD	0a3416H
	DD	0f0123216H
	DD	0c00ee010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z DB 04H
	DB	'R'
	DB	02H
	DB	' '
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z DB 04H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
	DB	03cH
	DD	imagerel ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z
	DD	imagerel $ip2state$??$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z DD 060f11H
	DD	0a640fH
	DD	09340fH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z DD 021H
	DD	imagerel $LN65
	DD	imagerel $LN65+63
	DD	imagerel $unwind$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN65
	DD	imagerel $LN65+63
	DD	imagerel $unwind$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$equal@PEBHPEBHU?$equal_to@X@std@@@std@@YA_NQEBH00U?$equal_to@X@0@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z DB 02H
	DB	'2'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z DD 020a11H
	DD	03006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z DB 02H
	DB	'2'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z
	DD	imagerel $ip2state$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z DD 020a11H
	DD	03006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+37
	DD	imagerel $unwind$??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z DD 020521H
	DD	023405H
	DD	imagerel $LN47
	DD	imagerel $LN47+37
	DD	imagerel $unwind$??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z DD 030601H
	DD	046406H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z DD 021H
	DD	imagerel $LN65
	DD	imagerel $LN65+63
	DD	imagerel $unwind$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN65
	DD	imagerel $LN65+63
	DD	imagerel $unwind$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z DD 040a01H
	DD	09340aH
	DD	06006320aH
xdata	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$dead$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 169  :         (void)_Size;
; 170  :         return _Where;

	mov	rax, rdx

; 171  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
__formal$ = 24
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 66   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 67   :         _Data._What = _Message;
; 68   :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 72   :     {

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0
	lea	rdx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy

; 74   :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rdx, QWORD PTR [rcx+8]
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	test	rdx, rdx
	cmovne	rax, rdx

; 96   :     }

	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN6@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN6@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 130  :     {

	lea	rax, OFFSET FLAT:??_7bad_alloc@std@@6B@

; 65   :         : _Data()

	mov	QWORD PTR [rcx+16], 0

; 130  :     {

	mov	QWORD PTR [rcx], rax

; 131  :     }

	mov	rax, rcx

; 67   :         _Data._What = _Message;

	mov	QWORD PTR [rcx+8], rdx

; 131  :     }

	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN9@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN9@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vcruntime_exception.h
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 67   :         _Data._What = _Message;

	lea	rax, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rax

; 141  :     {

	lea	rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rcx], rax

; 142  :     }

	mov	rax, rcx
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN12@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN12@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 328  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN4:
	sub	rsp, 72					; 00000048H

; 329  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN3@Throw_bad_:
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 72   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0

; 71   :         : _Data()

	lea	rdx, QWORD PTR [rbx+8]

; 72   :     {

	mov	QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 72   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	xorps	xmm0, xmm0

; 71   :         : _Data()

	lea	rdx, QWORD PTR [rbx+8]

; 72   :     {

	mov	QWORD PTR [rbx], rcx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	movups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 642  :         return LLONG_MAX;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 643  :     }

	ret	0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 8
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 77   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 145  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN13:
	sub	rsp, 40					; 00000028H

; 146  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 147  :     _Bytes += _Non_user_size;

	add	QWORD PTR [rdx], 39			; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax-8]

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rdx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN7@Adjust_man

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	QWORD PTR [rcx], rdx

; 166  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@Adjust_man:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@Adjust_man:
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1145 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1146 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

	ret	0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1147 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1152 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Getcont@_Iterator_base0@std@@QEBAPEBU_Container_base0@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Getcont@_Iterator_base0@std@@QEBAPEBU_Container_base0@2@XZ PROC ; std::_Iterator_base0::_Getcont, COMDAT

; 1154 :         return nullptr;

	xor	eax, eax

; 1155 :     }

	ret	0
?_Getcont@_Iterator_base0@std@@QEBAPEBU_Container_base0@2@XZ ENDP ; std::_Iterator_base0::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1411 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	rax, rcx
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1414 :     _CONSTEXPR20 void _Release() noexcept {}

	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Throw_tree_length_error@std@@YAXXZ
_TEXT	SEGMENT
?_Throw_tree_length_error@std@@YAXXZ PROC		; std::_Throw_tree_length_error, COMDAT

; 417  : [[noreturn]] inline void _Throw_tree_length_error() {

$LN4:
	sub	rsp, 40					; 00000028H

; 418  :     _Xlength_error("map/set too long");

	lea	rcx, OFFSET FLAT:??_C@_0BB@GCADKGJO@map?1set?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Throw_tree:
?_Throw_tree_length_error@std@@YAXXZ ENDP		; std::_Throw_tree_length_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\VSproject\\II\II\Main.cpp
;	COMDAT ?combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z
_TEXT	SEGMENT
$T1 = 48
$T18 = 56
$T50 = 56
__$ReturnUdt$GSCopy$1$ = 72
$T25 = 80
_Loc$67 = 80
$T58 = 80
_Loc$68 = 80
__$ReturnUdt$GSCopy$ = 112
$T17 = 120
$T49 = 120
target$GSCopy$ = 144
temp$ = 152
s$ = 168
__$ArrayPad$ = 184
this$ = 272
__$ReturnUdt$ = 280
candidates$ = 288
target$dead$ = 296
?combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z PROC ; Solution::combinationSum2, COMDAT

; 10   : 	vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {

$LN721:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-39]
	sub	rsp, 208				; 000000d0H
	movaps	XMMWORD PTR [rsp+192], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-169], rax
	mov	r13, r8
	mov	QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-169], rdx
	mov	r15, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-169], rdx
	xor	r14d, r14d
	mov	DWORD PTR $T1[rbp-169], r14d
	mov	DWORD PTR target$GSCopy$[rbp-169], 10
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1555 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdi, QWORD PTR [rcx+8]
	mov	rdx, QWORD PTR [rcx]
	mov	rcx, rdi
	sub	rcx, rdx
	sar	rcx, 2

; 1556 :         if (_Newsize < _Oldsize) { // trim

	cmp	rcx, 51					; 00000033H
	jbe	SHORT $LN632@combinatio

; 1557 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+204]

; 1558 :             _Orphan_range(_Newlast, _Mylast);
; 1559 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1560 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1561 :             _Mylast = _Newlast;
; 1562 :             return;

	jmp	SHORT $LN716@combinatio
$LN632@combinatio:

; 1563 :         }
; 1564 : 
; 1565 :         if (_Newsize > _Oldsize) { // append

	jae	SHORT $LN633@combinatio

; 1566 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [r15+16]
	sub	rax, rdx
	sar	rax, 2

; 1567 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rax, 51					; 00000033H
	jae	SHORT $LN634@combinatio

; 1568 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, r15
	call	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize_reallocate<std::_Value_init_tag>

; 1569 :                 return;

	jmp	SHORT $LN633@combinatio
$LN634@combinatio:

; 1570 :             }
; 1571 : 
; 1572 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1573 :             const pointer _Oldlast = _Mylast;
; 1574 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1575 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1576 :             } else {
; 1577 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1578 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	eax, 51					; 00000033H
	sub	rax, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 2010 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [rax*4]

; 1995 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	xor	edx, edx
	mov	rcx, rdi
	call	memset

; 2010 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rax, QWORD PTR [rdi+rbx]
$LN716@combinatio:
; File G:\VSproject\\II\II\Main.cpp

; 12   : 		for (auto i : candidates) {

	mov	QWORD PTR [r15+8], rax
$LN633@combinatio:
	mov	r8, QWORD PTR [r13+8]
	mov	rdx, QWORD PTR [r13]
	cmp	rdx, r8
	je	SHORT $LN3@combinatio
	npad	3
$LL4@combinatio:

; 13   : 			candidates_count[i]++;

	movsxd	rcx, DWORD PTR [rdx]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1887 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r15]
; File G:\VSproject\\II\II\Main.cpp

; 13   : 			candidates_count[i]++;

	inc	DWORD PTR [rax+rcx*4]

; 12   : 		for (auto i : candidates) {

	add	rdx, 4
	cmp	rdx, r8
	jne	SHORT $LL4@combinatio
$LN3@combinatio:
	xorps	xmm0, xmm0
	movups	XMMWORD PTR s$[rbp-169], xmm0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	r12, QWORD PTR [r13+8]
	mov	rbx, QWORD PTR [r13]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	QWORD PTR s$[rbp-169], r14
	mov	QWORD PTR s$[rbp-161], r14
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1941 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	rdi, rax
	mov	QWORD PTR s$[rbp-169], rax
$LN718@combinatio:

; 1044 :             _Loc = _Find_hint(_Hint, _In_place_key_extractor::_Extract(_Vals...));

	cmp	rbx, r12
	je	$LN710@combinatio
	mov	r9, rbx
	mov	r8, rsi
	lea	rdx, QWORD PTR $T17[rbp-169]
	lea	rcx, QWORD PTR s$[rbp-169]
	call	??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_hint<int>
	movups	xmm6, XMMWORD PTR [rax]
	movsd	xmm0, QWORD PTR [rax+16]
	movsd	QWORD PTR _Loc$67[rbp-153], xmm0

; 1045 :             if (_Loc._Duplicate) {

	cmp	BYTE PTR _Loc$67[rbp-153], 0
	jne	SHORT $LN482@combinatio

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	QWORD PTR s$[rbp-161], rax
	je	$LN665@combinatio
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	lea	rax, QWORD PTR s$[rbp-169]
	mov	QWORD PTR $T18[rbp-169], rax

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T18[rbp-161], r14

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r8, rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	eax, DWORD PTR [rbx]
	mov	DWORD PTR [r8+28], eax

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [r8], rdi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [r8+8], rdi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [r8+16], rdi

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [r8+24], 0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T18[rbp-161], r14
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1066 :         return _Scary->_Insert_node(_Loc._Location, _Inserted);

	movaps	XMMWORD PTR $T25[rbp-169], xmm6
	lea	rdx, QWORD PTR $T25[rbp-169]
	lea	rcx, QWORD PTR s$[rbp-169]
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@U?$_Tree_id@PEAU?$_Tree_node@HPEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Insert_node
	mov	rdi, QWORD PTR s$[rbp-169]
$LN482@combinatio:

; 1259 :         for (; _First != _Last; ++_First) {

	add	rbx, 4
	jmp	$LN718@combinatio
$LN710@combinatio:

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	r9, QWORD PTR [rdi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1233 :         auto _UFirst             = _Get_unwrapped(_First);

	mov	rax, r9

; 1234 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1235 :         _Iter_diff_t<_InIt> _Off = 0;

	mov	r8, r14

; 1236 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	r9, rdi
	je	SHORT $LN598@combinatio
$LL609@combinatio:

; 1237 :             ++_Off;

	inc	r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rcx, QWORD PTR [rax+16]
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LN608@combinatio

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rcx, QWORD PTR [rax+8]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN607@combinatio
	npad	7
$LL606@combinatio:
	cmp	rax, QWORD PTR [rcx+16]
	jne	SHORT $LN607@combinatio

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rax, rcx

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rcx, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL606@combinatio
$LN607@combinatio:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rax, rcx

; 58   :         } else {

	jmp	SHORT $LN671@combinatio
$LN608@combinatio:

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rax, rcx

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rdx, QWORD PTR [rcx]
	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN671@combinatio
	npad	12
$LL612@combinatio:

; 454  :             _Pnode = _Pnode->_Left;

	mov	rax, rdx

; 438  : 
; 439  :     enum _Redbl { // colors for link to parent
; 440  :         _Red,
; 441  :         _Black
; 442  :     };
; 443  : 
; 444  :     static _Nodeptr _Max(_Nodeptr _Pnode) noexcept { // return rightmost node in subtree at _Pnode
; 445  :         while (!_Pnode->_Right->_Isnil) {
; 446  :             _Pnode = _Pnode->_Right;
; 447  :         }
; 448  : 
; 449  :         return _Pnode;
; 450  :     }
; 451  : 
; 452  :     static _Nodeptr _Min(_Nodeptr _Pnode) noexcept { // return leftmost node in subtree at _Pnode
; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rdx]
	mov	rdx, rcx
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL612@combinatio
$LN671@combinatio:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1236 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, rdi
	jne	SHORT $LL609@combinatio
$LN598@combinatio:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1450 :             _Assign_counted_range(_UFirst, _Count);

	mov	rdx, r9
	mov	rcx, r13
	call	??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@_K@Z ; std::vector<int,std::allocator<int> >::_Assign_counted_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> >
	xorps	xmm0, xmm0
	mov	rdi, QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-169]
	movups	XMMWORD PTR [rdi], xmm0

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdi], r14
	mov	QWORD PTR [rdi+8], r14
	mov	QWORD PTR [rdi+16], r14
; File G:\VSproject\\II\II\Main.cpp

; 30   : 		return result;

	mov	DWORD PTR $T1[rbp-169], 1

; 14   : 		}
; 15   : 		set<int>s(candidates.begin(), candidates.end());
; 16   : 		candidates.assign(s.begin(), s.end());
; 17   : 		vector<vector<int>> result;
; 18   : 		dfs(result, candidates, 0, target, target);

	lea	rax, QWORD PTR target$GSCopy$[rbp-169]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR target$GSCopy$[rbp-169]
	mov	DWORD PTR [rsp+32], eax
	xor	r9d, r9d
	mov	r8, r13
	mov	rdx, rdi
	mov	rcx, r15
	call	?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z ; Solution::dfs

; 19   : 		int sum = 0;

	mov	edx, r14d
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1942 :         return _My_data._Mylast[-1];

	mov	rax, QWORD PTR [rdi+8]
; File G:\VSproject\\II\II\Main.cpp

; 20   : 		for (auto i : result.back())

	mov	rcx, QWORD PTR [rax-24]
	mov	r9, QWORD PTR [rax-16]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1450 :             _Assign_counted_range(_UFirst, _Count);

	mov	rax, r14
	mov	r8, r9
	sub	r8, rcx
	add	r8, 3
	shr	r8, 2
	cmp	rcx, r9
	cmova	r8, r14
; File G:\VSproject\\II\II\Main.cpp

; 20   : 		for (auto i : result.back())

	test	r8, r8
	je	SHORT $LN680@combinatio
	cmp	r8, 8
	jb	SHORT $LN680@combinatio

; 21   : 		{
; 22   : 			sum += i;

	and	r8, -8
	xorps	xmm1, xmm1
	xorps	xmm2, xmm2
	npad	8
$LL7@combinatio:
	movdqu	xmm0, XMMWORD PTR [rcx]
	paddd	xmm1, xmm0
	movdqu	xmm0, XMMWORD PTR [rcx+16]
	paddd	xmm2, xmm0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1450 :             _Assign_counted_range(_UFirst, _Count);

	add	rcx, 32					; 00000020H
; File G:\VSproject\\II\II\Main.cpp

; 20   : 		for (auto i : result.back())

	add	rax, 8
	cmp	rax, r8
	jne	SHORT $LL7@combinatio
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1450 :             _Assign_counted_range(_UFirst, _Count);

	paddd	xmm1, xmm2
	movdqa	xmm0, xmm1
	psrldq	xmm0, 8
	paddd	xmm1, xmm0
	movdqa	xmm0, xmm1
	psrldq	xmm0, 4
	paddd	xmm1, xmm0
	movd	edx, xmm1
$LN680@combinatio:
; File G:\VSproject\\II\II\Main.cpp

; 20   : 		for (auto i : result.back())

	cmp	rcx, r9
	je	SHORT $LN6@combinatio
$LL679@combinatio:

; 21   : 		{
; 22   : 			sum += i;

	add	edx, DWORD PTR [rcx]

; 20   : 		for (auto i : result.back())

	add	rcx, 4
	cmp	rcx, r9
	jne	SHORT $LL679@combinatio
$LN6@combinatio:

; 23   : 		}
; 24   : 		if (sum != target)

	cmp	edx, DWORD PTR target$GSCopy$[rbp-169]
	je	SHORT $LN709@combinatio
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1728 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

	mov	rbx, QWORD PTR [rdi+8]

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx-24]
	test	rcx, rcx
	je	SHORT $LN394@combinatio

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR [rbx-8]
	sub	rax, rcx
	sar	rax, 2
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN410@combinatio

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN407@combinatio

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN410@combinatio:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx-24], r14

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx-16], r14

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx-8], r14
$LN394@combinatio:

; 1730 :         --_Mylast;

	add	QWORD PTR [rdi+8], -24
$LN709@combinatio:
	xorps	xmm0, xmm0
	movups	XMMWORD PTR temp$[rbp-169], xmm0

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	r12, QWORD PTR [rdi+8]
	mov	rsi, QWORD PTR [rdi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	QWORD PTR temp$[rbp-169], r14
	mov	QWORD PTR temp$[rbp-161], r14
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r15, rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1941 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR temp$[rbp-169], rax

; 1259 :         for (; _First != _Last; ++_First) {

	cmp	rsi, r12
	je	$LN711@combinatio
	mov	r13, 329406144173384850			; 0492492492492492H
	npad	5
$LL75@combinatio:

; 1044 :             _Loc = _Find_hint(_Hint, _In_place_key_extractor::_Extract(_Vals...));

	mov	r9, rsi
	mov	r8, r15
	lea	rdx, QWORD PTR $T49[rbp-169]
	lea	rcx, QWORD PTR temp$[rbp-169]
	call	??$_Find_hint@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Find_hint<std::vector<int,std::allocator<int> > >
	movups	xmm6, XMMWORD PTR [rax]
	movsd	xmm0, QWORD PTR [rax+16]
	movsd	QWORD PTR _Loc$68[rbp-153], xmm0

; 1045 :             if (_Loc._Duplicate) {

	cmp	BYTE PTR _Loc$68[rbp-153], 0
	jne	SHORT $LN73@combinatio

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

	cmp	QWORD PTR temp$[rbp-161], r13
	je	$LN666@combinatio

; 1050 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

	mov	rbx, QWORD PTR temp$[rbp-169]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	lea	rax, QWORD PTR temp$[rbp-169]
	mov	QWORD PTR $T50[rbp-169], rax

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T50[rbp-161], r14

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
	mov	QWORD PTR $T50[rbp-161], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rcx, QWORD PTR [rax+32]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, rsi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [rdi], rbx

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [rdi+8], rbx

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [rdi+16], rbx

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [rdi+24], 0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T50[rbp-161], r14
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1066 :         return _Scary->_Insert_node(_Loc._Location, _Inserted);

	movaps	XMMWORD PTR $T58[rbp-169], xmm6
	mov	r8, rdi
	lea	rdx, QWORD PTR $T58[rbp-169]
	lea	rcx, QWORD PTR temp$[rbp-169]
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Insert_node
$LN73@combinatio:

; 1259 :         for (; _First != _Last; ++_First) {

	add	rsi, 24
	cmp	rsi, r12
	jne	$LL75@combinatio
	mov	r15, QWORD PTR temp$[rbp-169]
	mov	rdi, QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-169]
$LN711@combinatio:

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	r9, QWORD PTR [r15]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1233 :         auto _UFirst             = _Get_unwrapped(_First);

	mov	rax, r9

; 1236 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	r9, r15
	je	SHORT $LN223@combinatio
	npad	10
$LL234@combinatio:

; 1237 :             ++_Off;

	inc	r14
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rcx, QWORD PTR [rax+16]
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LN233@combinatio

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rcx, QWORD PTR [rax+8]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN232@combinatio
$LL231@combinatio:
	cmp	rax, QWORD PTR [rcx+16]
	jne	SHORT $LN232@combinatio

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rax, rcx

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rcx, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL231@combinatio
$LN232@combinatio:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rax, rcx

; 58   :         } else {

	jmp	SHORT $LN677@combinatio
$LN407@combinatio:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN233@combinatio:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rax, rcx

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rdx, QWORD PTR [rcx]
	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN677@combinatio
	npad	14
$LL237@combinatio:

; 454  :             _Pnode = _Pnode->_Left;

	mov	rax, rdx

; 438  : 
; 439  :     enum _Redbl { // colors for link to parent
; 440  :         _Red,
; 441  :         _Black
; 442  :     };
; 443  : 
; 444  :     static _Nodeptr _Max(_Nodeptr _Pnode) noexcept { // return rightmost node in subtree at _Pnode
; 445  :         while (!_Pnode->_Right->_Isnil) {
; 446  :             _Pnode = _Pnode->_Right;
; 447  :         }
; 448  : 
; 449  :         return _Pnode;
; 450  :     }
; 451  : 
; 452  :     static _Nodeptr _Min(_Nodeptr _Pnode) noexcept { // return leftmost node in subtree at _Pnode
; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rdx]
	mov	rdx, rcx
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL237@combinatio
$LN677@combinatio:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1236 :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, r15
	jne	SHORT $LL234@combinatio
$LN223@combinatio:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1450 :             _Assign_counted_range(_UFirst, _Count);

	mov	r8, r14
	mov	rdx, r9
	mov	rcx, rdi
	call	??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@_K@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Assign_counted_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> >
	npad	1
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	r8, QWORD PTR temp$[rbp-169]
	mov	r8, QWORD PTR [r8+8]
	lea	rdx, QWORD PTR temp$[rbp-169]
	lea	rcx, QWORD PTR temp$[rbp-169]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Erase_tree<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, QWORD PTR temp$[rbp-169]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	rcx, QWORD PTR s$[rbp-169]
	mov	rbx, QWORD PTR [rcx+8]

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN283@combinatio
	npad	11
$LL282@combinatio:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	r8, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR s$[rbp-169]
	lea	rcx, QWORD PTR s$[rbp-169]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, rbx

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rbx, QWORD PTR [rbx]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL282@combinatio
	mov	rcx, QWORD PTR s$[rbp-169]
$LN283@combinatio:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\VSproject\\II\II\Main.cpp

; 30   : 		return result;

	mov	rax, rdi

; 31   : 	}

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-169]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+296]
	movaps	xmm6, XMMWORD PTR [rsp+192]
	add	rsp, 208				; 000000d0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN666@combinatio:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1630 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	npad	1
$LN665@combinatio:
	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN715@combinatio:
?combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z ENDP ; Solution::combinationSum2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T18 = 56
$T50 = 56
__$ReturnUdt$GSCopy$1$ = 72
$T25 = 80
_Loc$67 = 80
$T58 = 80
_Loc$68 = 80
__$ReturnUdt$GSCopy$ = 112
$T17 = 120
$T49 = 120
target$GSCopy$ = 144
temp$ = 152
s$ = 168
__$ArrayPad$ = 184
this$ = 272
__$ReturnUdt$ = 280
candidates$ = 288
target$dead$ = 296
?dtor$11@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA PROC ; `Solution::combinationSum2'::`1'::dtor$11
	lea	rcx, QWORD PTR s$[rdx]
	jmp	??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
?dtor$11@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA ENDP ; `Solution::combinationSum2'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T18 = 56
$T50 = 56
__$ReturnUdt$GSCopy$1$ = 72
$T25 = 80
_Loc$67 = 80
$T58 = 80
_Loc$68 = 80
__$ReturnUdt$GSCopy$ = 112
$T17 = 120
$T49 = 120
target$GSCopy$ = 144
temp$ = 152
s$ = 168
__$ArrayPad$ = 184
this$ = 272
__$ReturnUdt$ = 280
candidates$ = 288
target$dead$ = 296
?dtor$14@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA PROC ; `Solution::combinationSum2'::`1'::dtor$14
	lea	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
?dtor$14@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA ENDP ; `Solution::combinationSum2'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T18 = 56
$T50 = 56
__$ReturnUdt$GSCopy$1$ = 72
$T25 = 80
_Loc$67 = 80
$T58 = 80
_Loc$68 = 80
__$ReturnUdt$GSCopy$ = 112
$T17 = 120
$T49 = 120
target$GSCopy$ = 144
temp$ = 152
s$ = 168
__$ArrayPad$ = 184
this$ = 272
__$ReturnUdt$ = 280
candidates$ = 288
target$dead$ = 296
?dtor$0@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA PROC ; `Solution::combinationSum2'::`1'::dtor$0
	lea	rcx, QWORD PTR s$[rdx]
	jmp	??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@XZ
?dtor$0@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA ENDP ; `Solution::combinationSum2'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T18 = 56
$T50 = 56
__$ReturnUdt$GSCopy$1$ = 72
$T25 = 80
_Loc$67 = 80
$T58 = 80
_Loc$68 = 80
__$ReturnUdt$GSCopy$ = 112
$T17 = 120
$T49 = 120
target$GSCopy$ = 144
temp$ = 152
s$ = 168
__$ArrayPad$ = 184
this$ = 272
__$ReturnUdt$ = 280
candidates$ = 288
target$dead$ = 296
?dtor$1@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA PROC ; `Solution::combinationSum2'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN12@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
$LN12@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA ENDP ; `Solution::combinationSum2'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T18 = 56
$T50 = 56
__$ReturnUdt$GSCopy$1$ = 72
$T25 = 80
_Loc$67 = 80
$T58 = 80
_Loc$68 = 80
__$ReturnUdt$GSCopy$ = 112
$T17 = 120
$T49 = 120
target$GSCopy$ = 144
temp$ = 152
s$ = 168
__$ArrayPad$ = 184
this$ = 272
__$ReturnUdt$ = 280
candidates$ = 288
target$dead$ = 296
?dtor$3@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA PROC ; `Solution::combinationSum2'::`1'::dtor$3
	lea	rcx, QWORD PTR temp$[rdx]
	jmp	??1?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::~_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >
?dtor$3@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA ENDP ; `Solution::combinationSum2'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T18 = 56
$T50 = 56
__$ReturnUdt$GSCopy$1$ = 72
$T25 = 80
_Loc$67 = 80
$T58 = 80
_Loc$68 = 80
__$ReturnUdt$GSCopy$ = 112
$T17 = 120
$T49 = 120
target$GSCopy$ = 144
temp$ = 152
s$ = 168
__$ArrayPad$ = 184
this$ = 272
__$ReturnUdt$ = 280
candidates$ = 288
target$dead$ = 296
?dtor$6@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA PROC ; `Solution::combinationSum2'::`1'::dtor$6
	lea	rcx, QWORD PTR $T50[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
?dtor$6@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA ENDP ; `Solution::combinationSum2'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T18 = 56
$T50 = 56
__$ReturnUdt$GSCopy$1$ = 72
$T25 = 80
_Loc$67 = 80
$T58 = 80
_Loc$68 = 80
__$ReturnUdt$GSCopy$ = 112
$T17 = 120
$T49 = 120
target$GSCopy$ = 144
temp$ = 152
s$ = 168
__$ArrayPad$ = 184
this$ = 272
__$ReturnUdt$ = 280
candidates$ = 288
target$dead$ = 296
?dtor$5@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA PROC ; `Solution::combinationSum2'::`1'::dtor$5
	lea	rcx, QWORD PTR $T50[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$5@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA ENDP ; `Solution::combinationSum2'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T18 = 56
$T50 = 56
__$ReturnUdt$GSCopy$1$ = 72
$T25 = 80
_Loc$67 = 80
$T58 = 80
_Loc$68 = 80
__$ReturnUdt$GSCopy$ = 112
$T17 = 120
$T49 = 120
target$GSCopy$ = 144
temp$ = 152
s$ = 168
__$ArrayPad$ = 184
this$ = 272
__$ReturnUdt$ = 280
candidates$ = 288
target$dead$ = 296
?dtor$2@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA PROC ; `Solution::combinationSum2'::`1'::dtor$2
	lea	rcx, QWORD PTR temp$[rdx]
	jmp	??1?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ
?dtor$2@?0??combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z@4HA ENDP ; `Solution::combinationSum2'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
;	COMDAT ?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z
_TEXT	SEGMENT
$T89 = 48
$T40 = 48
$T1 = 48
original_target$GSCopy$1$ = 72
this$ = 160
result$ = 168
candidates$ = 176
index$ = 184
target$ = 192
original_target$ = 200
?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z PROC ; Solution::dfs, COMDAT

; 32   : 	int dfs(vector<vector<int>>& result, vector<int>& candidates, int index, int target, int& original_target) {

$LN545:
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 88					; 00000058H
	movsxd	rbx, r9d
	mov	r15, r8
	mov	rdi, rdx
	mov	r12, rcx
	mov	r13d, DWORD PTR target$[rbp-88]
	mov	rax, QWORD PTR original_target$[rbp-88]
	mov	QWORD PTR original_target$GSCopy$1$[rbp-88], rax

; 33   : 		if (target < 0) {

	test	r13d, r13d
	js	$LN18@dfs

; 34   : 			return 0;
; 35   : 		}
; 36   : 		if (target == 0) {

	jne	SHORT $LN6@dfs

; 37   : 			return 1;

	mov	eax, 1
	jmp	$LN1@dfs
$LN6@dfs:

; 38   : 		}
; 39   : 		if (target == original_target) {

	xor	esi, esi
	cmp	r13d, DWORD PTR [rax]
	jne	SHORT $LN159@dfs
	xorps	xmm0, xmm0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T1[rbp-88], xmm0
	mov	QWORD PTR $T1[rbp-72], rsi

; 779  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rdi+16]
	je	SHORT $LN138@dfs
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	eax, esi
	mov	ecx, esi
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdx], rsi
	mov	QWORD PTR [rdx+8], rsi
	mov	QWORD PTR [rdx+16], rsi

; 804  :         ++_Mylast;

	add	QWORD PTR [rdi+8], 24

; 780  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN137@dfs
$LN138@dfs:

; 781  :         }
; 782  : 
; 783  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T1[rbp-88]
	mov	rcx, rdi
	call	??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_reallocate<std::vector<int,std::allocator<int> > >
	mov	rax, QWORD PTR $T1[rbp-72]
	mov	rcx, QWORD PTR $T1[rbp-88]
$LN137@dfs:

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN159@dfs

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rax, rcx
	sar	rax, 2
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN175@dfs

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN474@dfs
$LN175@dfs:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN159@dfs:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1867 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, QWORD PTR [r15+8]
	mov	r8, QWORD PTR [r15]
	mov	rax, rdx
	sub	rax, r8
	sar	rax, 2
; File G:\VSproject\\II\II\Main.cpp

; 42   : 		for (int i = index; i < candidates.size(); i++) {

	cmp	rbx, rax
	jae	$LN3@dfs
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1866 :         auto& _My_data = _Mypair._Myval2;

	lea	r14, QWORD PTR [rbx*4]
	npad	8
$LL4@dfs:

; 1887 :         return _My_data._Myfirst[_Pos];

	mov	r9, QWORD PTR [r12]
; File G:\VSproject\\II\II\Main.cpp

; 43   : 			if (candidates_count[candidates[i]]) {

	movsxd	rax, DWORD PTR [r8+r14]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1887 :         return _My_data._Myfirst[_Pos];

	lea	rcx, QWORD PTR [r9+rax*4]
; File G:\VSproject\\II\II\Main.cpp

; 43   : 			if (candidates_count[candidates[i]]) {

	mov	eax, DWORD PTR [rcx]
	test	eax, eax
	je	$LN8@dfs

; 44   : 				candidates_count[candidates[i]]--;

	dec	eax
	mov	DWORD PTR [rcx], eax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1887 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [r15]
	add	r8, r14

; 1942 :         return _My_data._Mylast[-1];

	mov	rcx, QWORD PTR [rdi+8]
	sub	rcx, 24

; 779  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN47@dfs

; 795  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax

; 796  :         } else {
; 797  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 798  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 799  :             _ASAN_VECTOR_RELEASE_GUARD;
; 800  :         }
; 801  : 
; 802  :         _Orphan_range(_Mylast, _Mylast);
; 803  :         _Ty& _Result = *_Mylast;
; 804  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 4

; 780  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN46@dfs
$LN47@dfs:

; 781  :         }
; 782  : 
; 783  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	call	??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
$LN46@dfs:

; 1887 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r15]
; File G:\VSproject\\II\II\Main.cpp

; 46   : 				int rev = dfs(result, candidates, i, target - candidates[i], original_target);

	mov	ecx, r13d
	sub	ecx, DWORD PTR [r14+rax]
	mov	rax, QWORD PTR original_target$GSCopy$1$[rbp-88]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, ebx
	mov	r8, r15
	mov	rdx, rdi
	mov	rcx, r12
	call	?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z ; Solution::dfs

; 47   : 				if (rev == 0) {	

	test	eax, eax
	je	$LN461@dfs

; 48   : 					return 2;
; 49   : 				}
; 50   : 				else if (rev == 1) {

	cmp	eax, 1
	je	$LN516@dfs

; 52   : 						result.push_back(vector<int>(result.back()));
; 53   : 					}
; 54   : 					return 2;
; 55   : 				}
; 56   : 				else if (rev == 2) {

	cmp	eax, 2
	jne	SHORT $LN15@dfs

; 57   : 					candidates_count[result.back().back()]++;

	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rax-16]
	movsxd	rdx, DWORD PTR [rcx-4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1887 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
; File G:\VSproject\\II\II\Main.cpp

; 57   : 					candidates_count[result.back().back()]++;

	inc	DWORD PTR [rax+rdx*4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1702 :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR [rdi+8]

; 1703 : 
; 1704 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1705 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1706 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1707 : 
; 1708 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1709 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
; 1710 :         _ASAN_VECTOR_MODIFY(-1);
; 1711 :         --_Mylast;

	add	QWORD PTR [rax-16], -4
; File G:\VSproject\\II\II\Main.cpp

; 61   : 				}

	jmp	SHORT $LN541@dfs
$LN15@dfs:

; 62   : 				else if (rev == 3) {

	cmp	eax, 3
	jne	SHORT $LN379@dfs
$LN541@dfs:

; 63   : 					candidates_count[result.back().back()]++;
; 64   : 					result.back().pop_back();
; 65   : 				}
; 66   : 			}

	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rax-16]
	movsxd	rdx, DWORD PTR [rcx-4]
	mov	rax, QWORD PTR [r12]
	inc	DWORD PTR [rax+rdx*4]
	mov	rax, QWORD PTR [rdi+8]
	add	QWORD PTR [rax-16], -4
$LN379@dfs:
	inc	ebx
	add	r14, 4
	jmp	$LN2@dfs
$LN8@dfs:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1867 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	sub	rdx, r8
	sar	rdx, 2
; File G:\VSproject\\II\II\Main.cpp

; 67   : 			else if (i < candidates.size() - 1) {

	lea	rcx, QWORD PTR [rdx-1]
	movsxd	rax, ebx
	cmp	rax, rcx
	jae	$LN18@dfs
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1887 :         return _My_data._Myfirst[_Pos];

	lea	rax, QWORD PTR [r14+4]
	mov	r14, rax
; File G:\VSproject\\II\II\Main.cpp

; 68   : 				candidates_count[candidates[i + 1]]--;

	movsxd	rax, DWORD PTR [r8+rax]
	dec	DWORD PTR [r9+rax*4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1887 :         return _My_data._Myfirst[_Pos];

	mov	r8, QWORD PTR [r15]
	add	r8, r14

; 1942 :         return _My_data._Mylast[-1];

	mov	rcx, QWORD PTR [rdi+8]
	sub	rcx, 24

; 779  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN62@dfs

; 795  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax

; 796  :         } else {
; 797  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 798  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 799  :             _ASAN_VECTOR_RELEASE_GUARD;
; 800  :         }
; 801  : 
; 802  :         _Orphan_range(_Mylast, _Mylast);
; 803  :         _Ty& _Result = *_Mylast;
; 804  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 4

; 780  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN61@dfs
$LN62@dfs:

; 781  :         }
; 782  : 
; 783  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	call	??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
$LN61@dfs:

; 1887 :         return _My_data._Myfirst[_Pos];

	mov	rcx, QWORD PTR [r15]
; File G:\VSproject\\II\II\Main.cpp

; 70   : 				int rev = dfs(result, candidates, i + 1, target - candidates[i + 1], original_target);

	lea	r9d, DWORD PTR [rbx+1]
	mov	ebx, r9d
	mov	eax, r13d
	sub	eax, DWORD PTR [rcx+r14]
	mov	rcx, QWORD PTR original_target$GSCopy$1$[rbp-88]
	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [rsp+32], eax
	mov	r8, r15
	mov	rdx, rdi
	mov	rcx, r12
	call	?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z ; Solution::dfs

; 71   : 				if (rev == 0) {

	test	eax, eax
	je	$LN461@dfs

; 72   : 					return 2;
; 73   : 				}
; 74   : 				else if (rev == 1) {

	cmp	eax, 1
	je	$LN518@dfs

; 79   : 				}
; 80   : 				else if (rev == 2) {

	cmp	eax, 2
	jne	SHORT $LN25@dfs

; 81   : 					candidates_count[result.back().back()]++;

	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rax-16]
	movsxd	rdx, DWORD PTR [rcx-4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1887 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [r12]
; File G:\VSproject\\II\II\Main.cpp

; 81   : 					candidates_count[result.back().back()]++;

	inc	DWORD PTR [rax+rdx*4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1702 :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR [rdi+8]

; 1703 : 
; 1704 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1705 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1706 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1707 : 
; 1708 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1709 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
; 1710 :         _ASAN_VECTOR_MODIFY(-1);
; 1711 :         --_Mylast;

	add	QWORD PTR [rax-16], -4
; File G:\VSproject\\II\II\Main.cpp

; 85   : 				}

	jmp	SHORT $LN542@dfs
$LN25@dfs:

; 86   : 				else if (rev == 3) {

	cmp	eax, 3
	jne	SHORT $LN2@dfs
$LN542@dfs:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1867 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rax-16]
	movsxd	rdx, DWORD PTR [rcx-4]
	mov	rax, QWORD PTR [r12]
	inc	DWORD PTR [rax+rdx*4]
	mov	rax, QWORD PTR [rdi+8]
	add	QWORD PTR [rax-16], -4
$LN2@dfs:
	mov	rdx, QWORD PTR [r15+8]
	mov	r8, QWORD PTR [r15]
	mov	rcx, rdx
	sub	rcx, r8
	sar	rcx, 2
; File G:\VSproject\\II\II\Main.cpp

; 42   : 		for (int i = index; i < candidates.size(); i++) {

	movsxd	rax, ebx
	cmp	rax, rcx
	jb	$LL4@dfs
$LN3@dfs:

; 93   : 			}
; 94   : 		}
; 95   : 		return 3;

	mov	eax, 3
	jmp	$LN1@dfs
$LN516@dfs:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	r15, QWORD PTR [rdi+8]
	lea	r12, QWORD PTR [r15-24]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5754 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

	mov	rbx, QWORD PTR [rdi]

; 5739 :     for (; _First != _Last; ++_First) {

	cmp	rbx, r15
	je	SHORT $LN519@dfs
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1867 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r13, QWORD PTR [r12]
	mov	r14, QWORD PTR [r12+8]
	sub	r14, r13
	sar	r14, 2
$LL109@dfs:
	mov	rcx, QWORD PTR [rbx]
	mov	r8, QWORD PTR [rbx+8]
	sub	r8, rcx
	mov	rax, r8
	sar	rax, 2

; 2220 :     if (_Left.size() != _Right.size()) {

	cmp	rax, r14
	jne	SHORT $LN530@dfs
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5149 :     return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));

	mov	rdx, r13
	call	memcmp

; 5172 :             return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;

	test	eax, eax

; 5740 :         if (*_First == _Val) {

	je	SHORT $LN519@dfs
$LN530@dfs:

; 5173 :         }
; 5174 :     }
; 5175 : 
; 5176 :     for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
; 5177 :         if (!_Pred(*_UFirst1, *_UFirst2)) {
; 5178 :             return false;
; 5179 :         }
; 5180 :     }
; 5181 : 
; 5182 :     return true;
; 5183 : }
; 5184 : 
; 5185 : #if _HAS_CXX17
; 5186 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5187 : _NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5188 :     _Pr _Pred) noexcept; // terminates
; 5189 : #endif // _HAS_CXX17
; 5190 : 
; 5191 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5192 : _NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
; 5193 :     // compare [_First1, _Last1) to [_First2, ...)
; 5194 :     return _STD equal(_First1, _Last1, _First2, equal_to<>{});
; 5195 : }
; 5196 : 
; 5197 : #if _HAS_CXX17
; 5198 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5199 : _NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2) noexcept
; 5200 : /* terminates */ {
; 5201 :     // compare [_First1, _Last1) to [_First2, ...)
; 5202 :     return _STD equal(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to{});
; 5203 : }
; 5204 : #endif // _HAS_CXX17
; 5205 : 
; 5206 : _EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
; 5207 : _NODISCARD _CONSTEXPR20 bool equal(
; 5208 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
; 5209 :     // compare [_First1, _Last1) to [_First2, _Last2)
; 5210 :     _Adl_verify_range(_First1, _Last1);
; 5211 :     _Adl_verify_range(_First2, _Last2);
; 5212 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5213 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5214 :     auto _UFirst2      = _Get_unwrapped(_First2);
; 5215 :     const auto _ULast2 = _Get_unwrapped(_Last2);
; 5216 :     if constexpr (_Is_ranges_random_iter_v<_InIt1> && _Is_ranges_random_iter_v<_InIt2>) {
; 5217 :         if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
; 5218 :             return false;
; 5219 :         }
; 5220 : 
; 5221 :         return _STD equal(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
; 5222 :     } else {
; 5223 :         for (;;) {
; 5224 :             if (_UFirst1 == _ULast1) {
; 5225 :                 return _UFirst2 == _ULast2;
; 5226 :             }
; 5227 : 
; 5228 :             if (_UFirst2 == _ULast2) {
; 5229 :                 return false;
; 5230 :             }
; 5231 : 
; 5232 :             if (!_Pred(*_UFirst1, *_UFirst2)) {
; 5233 :                 return false;
; 5234 :             }
; 5235 : 
; 5236 :             ++_UFirst1;
; 5237 :             ++_UFirst2;
; 5238 :         }
; 5239 :     }
; 5240 : }
; 5241 : 
; 5242 : #if _HAS_CXX17
; 5243 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5244 : _NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5245 :     const _FwdIt2 _Last2, _Pr _Pred) noexcept; // terminates
; 5246 : #endif // _HAS_CXX17
; 5247 : 
; 5248 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5249 : _NODISCARD _CONSTEXPR20 bool equal(
; 5250 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
; 5251 :     // compare [_First1, _Last1) to [_First2, _Last2)
; 5252 :     return _STD equal(_First1, _Last1, _First2, _Last2, equal_to<>{});
; 5253 : }
; 5254 : 
; 5255 : #if _HAS_CXX17
; 5256 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5257 : _NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5258 :     const _FwdIt2 _Last2) noexcept /* terminates */ {
; 5259 :     // compare [_First1, _Last1) to [_First2, _Last2)
; 5260 :     return _STD equal(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
; 5261 : }
; 5262 : #endif // _HAS_CXX17
; 5263 : 
; 5264 : #ifdef __cpp_lib_concepts
; 5265 : namespace ranges {
; 5266 :     template <forward_range _Rng, class _It>
; 5267 :     _NODISCARD constexpr iterator_t<_Rng> _Rewrap_iterator(_Rng&& _Range, _It&& _Val) {
; 5268 :         _STL_INTERNAL_STATIC_ASSERT(is_same_v<remove_cvref_t<_It>, _Unwrapped_iterator_t<_Rng>>);
; 5269 : 
; 5270 :         if constexpr (is_same_v<remove_cvref_t<_It>, iterator_t<_Rng>>) {
; 5271 :             return _STD forward<_It>(_Val);
; 5272 :         } else {
; 5273 :             auto _Result = _RANGES begin(_Range);
; 5274 :             _Result._Seek_to(_STD forward<_It>(_Val));
; 5275 :             return _Result;
; 5276 :         }
; 5277 :     }
; 5278 : 
; 5279 :     _EXPORT_STD template <class _In1, class _In2>
; 5280 :     struct in_in_result {
; 5281 :         /* [[no_unique_address]] */ _In1 in1;
; 5282 :         /* [[no_unique_address]] */ _In2 in2;
; 5283 : 
; 5284 :         template <_Convertible_from<const _In1&> _IIn1, _Convertible_from<const _In2&> _IIn2>
; 5285 :         constexpr operator in_in_result<_IIn1, _IIn2>() const& {
; 5286 :             return {in1, in2};
; 5287 :         }
; 5288 : 
; 5289 :         template <_Convertible_from<_In1> _IIn1, _Convertible_from<_In2> _IIn2>
; 5290 :         constexpr operator in_in_result<_IIn1, _IIn2>() && {
; 5291 :             return {_STD move(in1), _STD move(in2)};
; 5292 :         }
; 5293 :     };
; 5294 : 
; 5295 :     _EXPORT_STD template <class _In1, class _In2>
; 5296 :     using mismatch_result = in_in_result<_In1, _In2>;
; 5297 : 
; 5298 :     // clang-format off
; 5299 :     template <input_iterator _It1, input_iterator _It2, class _Pr, class _Pj1, class _Pj2>
; 5300 :         requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 5301 :     _NODISCARD constexpr mismatch_result<_It1, _It2> _Mismatch_n(
; 5302 :         _It1 _First1, _It2 _First2, iter_difference_t<_It1> _Count, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 5303 :         // clang-format on
; 5304 :         _STL_INTERNAL_CHECK(_Count >= 0);
; 5305 :         for (; _Count != 0; ++_First1, (void) ++_First2, --_Count) {
; 5306 :             if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
; 5307 :                 break;
; 5308 :             }
; 5309 :         }
; 5310 : 
; 5311 :         return {_STD move(_First1), _STD move(_First2)};
; 5312 :     }
; 5313 : 
; 5314 :     template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2, class _Pr,
; 5315 :         class _Pj1, class _Pj2>
; 5316 :         requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 5317 :     _NODISCARD constexpr mismatch_result<_It1, _It2> _Mismatch_4(
; 5318 :         _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 5319 : 
; 5320 :         for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) {
; 5321 :             if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
; 5322 :                 break;
; 5323 :             }
; 5324 :         }
; 5325 : 
; 5326 :         return {_STD move(_First1), _STD move(_First2)};
; 5327 :     }
; 5328 : 
; 5329 :     class _Mismatch_fn : private _Not_quite_object {
; 5330 :     public:
; 5331 :         using _Not_quite_object::_Not_quite_object;
; 5332 : 
; 5333 :         // clang-format off
; 5334 :         template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
; 5335 :             class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
; 5336 :             requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 5337 :         _NODISCARD constexpr mismatch_result<_It1, _It2> operator()(_It1 _First1, _Se1 _Last1,
; 5338 :             _It2 _First2, _Se2 _Last2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 5339 :             // clang-format on
; 5340 :             _Adl_verify_range(_First1, _Last1);
; 5341 :             _Adl_verify_range(_First2, _Last2);
; 5342 : 
; 5343 :             if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
; 5344 :                 iter_difference_t<_It1> _Count1       = _Last1 - _First1;
; 5345 :                 const iter_difference_t<_It2> _Count2 = _Last2 - _First2;
; 5346 :                 if (_Count1 > _Count2) {
; 5347 :                     _Count1 = static_cast<decltype(_Count1)>(_Count2);
; 5348 :                 }
; 5349 : 
; 5350 :                 auto _Result = _RANGES _Mismatch_n(_Get_unwrapped(_STD move(_First1)),
; 5351 :                     _Get_unwrapped(_STD move(_First2)), _Count1, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 5352 :                 _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5353 :                 _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5354 :                 return {_STD move(_First1), _STD move(_First2)};
; 5355 :             } else {
; 5356 :                 auto _Result = _RANGES _Mismatch_4(_Unwrap_iter<_Se1>(_STD move(_First1)),
; 5357 :                     _Unwrap_sent<_It1>(_STD move(_Last1)), _Unwrap_iter<_Se2>(_STD move(_First2)),
; 5358 :                     _Unwrap_sent<_It2>(_STD move(_Last2)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 5359 :                 _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5360 :                 _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5361 :                 return {_STD move(_First1), _STD move(_First2)};
; 5362 :             }
; 5363 :         }
; 5364 : 
; 5365 :         template <input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
; 5366 :             class _Pj2 = identity>
; 5367 :             requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
; 5368 :         _NODISCARD constexpr mismatch_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>> operator()(
; 5369 :             _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 5370 :             if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
; 5371 :                 range_difference_t<_Rng1> _Count1       = _RANGES distance(_Range1);
; 5372 :                 const range_difference_t<_Rng2> _Count2 = _RANGES distance(_Range2);
; 5373 :                 if (_Count1 > _Count2) {
; 5374 :                     _Count1 = static_cast<range_difference_t<_Rng1>>(_Count2);
; 5375 :                 }
; 5376 : 
; 5377 :                 auto _First1 = _RANGES begin(_Range1);
; 5378 :                 auto _First2 = _RANGES begin(_Range2);
; 5379 :                 auto _Result = _RANGES _Mismatch_n(_Get_unwrapped(_STD move(_First1)),
; 5380 :                     _Get_unwrapped(_STD move(_First2)), _Count1, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 5381 :                 _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5382 :                 _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5383 :                 return {_STD move(_First1), _STD move(_First2)};
; 5384 :             } else {
; 5385 :                 auto _First1 = _RANGES begin(_Range1);
; 5386 :                 auto _First2 = _RANGES begin(_Range2);
; 5387 :                 auto _Result = _RANGES _Mismatch_4(_Unwrap_range_iter<_Rng1>(_STD move(_First1)), _Uend(_Range1),
; 5388 :                     _Unwrap_range_iter<_Rng2>(_STD move(_First2)), _Uend(_Range2), _Pass_fn(_Pred), _Pass_fn(_Proj1),
; 5389 :                     _Pass_fn(_Proj2));
; 5390 :                 _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5391 :                 _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5392 :                 return {_STD move(_First1), _STD move(_First2)};
; 5393 :             }
; 5394 :         }
; 5395 :     };
; 5396 : 
; 5397 :     _EXPORT_STD inline constexpr _Mismatch_fn mismatch{_Not_quite_object::_Construct_tag {}};
; 5398 : } // namespace ranges
; 5399 : #endif // __cpp_lib_concepts
; 5400 : 
; 5401 : template <class _Elem1, class _Elem2>
; 5402 : _INLINE_VAR constexpr bool _Lex_compare_memcmp_classify_elements = conjunction_v<_Is_character_or_bool<_Elem1>,
; 5403 :     _Is_character_or_bool<_Elem2>, is_unsigned<_Elem1>, is_unsigned<_Elem2>>;
; 5404 : 
; 5405 : #ifdef __cpp_lib_byte
; 5406 : template <>
; 5407 : inline constexpr bool _Lex_compare_memcmp_classify_elements<byte, byte> = true;
; 5408 : #endif // __cpp_lib_byte
; 5409 : 
; 5410 : template <class _Elem1, class _Elem2, class _Pr>
; 5411 : struct _Lex_compare_memcmp_classify_pred {
; 5412 :     using _Pred = void;
; 5413 : };
; 5414 : 
; 5415 : template <class _Elem1, class _Elem2, class _Elem3>
; 5416 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<_Elem3>> {
; 5417 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
; 5418 :                                     && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
; 5419 :                                     && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
; 5420 :         less<int>, void>;
; 5421 : };
; 5422 : 
; 5423 : template <class _Elem1, class _Elem2>
; 5424 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<>> {
; 5425 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
; 5426 : };
; 5427 : 
; 5428 : template <class _Elem1, class _Elem2, class _Elem3>
; 5429 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<_Elem3>> {
; 5430 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
; 5431 :                                     && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
; 5432 :                                     && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
; 5433 :         greater<int>, void>;
; 5434 : };
; 5435 : 
; 5436 : template <class _Elem1, class _Elem2>
; 5437 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<>> {
; 5438 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
; 5439 : };
; 5440 : 
; 5441 : #ifdef __cpp_lib_concepts
; 5442 : template <class _Elem1, class _Elem2>
; 5443 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, _RANGES less> {
; 5444 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
; 5445 : };
; 5446 : 
; 5447 : template <class _Elem1, class _Elem2>
; 5448 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, _RANGES greater> {
; 5449 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
; 5450 : };
; 5451 : #endif // __cpp_lib_concepts
; 5452 : 
; 5453 : template <class _It1, class _It2, class _Pr>
; 5454 : using _Lex_compare_memcmp_classify =
; 5455 :     conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
; 5456 :         typename _Lex_compare_memcmp_classify_pred<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Pr>::_Pred, void>;
; 5457 : 
; 5458 : _EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
; 5459 : _NODISCARD _CONSTEXPR20 bool lexicographical_compare(
; 5460 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
; 5461 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5462 :     _Adl_verify_range(_First1, _Last1);
; 5463 :     _Adl_verify_range(_First2, _Last2);
; 5464 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5465 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);
; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);
; 5468 : 
; 5469 :     using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
; 5470 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5471 : #if _HAS_CXX20
; 5472 :         if (!_STD is_constant_evaluated())
; 5473 : #endif // _HAS_CXX20
; 5474 :         {
; 5475 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5476 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5477 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5478 :             return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
; 5479 :         }
; 5480 :     }
; 5481 : 
; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it
; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {
; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {
; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;
; 5491 : }
; 5492 : 
; 5493 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5494 : _NODISCARD _CONSTEXPR20 bool lexicographical_compare(
; 5495 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
; 5496 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5497 :     return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>{});
; 5498 : }
; 5499 : 
; 5500 : #if _HAS_CXX17
; 5501 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5502 : _NODISCARD bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5503 :     const _FwdIt2 _Last2, _Pr _Pred) noexcept /* terminates */ {
; 5504 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5505 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 5506 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 5507 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
; 5508 :     return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2, _Pass_fn(_Pred));
; 5509 : }
; 5510 : 
; 5511 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5512 : _NODISCARD bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5513 :     const _FwdIt2 _Last2) noexcept /* terminates */ {
; 5514 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5515 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 5516 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 5517 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
; 5518 :     return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2);
; 5519 : }
; 5520 : #endif // _HAS_CXX17
; 5521 : 
; 5522 : #ifdef __cpp_lib_concepts
; 5523 : template <class _Elem1, class _Elem2, class _Cmp>
; 5524 : struct _Lex_compare_three_way_memcmp_classify_comp {
; 5525 :     using _Comp = void;
; 5526 : };
; 5527 : 
; 5528 : template <class _Elem1, class _Elem2>
; 5529 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, compare_three_way> {
; 5530 :     using _Comp = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>
; 5531 :                                     && three_way_comparable_with<const _Elem1&, const _Elem2&>,
; 5532 :         compare_three_way, void>;
; 5533 : };
; 5534 : 
; 5535 : template <class _Elem1, class _Elem2>
; 5536 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Strong_order::_Cpo> {
; 5537 :     using _Comp =
; 5538 :         conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_strong_order<_Elem1, _Elem2>,
; 5539 :             _Strong_order::_Cpo, void>;
; 5540 : };
; 5541 : 
; 5542 : template <class _Elem1, class _Elem2>
; 5543 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Weak_order::_Cpo> {
; 5544 :     using _Comp =
; 5545 :         conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_weak_order<_Elem1, _Elem2>,
; 5546 :             _Weak_order::_Cpo, void>;
; 5547 : };
; 5548 : 
; 5549 : template <class _Elem1, class _Elem2>
; 5550 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Partial_order::_Cpo> {
; 5551 :     using _Comp =
; 5552 :         conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_partial_order<_Elem1, _Elem2>,
; 5553 :             _Partial_order::_Cpo, void>;
; 5554 : };
; 5555 : 
; 5556 : template <class _It1, class _It2, class _Cmp>
; 5557 : using _Lex_compare_three_way_memcmp_classify =
; 5558 :     conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
; 5559 :         typename _Lex_compare_three_way_memcmp_classify_comp<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Cmp>::_Comp,
; 5560 :         void>;
; 5561 : 
; 5562 : _EXPORT_STD template <class _InIt1, class _InIt2, class _Cmp>
; 5563 : _NODISCARD constexpr auto lexicographical_compare_three_way(const _InIt1 _First1, const _InIt1 _Last1,
; 5564 :     const _InIt2 _First2, const _InIt2 _Last2, _Cmp _Comp) -> decltype(_Comp(*_First1, *_First2)) {
; 5565 :     _Adl_verify_range(_First1, _Last1);
; 5566 :     _Adl_verify_range(_First2, _Last2);
; 5567 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5568 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5569 :     auto _UFirst2      = _Get_unwrapped(_First2);
; 5570 :     const auto _ULast2 = _Get_unwrapped(_Last2);
; 5571 : 
; 5572 :     using _Memcmp_pred = _Lex_compare_three_way_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Cmp>;
; 5573 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5574 :         if (!_STD is_constant_evaluated()) {
; 5575 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5576 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5577 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5578 :             if (_Ans == 0) {
; 5579 :                 return _Num1 <=> _Num2;
; 5580 :             } else {
; 5581 :                 return _Memcmp_pred{}(_Ans, 0);
; 5582 :             }
; 5583 :         }
; 5584 :     }
; 5585 : 
; 5586 :     for (;;) {
; 5587 :         if (_UFirst1 == _ULast1) {
; 5588 :             return _UFirst2 == _ULast2 ? strong_ordering::equal : strong_ordering::less;
; 5589 :         }
; 5590 : 
; 5591 :         if (_UFirst2 == _ULast2) {
; 5592 :             return strong_ordering::greater;
; 5593 :         }
; 5594 : 
; 5595 :         if (const auto _CmpResult = _Comp(*_UFirst1, *_UFirst2); _CmpResult != 0) {
; 5596 :             return _CmpResult;
; 5597 :         }
; 5598 : 
; 5599 :         ++_UFirst1;
; 5600 :         ++_UFirst2;
; 5601 :     }
; 5602 : }
; 5603 : 
; 5604 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5605 : _NODISCARD constexpr auto lexicographical_compare_three_way(
; 5606 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
; 5607 :     return _STD lexicographical_compare_three_way(_First1, _Last1, _First2, _Last2, compare_three_way{});
; 5608 : }
; 5609 : #endif // __cpp_lib_concepts
; 5610 : 
; 5611 : template <class _Ty, class _Elem>
; 5612 : struct _Vector_alg_in_find_is_safe_object_pointers : false_type {};
; 5613 : template <class _Ty1, class _Ty2>
; 5614 : struct _Vector_alg_in_find_is_safe_object_pointers<_Ty1*, _Ty2*>
; 5615 :     : conjunction<
; 5616 :           // _Ty1* is an object pointer type
; 5617 :           disjunction<is_object<_Ty1>, is_void<_Ty1>>,
; 5618 :           // _Ty2* is an object pointer type
; 5619 :           disjunction<is_object<_Ty2>, is_void<_Ty2>>,
; 5620 :           // either _Ty1 is the same as _Ty2 (ignoring cv-qualifiers), or one of the two is void
; 5621 :           disjunction<is_same<remove_cv_t<_Ty1>, remove_cv_t<_Ty2>>, is_void<_Ty1>, is_void<_Ty2>>> {};
; 5622 : 
; 5623 : // Can we activate the vector algorithms for find/count?
; 5624 : template <class _Iter, class _Ty, class _Elem = _Iter_value_t<_Iter>>
; 5625 : _INLINE_VAR constexpr bool _Vector_alg_in_find_is_safe =
; 5626 :     // The iterator must be contiguous so we can get raw pointers.
; 5627 :     _Iterator_is_contiguous<_Iter>
; 5628 :     // The iterator must not be volatile.
; 5629 :     && !_Iterator_is_volatile<_Iter>
; 5630 :     // And one of the following conditions must be met:
; 5631 :     && disjunction_v<
; 5632 : #ifdef __cpp_lib_byte
; 5633 :         // We're finding a std::byte in a range of std::byte.
; 5634 :         conjunction<is_same<_Ty, byte>, is_same<_Elem, byte>>,
; 5635 : #endif // __cpp_lib_byte
; 5636 :        // We're finding an integer in a range of integers.
; 5637 :        // This case is the one that requires careful runtime handling in _Could_compare_equal_to_value_type.
; 5638 :         conjunction<is_integral<_Ty>, is_integral<_Elem>>,
; 5639 :         // We're finding an (object or function) pointer in a range of pointers of the same type.
; 5640 :         conjunction<is_pointer<_Ty>, is_same<_Ty, _Elem>>,
; 5641 :         // We're finding a nullptr in a range of (object or function) pointers.
; 5642 :         conjunction<is_same<_Ty, nullptr_t>, is_pointer<_Elem>>,
; 5643 :         // We're finding an object pointer in a range of object pointers, and:
; 5644 :         // - One of the pointer types is a cv void*.
; 5645 :         // - One of the pointer types is a cv1 U* and the other is a cv2 U*.
; 5646 :         _Vector_alg_in_find_is_safe_object_pointers<_Ty, _Elem>>;
; 5647 : 
; 5648 : template <class _InIt, class _Ty>
; 5649 : _NODISCARD constexpr bool _Could_compare_equal_to_value_type(const _Ty& _Val) {
; 5650 :     // check whether _Val is within the limits of _Elem
; 5651 :     _STL_INTERNAL_STATIC_ASSERT(_Vector_alg_in_find_is_safe<_InIt, _Ty>);
; 5652 : 
; 5653 :     if constexpr (disjunction_v<
; 5654 : #ifdef __cpp_lib_byte
; 5655 :                       is_same<_Ty, byte>,
; 5656 : #endif // __cpp_lib_byte
; 5657 :                       is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
; 5658 :         return true;
; 5659 :     } else {
; 5660 :         using _Elem = _Iter_value_t<_InIt>;
; 5661 :         _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Elem> && is_integral_v<_Ty>);
; 5662 : 
; 5663 :         if constexpr (is_same_v<_Elem, bool>) {
; 5664 :             return _Val == true || _Val == false;
; 5665 :         } else if constexpr (is_signed_v<_Elem>) {
; 5666 :             // use instead of numeric_limits::min/max; avoid <limits> dependency
; 5667 :             constexpr _Elem _Min = static_cast<_Elem>(_Elem{1} << (sizeof(_Elem) * CHAR_BIT - 1));
; 5668 :             constexpr _Elem _Max = static_cast<_Elem>(~_Min);
; 5669 : 
; 5670 :             if constexpr (is_signed_v<_Ty>) {
; 5671 :                 // signed _Elem, signed _Ty
; 5672 :                 return _Min <= _Val && _Val <= _Max;
; 5673 :             } else {
; 5674 :                 // signed _Elem, unsigned _Ty
; 5675 :                 if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
; 5676 :                     // negative values of _Elem can compare equal to values of _Ty
; 5677 :                     return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
; 5678 :                 } else {
; 5679 :                     // negative values of _Elem cannot compare equal to values of _Ty
; 5680 :                     return _Val <= _Max;
; 5681 :                 }
; 5682 :             }
; 5683 :         } else {
; 5684 :             constexpr _Elem _Max = static_cast<_Elem>(~_Elem{0});
; 5685 : 
; 5686 :             if constexpr (is_unsigned_v<_Ty>) {
; 5687 :                 // unsigned _Elem, unsigned _Ty
; 5688 :                 return _Val <= _Max;
; 5689 :             } else {
; 5690 :                 // unsigned _Elem, signed _Ty
; 5691 :                 if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
; 5692 :                     // negative values of _Ty can compare equal to values of _Elem
; 5693 :                     return _Val <= _Max;
; 5694 :                 } else {
; 5695 :                     // negative values of _Ty cannot compare equal to values of _Elem
; 5696 :                     return 0 <= _Val && _Val <= _Max;
; 5697 :                 }
; 5698 :             }
; 5699 :         }
; 5700 :     }
; 5701 : }
; 5702 : 
; 5703 : template <class _InIt, class _Ty>
; 5704 : _NODISCARD _CONSTEXPR20 _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val) {
; 5705 :     // find first matching _Val; choose optimization
; 5706 :     // activate optimization for contiguous iterators to most scalar types (possibly const-qualified)
; 5707 :     if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {
; 5708 : #if _HAS_CXX20
; 5709 :         if (!_STD is_constant_evaluated())
; 5710 : #endif // _HAS_CXX20
; 5711 :         {
; 5712 :             if (!_STD _Could_compare_equal_to_value_type<_InIt>(_Val)) {
; 5713 :                 return _Last;
; 5714 :             }
; 5715 : #if _USE_STD_VECTOR_ALGORITHMS
; 5716 :             const auto _First_ptr = _To_address(_First);
; 5717 :             const auto _Result    = __std_find_trivial(_First_ptr, _To_address(_Last), _Val);
; 5718 :             if constexpr (is_pointer_v<_InIt>) {
; 5719 :                 return _Result;
; 5720 :             } else {
; 5721 :                 return _First + (_Result - _First_ptr);
; 5722 :             }
; 5723 : #else // ^^^ _USE_STD_VECTOR_ALGORITHMS / not _USE_STD_VECTOR_ALGORITHMS vvv
; 5724 :             if constexpr (sizeof(_Iter_value_t<_InIt>) == 1) {
; 5725 :                 const auto _First_ptr = _To_address(_First);
; 5726 :                 const auto _Result    = static_cast<remove_reference_t<_Iter_ref_t<_InIt>>*>(
; 5727 :                     _CSTD memchr(_First_ptr, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
; 5728 :                 if constexpr (is_pointer_v<_InIt>) {
; 5729 :                     return _Result ? _Result : _Last;
; 5730 :                 } else {
; 5731 :                     return _Result ? _First + (_Result - _First_ptr) : _Last;
; 5732 :                 }
; 5733 :             }
; 5734 :             // TRANSITION, DevCom-1614562: not trying wmemchr
; 5735 : #endif // ^^^ not _USE_STD_VECTOR_ALGORITHMS ^^^
; 5736 :         }
; 5737 :     }
; 5738 : 
; 5739 :     for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, r15
	jne	SHORT $LL109@dfs
$LN519@dfs:
; File G:\VSproject\\II\II\Main.cpp

; 51   : 					if (find(result.begin(), result.end(), result.back()) == result.end() - 1) {

	cmp	rbx, r12
	jne	$LN461@dfs
	xorps	xmm0, xmm0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T40[rbp-88], xmm0
	mov	r8, rsi
	mov	QWORD PTR $T40[rbp-72], rsi

; 683  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rdx, QWORD PTR [r12+8]
	sub	rdx, QWORD PTR [r12]
	sar	rdx, 2

; 2063 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN536@dfs

; 2004 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	ja	$LN532@dfs

; 2006 :         }
; 2007 : 
; 2008 :         _Buy_raw(_Newcapacity);

	lea	rcx, QWORD PTR $T40[rbp-88]
	call	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Buy_raw

; 2072 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbx, QWORD PTR [r12+8]
	mov	rdx, QWORD PTR [r12]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	r14, QWORD PTR $T40[rbp-88]
	mov	rcx, r14
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1819 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 2
	lea	rax, QWORD PTR [r14+rbx*4]
	mov	QWORD PTR $T40[rbp-80], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2063 :         if (_Count != 0) {

	mov	r8, QWORD PTR $T40[rbp-72]
	jmp	SHORT $LN242@dfs
$LN536@dfs:
	mov	rax, QWORD PTR $T40[rbp-80]
	mov	r14, QWORD PTR $T40[rbp-88]
$LN242@dfs:

; 779  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rdi+8]
	cmp	rdx, QWORD PTR [rdi+16]
	je	SHORT $LN267@dfs
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rcx, rsi
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdx], r14
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], r8

; 804  :         ++_Mylast;

	add	QWORD PTR [rdi+8], 24

; 780  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN266@dfs
$LN267@dfs:

; 781  :         }
; 782  : 
; 783  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T40[rbp-88]
	mov	rcx, rdi
	call	??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_reallocate<std::vector<int,std::allocator<int> > >
	mov	rsi, QWORD PTR $T40[rbp-72]
	mov	rcx, QWORD PTR $T40[rbp-88]
$LN266@dfs:

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN461@dfs

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rsi, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rsi, -4
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN477@dfs

; 147  :     _Bytes += _Non_user_size;

	add	rsi, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN474@dfs
$LN477@dfs:
; File G:\VSproject\\II\II\Main.cpp

; 78   : 					return 2;

	mov	rdx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN461@dfs:
	mov	eax, 2
	jmp	$LN1@dfs
$LN518@dfs:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	r15, QWORD PTR [rdi+8]
	lea	r12, QWORD PTR [r15-24]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5754 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

	mov	rbx, QWORD PTR [rdi]

; 5739 :     for (; _First != _Last; ++_First) {

	cmp	rbx, r15
	je	SHORT $LN520@dfs
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1867 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r13, QWORD PTR [r12]
	mov	r14, QWORD PTR [r12+8]
	sub	r14, r13
	sar	r14, 2
	npad	2
$LL344@dfs:
	mov	rcx, QWORD PTR [rbx]
	mov	r8, QWORD PTR [rbx+8]
	sub	r8, rcx
	mov	rax, r8
	sar	rax, 2

; 2220 :     if (_Left.size() != _Right.size()) {

	cmp	rax, r14
	jne	SHORT $LN531@dfs
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5149 :     return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));

	mov	rdx, r13
	call	memcmp

; 5172 :             return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;

	test	eax, eax

; 5740 :         if (*_First == _Val) {

	je	SHORT $LN520@dfs
$LN531@dfs:

; 5173 :         }
; 5174 :     }
; 5175 : 
; 5176 :     for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
; 5177 :         if (!_Pred(*_UFirst1, *_UFirst2)) {
; 5178 :             return false;
; 5179 :         }
; 5180 :     }
; 5181 : 
; 5182 :     return true;
; 5183 : }
; 5184 : 
; 5185 : #if _HAS_CXX17
; 5186 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5187 : _NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5188 :     _Pr _Pred) noexcept; // terminates
; 5189 : #endif // _HAS_CXX17
; 5190 : 
; 5191 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5192 : _NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
; 5193 :     // compare [_First1, _Last1) to [_First2, ...)
; 5194 :     return _STD equal(_First1, _Last1, _First2, equal_to<>{});
; 5195 : }
; 5196 : 
; 5197 : #if _HAS_CXX17
; 5198 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5199 : _NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2) noexcept
; 5200 : /* terminates */ {
; 5201 :     // compare [_First1, _Last1) to [_First2, ...)
; 5202 :     return _STD equal(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to{});
; 5203 : }
; 5204 : #endif // _HAS_CXX17
; 5205 : 
; 5206 : _EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
; 5207 : _NODISCARD _CONSTEXPR20 bool equal(
; 5208 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
; 5209 :     // compare [_First1, _Last1) to [_First2, _Last2)
; 5210 :     _Adl_verify_range(_First1, _Last1);
; 5211 :     _Adl_verify_range(_First2, _Last2);
; 5212 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5213 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5214 :     auto _UFirst2      = _Get_unwrapped(_First2);
; 5215 :     const auto _ULast2 = _Get_unwrapped(_Last2);
; 5216 :     if constexpr (_Is_ranges_random_iter_v<_InIt1> && _Is_ranges_random_iter_v<_InIt2>) {
; 5217 :         if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
; 5218 :             return false;
; 5219 :         }
; 5220 : 
; 5221 :         return _STD equal(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
; 5222 :     } else {
; 5223 :         for (;;) {
; 5224 :             if (_UFirst1 == _ULast1) {
; 5225 :                 return _UFirst2 == _ULast2;
; 5226 :             }
; 5227 : 
; 5228 :             if (_UFirst2 == _ULast2) {
; 5229 :                 return false;
; 5230 :             }
; 5231 : 
; 5232 :             if (!_Pred(*_UFirst1, *_UFirst2)) {
; 5233 :                 return false;
; 5234 :             }
; 5235 : 
; 5236 :             ++_UFirst1;
; 5237 :             ++_UFirst2;
; 5238 :         }
; 5239 :     }
; 5240 : }
; 5241 : 
; 5242 : #if _HAS_CXX17
; 5243 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5244 : _NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5245 :     const _FwdIt2 _Last2, _Pr _Pred) noexcept; // terminates
; 5246 : #endif // _HAS_CXX17
; 5247 : 
; 5248 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5249 : _NODISCARD _CONSTEXPR20 bool equal(
; 5250 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
; 5251 :     // compare [_First1, _Last1) to [_First2, _Last2)
; 5252 :     return _STD equal(_First1, _Last1, _First2, _Last2, equal_to<>{});
; 5253 : }
; 5254 : 
; 5255 : #if _HAS_CXX17
; 5256 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5257 : _NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5258 :     const _FwdIt2 _Last2) noexcept /* terminates */ {
; 5259 :     // compare [_First1, _Last1) to [_First2, _Last2)
; 5260 :     return _STD equal(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
; 5261 : }
; 5262 : #endif // _HAS_CXX17
; 5263 : 
; 5264 : #ifdef __cpp_lib_concepts
; 5265 : namespace ranges {
; 5266 :     template <forward_range _Rng, class _It>
; 5267 :     _NODISCARD constexpr iterator_t<_Rng> _Rewrap_iterator(_Rng&& _Range, _It&& _Val) {
; 5268 :         _STL_INTERNAL_STATIC_ASSERT(is_same_v<remove_cvref_t<_It>, _Unwrapped_iterator_t<_Rng>>);
; 5269 : 
; 5270 :         if constexpr (is_same_v<remove_cvref_t<_It>, iterator_t<_Rng>>) {
; 5271 :             return _STD forward<_It>(_Val);
; 5272 :         } else {
; 5273 :             auto _Result = _RANGES begin(_Range);
; 5274 :             _Result._Seek_to(_STD forward<_It>(_Val));
; 5275 :             return _Result;
; 5276 :         }
; 5277 :     }
; 5278 : 
; 5279 :     _EXPORT_STD template <class _In1, class _In2>
; 5280 :     struct in_in_result {
; 5281 :         /* [[no_unique_address]] */ _In1 in1;
; 5282 :         /* [[no_unique_address]] */ _In2 in2;
; 5283 : 
; 5284 :         template <_Convertible_from<const _In1&> _IIn1, _Convertible_from<const _In2&> _IIn2>
; 5285 :         constexpr operator in_in_result<_IIn1, _IIn2>() const& {
; 5286 :             return {in1, in2};
; 5287 :         }
; 5288 : 
; 5289 :         template <_Convertible_from<_In1> _IIn1, _Convertible_from<_In2> _IIn2>
; 5290 :         constexpr operator in_in_result<_IIn1, _IIn2>() && {
; 5291 :             return {_STD move(in1), _STD move(in2)};
; 5292 :         }
; 5293 :     };
; 5294 : 
; 5295 :     _EXPORT_STD template <class _In1, class _In2>
; 5296 :     using mismatch_result = in_in_result<_In1, _In2>;
; 5297 : 
; 5298 :     // clang-format off
; 5299 :     template <input_iterator _It1, input_iterator _It2, class _Pr, class _Pj1, class _Pj2>
; 5300 :         requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 5301 :     _NODISCARD constexpr mismatch_result<_It1, _It2> _Mismatch_n(
; 5302 :         _It1 _First1, _It2 _First2, iter_difference_t<_It1> _Count, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 5303 :         // clang-format on
; 5304 :         _STL_INTERNAL_CHECK(_Count >= 0);
; 5305 :         for (; _Count != 0; ++_First1, (void) ++_First2, --_Count) {
; 5306 :             if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
; 5307 :                 break;
; 5308 :             }
; 5309 :         }
; 5310 : 
; 5311 :         return {_STD move(_First1), _STD move(_First2)};
; 5312 :     }
; 5313 : 
; 5314 :     template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2, class _Pr,
; 5315 :         class _Pj1, class _Pj2>
; 5316 :         requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 5317 :     _NODISCARD constexpr mismatch_result<_It1, _It2> _Mismatch_4(
; 5318 :         _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 5319 : 
; 5320 :         for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) {
; 5321 :             if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
; 5322 :                 break;
; 5323 :             }
; 5324 :         }
; 5325 : 
; 5326 :         return {_STD move(_First1), _STD move(_First2)};
; 5327 :     }
; 5328 : 
; 5329 :     class _Mismatch_fn : private _Not_quite_object {
; 5330 :     public:
; 5331 :         using _Not_quite_object::_Not_quite_object;
; 5332 : 
; 5333 :         // clang-format off
; 5334 :         template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
; 5335 :             class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
; 5336 :             requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 5337 :         _NODISCARD constexpr mismatch_result<_It1, _It2> operator()(_It1 _First1, _Se1 _Last1,
; 5338 :             _It2 _First2, _Se2 _Last2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 5339 :             // clang-format on
; 5340 :             _Adl_verify_range(_First1, _Last1);
; 5341 :             _Adl_verify_range(_First2, _Last2);
; 5342 : 
; 5343 :             if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
; 5344 :                 iter_difference_t<_It1> _Count1       = _Last1 - _First1;
; 5345 :                 const iter_difference_t<_It2> _Count2 = _Last2 - _First2;
; 5346 :                 if (_Count1 > _Count2) {
; 5347 :                     _Count1 = static_cast<decltype(_Count1)>(_Count2);
; 5348 :                 }
; 5349 : 
; 5350 :                 auto _Result = _RANGES _Mismatch_n(_Get_unwrapped(_STD move(_First1)),
; 5351 :                     _Get_unwrapped(_STD move(_First2)), _Count1, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 5352 :                 _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5353 :                 _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5354 :                 return {_STD move(_First1), _STD move(_First2)};
; 5355 :             } else {
; 5356 :                 auto _Result = _RANGES _Mismatch_4(_Unwrap_iter<_Se1>(_STD move(_First1)),
; 5357 :                     _Unwrap_sent<_It1>(_STD move(_Last1)), _Unwrap_iter<_Se2>(_STD move(_First2)),
; 5358 :                     _Unwrap_sent<_It2>(_STD move(_Last2)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 5359 :                 _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5360 :                 _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5361 :                 return {_STD move(_First1), _STD move(_First2)};
; 5362 :             }
; 5363 :         }
; 5364 : 
; 5365 :         template <input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
; 5366 :             class _Pj2 = identity>
; 5367 :             requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
; 5368 :         _NODISCARD constexpr mismatch_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>> operator()(
; 5369 :             _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 5370 :             if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
; 5371 :                 range_difference_t<_Rng1> _Count1       = _RANGES distance(_Range1);
; 5372 :                 const range_difference_t<_Rng2> _Count2 = _RANGES distance(_Range2);
; 5373 :                 if (_Count1 > _Count2) {
; 5374 :                     _Count1 = static_cast<range_difference_t<_Rng1>>(_Count2);
; 5375 :                 }
; 5376 : 
; 5377 :                 auto _First1 = _RANGES begin(_Range1);
; 5378 :                 auto _First2 = _RANGES begin(_Range2);
; 5379 :                 auto _Result = _RANGES _Mismatch_n(_Get_unwrapped(_STD move(_First1)),
; 5380 :                     _Get_unwrapped(_STD move(_First2)), _Count1, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 5381 :                 _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5382 :                 _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5383 :                 return {_STD move(_First1), _STD move(_First2)};
; 5384 :             } else {
; 5385 :                 auto _First1 = _RANGES begin(_Range1);
; 5386 :                 auto _First2 = _RANGES begin(_Range2);
; 5387 :                 auto _Result = _RANGES _Mismatch_4(_Unwrap_range_iter<_Rng1>(_STD move(_First1)), _Uend(_Range1),
; 5388 :                     _Unwrap_range_iter<_Rng2>(_STD move(_First2)), _Uend(_Range2), _Pass_fn(_Pred), _Pass_fn(_Proj1),
; 5389 :                     _Pass_fn(_Proj2));
; 5390 :                 _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5391 :                 _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5392 :                 return {_STD move(_First1), _STD move(_First2)};
; 5393 :             }
; 5394 :         }
; 5395 :     };
; 5396 : 
; 5397 :     _EXPORT_STD inline constexpr _Mismatch_fn mismatch{_Not_quite_object::_Construct_tag {}};
; 5398 : } // namespace ranges
; 5399 : #endif // __cpp_lib_concepts
; 5400 : 
; 5401 : template <class _Elem1, class _Elem2>
; 5402 : _INLINE_VAR constexpr bool _Lex_compare_memcmp_classify_elements = conjunction_v<_Is_character_or_bool<_Elem1>,
; 5403 :     _Is_character_or_bool<_Elem2>, is_unsigned<_Elem1>, is_unsigned<_Elem2>>;
; 5404 : 
; 5405 : #ifdef __cpp_lib_byte
; 5406 : template <>
; 5407 : inline constexpr bool _Lex_compare_memcmp_classify_elements<byte, byte> = true;
; 5408 : #endif // __cpp_lib_byte
; 5409 : 
; 5410 : template <class _Elem1, class _Elem2, class _Pr>
; 5411 : struct _Lex_compare_memcmp_classify_pred {
; 5412 :     using _Pred = void;
; 5413 : };
; 5414 : 
; 5415 : template <class _Elem1, class _Elem2, class _Elem3>
; 5416 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<_Elem3>> {
; 5417 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
; 5418 :                                     && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
; 5419 :                                     && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
; 5420 :         less<int>, void>;
; 5421 : };
; 5422 : 
; 5423 : template <class _Elem1, class _Elem2>
; 5424 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<>> {
; 5425 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
; 5426 : };
; 5427 : 
; 5428 : template <class _Elem1, class _Elem2, class _Elem3>
; 5429 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<_Elem3>> {
; 5430 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
; 5431 :                                     && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
; 5432 :                                     && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
; 5433 :         greater<int>, void>;
; 5434 : };
; 5435 : 
; 5436 : template <class _Elem1, class _Elem2>
; 5437 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<>> {
; 5438 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
; 5439 : };
; 5440 : 
; 5441 : #ifdef __cpp_lib_concepts
; 5442 : template <class _Elem1, class _Elem2>
; 5443 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, _RANGES less> {
; 5444 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
; 5445 : };
; 5446 : 
; 5447 : template <class _Elem1, class _Elem2>
; 5448 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, _RANGES greater> {
; 5449 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
; 5450 : };
; 5451 : #endif // __cpp_lib_concepts
; 5452 : 
; 5453 : template <class _It1, class _It2, class _Pr>
; 5454 : using _Lex_compare_memcmp_classify =
; 5455 :     conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
; 5456 :         typename _Lex_compare_memcmp_classify_pred<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Pr>::_Pred, void>;
; 5457 : 
; 5458 : _EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
; 5459 : _NODISCARD _CONSTEXPR20 bool lexicographical_compare(
; 5460 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
; 5461 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5462 :     _Adl_verify_range(_First1, _Last1);
; 5463 :     _Adl_verify_range(_First2, _Last2);
; 5464 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5465 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);
; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);
; 5468 : 
; 5469 :     using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
; 5470 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5471 : #if _HAS_CXX20
; 5472 :         if (!_STD is_constant_evaluated())
; 5473 : #endif // _HAS_CXX20
; 5474 :         {
; 5475 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5476 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5477 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5478 :             return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
; 5479 :         }
; 5480 :     }
; 5481 : 
; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it
; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {
; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {
; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;
; 5491 : }
; 5492 : 
; 5493 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5494 : _NODISCARD _CONSTEXPR20 bool lexicographical_compare(
; 5495 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
; 5496 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5497 :     return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>{});
; 5498 : }
; 5499 : 
; 5500 : #if _HAS_CXX17
; 5501 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5502 : _NODISCARD bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5503 :     const _FwdIt2 _Last2, _Pr _Pred) noexcept /* terminates */ {
; 5504 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5505 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 5506 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 5507 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
; 5508 :     return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2, _Pass_fn(_Pred));
; 5509 : }
; 5510 : 
; 5511 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5512 : _NODISCARD bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5513 :     const _FwdIt2 _Last2) noexcept /* terminates */ {
; 5514 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5515 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 5516 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 5517 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
; 5518 :     return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2);
; 5519 : }
; 5520 : #endif // _HAS_CXX17
; 5521 : 
; 5522 : #ifdef __cpp_lib_concepts
; 5523 : template <class _Elem1, class _Elem2, class _Cmp>
; 5524 : struct _Lex_compare_three_way_memcmp_classify_comp {
; 5525 :     using _Comp = void;
; 5526 : };
; 5527 : 
; 5528 : template <class _Elem1, class _Elem2>
; 5529 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, compare_three_way> {
; 5530 :     using _Comp = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>
; 5531 :                                     && three_way_comparable_with<const _Elem1&, const _Elem2&>,
; 5532 :         compare_three_way, void>;
; 5533 : };
; 5534 : 
; 5535 : template <class _Elem1, class _Elem2>
; 5536 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Strong_order::_Cpo> {
; 5537 :     using _Comp =
; 5538 :         conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_strong_order<_Elem1, _Elem2>,
; 5539 :             _Strong_order::_Cpo, void>;
; 5540 : };
; 5541 : 
; 5542 : template <class _Elem1, class _Elem2>
; 5543 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Weak_order::_Cpo> {
; 5544 :     using _Comp =
; 5545 :         conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_weak_order<_Elem1, _Elem2>,
; 5546 :             _Weak_order::_Cpo, void>;
; 5547 : };
; 5548 : 
; 5549 : template <class _Elem1, class _Elem2>
; 5550 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Partial_order::_Cpo> {
; 5551 :     using _Comp =
; 5552 :         conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_partial_order<_Elem1, _Elem2>,
; 5553 :             _Partial_order::_Cpo, void>;
; 5554 : };
; 5555 : 
; 5556 : template <class _It1, class _It2, class _Cmp>
; 5557 : using _Lex_compare_three_way_memcmp_classify =
; 5558 :     conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
; 5559 :         typename _Lex_compare_three_way_memcmp_classify_comp<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Cmp>::_Comp,
; 5560 :         void>;
; 5561 : 
; 5562 : _EXPORT_STD template <class _InIt1, class _InIt2, class _Cmp>
; 5563 : _NODISCARD constexpr auto lexicographical_compare_three_way(const _InIt1 _First1, const _InIt1 _Last1,
; 5564 :     const _InIt2 _First2, const _InIt2 _Last2, _Cmp _Comp) -> decltype(_Comp(*_First1, *_First2)) {
; 5565 :     _Adl_verify_range(_First1, _Last1);
; 5566 :     _Adl_verify_range(_First2, _Last2);
; 5567 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5568 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5569 :     auto _UFirst2      = _Get_unwrapped(_First2);
; 5570 :     const auto _ULast2 = _Get_unwrapped(_Last2);
; 5571 : 
; 5572 :     using _Memcmp_pred = _Lex_compare_three_way_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Cmp>;
; 5573 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5574 :         if (!_STD is_constant_evaluated()) {
; 5575 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5576 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5577 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5578 :             if (_Ans == 0) {
; 5579 :                 return _Num1 <=> _Num2;
; 5580 :             } else {
; 5581 :                 return _Memcmp_pred{}(_Ans, 0);
; 5582 :             }
; 5583 :         }
; 5584 :     }
; 5585 : 
; 5586 :     for (;;) {
; 5587 :         if (_UFirst1 == _ULast1) {
; 5588 :             return _UFirst2 == _ULast2 ? strong_ordering::equal : strong_ordering::less;
; 5589 :         }
; 5590 : 
; 5591 :         if (_UFirst2 == _ULast2) {
; 5592 :             return strong_ordering::greater;
; 5593 :         }
; 5594 : 
; 5595 :         if (const auto _CmpResult = _Comp(*_UFirst1, *_UFirst2); _CmpResult != 0) {
; 5596 :             return _CmpResult;
; 5597 :         }
; 5598 : 
; 5599 :         ++_UFirst1;
; 5600 :         ++_UFirst2;
; 5601 :     }
; 5602 : }
; 5603 : 
; 5604 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5605 : _NODISCARD constexpr auto lexicographical_compare_three_way(
; 5606 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
; 5607 :     return _STD lexicographical_compare_three_way(_First1, _Last1, _First2, _Last2, compare_three_way{});
; 5608 : }
; 5609 : #endif // __cpp_lib_concepts
; 5610 : 
; 5611 : template <class _Ty, class _Elem>
; 5612 : struct _Vector_alg_in_find_is_safe_object_pointers : false_type {};
; 5613 : template <class _Ty1, class _Ty2>
; 5614 : struct _Vector_alg_in_find_is_safe_object_pointers<_Ty1*, _Ty2*>
; 5615 :     : conjunction<
; 5616 :           // _Ty1* is an object pointer type
; 5617 :           disjunction<is_object<_Ty1>, is_void<_Ty1>>,
; 5618 :           // _Ty2* is an object pointer type
; 5619 :           disjunction<is_object<_Ty2>, is_void<_Ty2>>,
; 5620 :           // either _Ty1 is the same as _Ty2 (ignoring cv-qualifiers), or one of the two is void
; 5621 :           disjunction<is_same<remove_cv_t<_Ty1>, remove_cv_t<_Ty2>>, is_void<_Ty1>, is_void<_Ty2>>> {};
; 5622 : 
; 5623 : // Can we activate the vector algorithms for find/count?
; 5624 : template <class _Iter, class _Ty, class _Elem = _Iter_value_t<_Iter>>
; 5625 : _INLINE_VAR constexpr bool _Vector_alg_in_find_is_safe =
; 5626 :     // The iterator must be contiguous so we can get raw pointers.
; 5627 :     _Iterator_is_contiguous<_Iter>
; 5628 :     // The iterator must not be volatile.
; 5629 :     && !_Iterator_is_volatile<_Iter>
; 5630 :     // And one of the following conditions must be met:
; 5631 :     && disjunction_v<
; 5632 : #ifdef __cpp_lib_byte
; 5633 :         // We're finding a std::byte in a range of std::byte.
; 5634 :         conjunction<is_same<_Ty, byte>, is_same<_Elem, byte>>,
; 5635 : #endif // __cpp_lib_byte
; 5636 :        // We're finding an integer in a range of integers.
; 5637 :        // This case is the one that requires careful runtime handling in _Could_compare_equal_to_value_type.
; 5638 :         conjunction<is_integral<_Ty>, is_integral<_Elem>>,
; 5639 :         // We're finding an (object or function) pointer in a range of pointers of the same type.
; 5640 :         conjunction<is_pointer<_Ty>, is_same<_Ty, _Elem>>,
; 5641 :         // We're finding a nullptr in a range of (object or function) pointers.
; 5642 :         conjunction<is_same<_Ty, nullptr_t>, is_pointer<_Elem>>,
; 5643 :         // We're finding an object pointer in a range of object pointers, and:
; 5644 :         // - One of the pointer types is a cv void*.
; 5645 :         // - One of the pointer types is a cv1 U* and the other is a cv2 U*.
; 5646 :         _Vector_alg_in_find_is_safe_object_pointers<_Ty, _Elem>>;
; 5647 : 
; 5648 : template <class _InIt, class _Ty>
; 5649 : _NODISCARD constexpr bool _Could_compare_equal_to_value_type(const _Ty& _Val) {
; 5650 :     // check whether _Val is within the limits of _Elem
; 5651 :     _STL_INTERNAL_STATIC_ASSERT(_Vector_alg_in_find_is_safe<_InIt, _Ty>);
; 5652 : 
; 5653 :     if constexpr (disjunction_v<
; 5654 : #ifdef __cpp_lib_byte
; 5655 :                       is_same<_Ty, byte>,
; 5656 : #endif // __cpp_lib_byte
; 5657 :                       is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
; 5658 :         return true;
; 5659 :     } else {
; 5660 :         using _Elem = _Iter_value_t<_InIt>;
; 5661 :         _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Elem> && is_integral_v<_Ty>);
; 5662 : 
; 5663 :         if constexpr (is_same_v<_Elem, bool>) {
; 5664 :             return _Val == true || _Val == false;
; 5665 :         } else if constexpr (is_signed_v<_Elem>) {
; 5666 :             // use instead of numeric_limits::min/max; avoid <limits> dependency
; 5667 :             constexpr _Elem _Min = static_cast<_Elem>(_Elem{1} << (sizeof(_Elem) * CHAR_BIT - 1));
; 5668 :             constexpr _Elem _Max = static_cast<_Elem>(~_Min);
; 5669 : 
; 5670 :             if constexpr (is_signed_v<_Ty>) {
; 5671 :                 // signed _Elem, signed _Ty
; 5672 :                 return _Min <= _Val && _Val <= _Max;
; 5673 :             } else {
; 5674 :                 // signed _Elem, unsigned _Ty
; 5675 :                 if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
; 5676 :                     // negative values of _Elem can compare equal to values of _Ty
; 5677 :                     return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
; 5678 :                 } else {
; 5679 :                     // negative values of _Elem cannot compare equal to values of _Ty
; 5680 :                     return _Val <= _Max;
; 5681 :                 }
; 5682 :             }
; 5683 :         } else {
; 5684 :             constexpr _Elem _Max = static_cast<_Elem>(~_Elem{0});
; 5685 : 
; 5686 :             if constexpr (is_unsigned_v<_Ty>) {
; 5687 :                 // unsigned _Elem, unsigned _Ty
; 5688 :                 return _Val <= _Max;
; 5689 :             } else {
; 5690 :                 // unsigned _Elem, signed _Ty
; 5691 :                 if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
; 5692 :                     // negative values of _Ty can compare equal to values of _Elem
; 5693 :                     return _Val <= _Max;
; 5694 :                 } else {
; 5695 :                     // negative values of _Ty cannot compare equal to values of _Elem
; 5696 :                     return 0 <= _Val && _Val <= _Max;
; 5697 :                 }
; 5698 :             }
; 5699 :         }
; 5700 :     }
; 5701 : }
; 5702 : 
; 5703 : template <class _InIt, class _Ty>
; 5704 : _NODISCARD _CONSTEXPR20 _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val) {
; 5705 :     // find first matching _Val; choose optimization
; 5706 :     // activate optimization for contiguous iterators to most scalar types (possibly const-qualified)
; 5707 :     if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {
; 5708 : #if _HAS_CXX20
; 5709 :         if (!_STD is_constant_evaluated())
; 5710 : #endif // _HAS_CXX20
; 5711 :         {
; 5712 :             if (!_STD _Could_compare_equal_to_value_type<_InIt>(_Val)) {
; 5713 :                 return _Last;
; 5714 :             }
; 5715 : #if _USE_STD_VECTOR_ALGORITHMS
; 5716 :             const auto _First_ptr = _To_address(_First);
; 5717 :             const auto _Result    = __std_find_trivial(_First_ptr, _To_address(_Last), _Val);
; 5718 :             if constexpr (is_pointer_v<_InIt>) {
; 5719 :                 return _Result;
; 5720 :             } else {
; 5721 :                 return _First + (_Result - _First_ptr);
; 5722 :             }
; 5723 : #else // ^^^ _USE_STD_VECTOR_ALGORITHMS / not _USE_STD_VECTOR_ALGORITHMS vvv
; 5724 :             if constexpr (sizeof(_Iter_value_t<_InIt>) == 1) {
; 5725 :                 const auto _First_ptr = _To_address(_First);
; 5726 :                 const auto _Result    = static_cast<remove_reference_t<_Iter_ref_t<_InIt>>*>(
; 5727 :                     _CSTD memchr(_First_ptr, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
; 5728 :                 if constexpr (is_pointer_v<_InIt>) {
; 5729 :                     return _Result ? _Result : _Last;
; 5730 :                 } else {
; 5731 :                     return _Result ? _First + (_Result - _First_ptr) : _Last;
; 5732 :                 }
; 5733 :             }
; 5734 :             // TRANSITION, DevCom-1614562: not trying wmemchr
; 5735 : #endif // ^^^ not _USE_STD_VECTOR_ALGORITHMS ^^^
; 5736 :         }
; 5737 :     }
; 5738 : 
; 5739 :     for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, r15
	jne	SHORT $LL344@dfs
$LN520@dfs:
; File G:\VSproject\\II\II\Main.cpp

; 75   : 					if (find(result.begin(), result.end(), result.back()) == result.end() - 1) {

	cmp	rbx, r12
	jne	SHORT $LN461@dfs
	xorps	xmm0, xmm0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T89[rbp-88], xmm0
	mov	r8, rsi
	mov	QWORD PTR $T89[rbp-72], rsi

; 683  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rdx, QWORD PTR [r12+8]
	sub	rdx, QWORD PTR [r12]
	sar	rdx, 2

; 2063 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN537@dfs

; 2004 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	ja	$LN532@dfs

; 2006 :         }
; 2007 : 
; 2008 :         _Buy_raw(_Newcapacity);

	lea	rcx, QWORD PTR $T89[rbp-88]
	call	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Buy_raw

; 2072 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbx, QWORD PTR [r12+8]
	mov	rdx, QWORD PTR [r12]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	r14, QWORD PTR $T89[rbp-88]
	mov	rcx, r14
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1819 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 2
	lea	rax, QWORD PTR [r14+rbx*4]
	mov	QWORD PTR $T89[rbp-80], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2063 :         if (_Count != 0) {

	mov	r8, QWORD PTR $T89[rbp-72]
	jmp	SHORT $LN415@dfs
$LN537@dfs:
	mov	rax, QWORD PTR $T89[rbp-80]
	mov	r14, QWORD PTR $T89[rbp-88]
$LN415@dfs:

; 779  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rdi+8]
	cmp	rdx, QWORD PTR [rdi+16]
	je	SHORT $LN440@dfs
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rcx, rsi
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdx], r14
	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], r8

; 804  :         ++_Mylast;

	add	QWORD PTR [rdi+8], 24

; 780  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN439@dfs
$LN440@dfs:

; 781  :         }
; 782  : 
; 783  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR $T89[rbp-88]
	mov	rcx, rdi
	call	??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_reallocate<std::vector<int,std::allocator<int> > >
	mov	rsi, QWORD PTR $T89[rbp-72]
	mov	rcx, QWORD PTR $T89[rbp-88]
$LN439@dfs:

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	$LN461@dfs

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	rsi, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rsi, -4
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	$LN477@dfs

; 147  :     _Bytes += _Non_user_size;

	add	rsi, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	$LN477@dfs
$LN474@dfs:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@dfs:
; File G:\VSproject\\II\II\Main.cpp

; 92   : 				return 0;

	xor	eax, eax
$LN1@dfs:

; 96   : 	}

	add	rsp, 88					; 00000058H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
$LN532@dfs:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2005 :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
	int	3
$LN540@dfs:
?dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z ENDP ; Solution::dfs
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T89 = 48
$T40 = 48
$T1 = 48
original_target$GSCopy$1$ = 72
this$ = 160
result$ = 168
candidates$ = 176
index$ = 184
target$ = 192
original_target$ = 200
?dtor$0@?0??dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z@4HA PROC ; `Solution::dfs'::`1'::dtor$0
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
?dtor$0@?0??dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z@4HA ENDP ; `Solution::dfs'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T89 = 48
$T40 = 48
$T1 = 48
original_target$GSCopy$1$ = 72
this$ = 160
result$ = 168
candidates$ = 176
index$ = 184
target$ = 192
original_target$ = 200
?dtor$1@?0??dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z@4HA PROC ; `Solution::dfs'::`1'::dtor$1
	lea	rcx, QWORD PTR $T40[rdx]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
?dtor$1@?0??dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z@4HA ENDP ; `Solution::dfs'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T89 = 48
$T40 = 48
$T1 = 48
original_target$GSCopy$1$ = 72
this$ = 160
result$ = 168
candidates$ = 176
index$ = 184
target$ = 192
original_target$ = 200
?dtor$2@?0??dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z@4HA PROC ; `Solution::dfs'::`1'::dtor$2
	lea	rcx, QWORD PTR $T89[rdx]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
?dtor$2@?0??dfs@Solution@@QEAAHAEAV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@HHAEAH@Z@4HA ENDP ; `Solution::dfs'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@XZ PROC ; std::set<int,std::less<int>,std::allocator<int> >::~set<int,std::less<int>,std::allocator<int> >, COMDAT
$LN67:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	rbx, QWORD PTR [rcx]
	mov	rdi, rcx
	mov	rbx, QWORD PTR [rbx+8]

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN9@set
	npad	6
$LL8@set:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	r8, QWORD PTR [rbx+16]
	mov	rdx, rdi
	mov	rcx, rdi
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, rbx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rbx, QWORD PTR [rbx]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL8@set
$LN9@set:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rdi]
	mov	edx, 32					; 00000020H
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	jmp	??3@YAXPEAX_K@Z				; operator delete
??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@XZ ENDP ; std::set<int,std::less<int>,std::allocator<int> >::~set<int,std::less<int>,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAAX_K@Z PROC ; std::set<int,std::less<int>,std::allocator<int> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	ret	0
?__autoclassinit2@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAAX_K@Z ENDP ; std::set<int,std::less<int>,std::allocator<int> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAX_K@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??1?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::~set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
$LN32:
	push	rbx
	sub	rsp, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	r8, QWORD PTR [rcx]
	mov	rdx, rcx
	mov	rbx, rcx
	mov	r8, QWORD PTR [r8+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Erase_tree<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rbx]
	mov	edx, 56					; 00000038H
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??3@YAXPEAX_K@Z				; operator delete
??1?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::~set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAX_K@Z PROC ; std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	ret	0
?__autoclassinit2@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\VSproject\\II\II\Main.cpp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\VSproject\\II\II\Main.cpp
;	COMDAT main
_TEXT	SEGMENT
$T22 = 32
$T14 = 32
$T10 = 32
$T1 = 32
candidates$ = 80
result$ = 104
i$27 = 128
__$ArrayPad$ = 152
main	PROC						; COMDAT

; 100  : {

$LN453:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 160				; 000000a0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-105], rax
	xorps	xmm1, xmm1
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR candidates$[rbp-105], xmm1
	xor	r13d, r13d
	mov	QWORD PTR candidates$[rbp-89], r13
; File G:\VSproject\\II\II\Main.cpp

; 102  : 	candidates = { 4, 4, 2, 1, 4, 2, 2, 1, 3 };

	movdqa	xmm0, XMMWORD PTR __xmm@00000001000000020000000400000004
	movdqu	XMMWORD PTR $T1[rbp-105], xmm0
	movdqa	xmm1, XMMWORD PTR __xmm@00000001000000020000000200000004
	movdqu	XMMWORD PTR $T1[rbp-89], xmm1
	mov	DWORD PTR $T1[rbp-73], 3
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1393 :             _Clear_and_reserve_geometric(_Newsize);

	lea	edx, QWORD PTR [r13+9]
	lea	rcx, QWORD PTR candidates$[rbp-105]
	call	?_Clear_and_reserve_geometric@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Clear_and_reserve_geometric

; 1394 :             if constexpr (_Nothrow_construct) {
; 1395 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rbx, QWORD PTR candidates$[rbp-105]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	lea	r8d, QWORD PTR [r13+36]
	lea	rdx, QWORD PTR $T1[rbp-105]
	mov	rcx, rbx
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1856 :             _Dest += _Count;

	lea	rax, QWORD PTR [rbx+36]
	mov	QWORD PTR candidates$[rbp-97], rax
	xorps	xmm0, xmm0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T10[rbp-105], xmm0
	mov	QWORD PTR $T10[rbp-89], r13

; 2008 :         _Buy_raw(_Newcapacity);

	lea	edx, QWORD PTR [r13+50]
	lea	rcx, QWORD PTR $T10[rbp-105]
	call	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Buy_raw

; 2070 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);

	mov	rdi, QWORD PTR $T10[rbp-105]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1766 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	movdqa	xmm0, XMMWORD PTR __xmm@00000001000000010000000100000001
	movups	XMMWORD PTR [rdi], xmm0
	movups	XMMWORD PTR [rdi+16], xmm0
	movups	XMMWORD PTR [rdi+32], xmm0
	movups	XMMWORD PTR [rdi+48], xmm0
	movups	XMMWORD PTR [rdi+64], xmm0
	movups	XMMWORD PTR [rdi+80], xmm0
	movups	XMMWORD PTR [rdi+96], xmm0
	lea	rcx, QWORD PTR [rdi+128]
	movups	XMMWORD PTR [rcx-16], xmm0
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movq	QWORD PTR [rcx+64], xmm0

; 1957 :     return _Backout._Release();

	mov	esi, 200				; 000000c8H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2070 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);

	add	rsi, rdi
	mov	QWORD PTR $T10[rbp-97], rsi

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR candidates$[rbp-105]
	test	rcx, rcx
	je	SHORT $LN276@main

; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR candidates$[rbp-89]
	sub	rax, rcx
	sar	rax, 2
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN292@main

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN292@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN292@main:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rsi, QWORD PTR $T10[rbp-97]
$LN276@main:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 412  :         _Myfirst = _Right._Myfirst;

	mov	rcx, QWORD PTR $T10[rbp-105]
	mov	QWORD PTR candidates$[rbp-105], rcx

; 413  :         _Mylast  = _Right._Mylast;

	mov	QWORD PTR candidates$[rbp-97], rsi

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR $T10[rbp-89]
	mov	QWORD PTR candidates$[rbp-89], rax
; File G:\VSproject\\II\II\Main.cpp

; 104  : 	candidates = { 5, 4, 5, 1, 5, 3, 1, 4, 5, 5, 4 };

	movdqa	xmm0, XMMWORD PTR __xmm@00000001000000050000000400000005
	movdqu	XMMWORD PTR $T14[rbp-105], xmm0
	movdqa	xmm1, XMMWORD PTR __xmm@00000004000000010000000300000005
	movdqu	XMMWORD PTR $T14[rbp-89], xmm1
	mov	DWORD PTR $T14[rbp-73], 5
	mov	DWORD PTR $T14[rbp-69], 5
	mov	DWORD PTR $T14[rbp-65], 4
	sub	rax, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1391 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	sar	rax, 2

; 1392 :         if (_Newsize > _Oldcapacity) {

	cmp	rax, 11
	jae	SHORT $LN333@main

; 1393 :             _Clear_and_reserve_geometric(_Newsize);

	mov	edx, 11
	lea	rcx, QWORD PTR candidates$[rbp-105]
	call	?_Clear_and_reserve_geometric@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Clear_and_reserve_geometric

; 1394 :             if constexpr (_Nothrow_construct) {
; 1395 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rbx, QWORD PTR candidates$[rbp-105]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 44					; 0000002cH
	lea	rdx, QWORD PTR $T14[rbp-105]
	mov	rcx, rbx
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1856 :             _Dest += _Count;

	lea	rax, QWORD PTR [rbx+44]
	mov	QWORD PTR candidates$[rbp-97], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1401 :             return;

	jmp	SHORT $LN335@main
$LN333@main:

; 1402 :         }
; 1403 : 
; 1404 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	sub	rsi, rcx
	sar	rsi, 2

; 1405 :         if (_Newsize > _Oldsize) {

	lea	rdx, QWORD PTR $T14[rbp-105]
	cmp	rsi, 11
	jae	SHORT $LN334@main
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rsi*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rdx, QWORD PTR $T14[rbp-105]
	add	rdx, rbx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1426 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	mov	rdi, QWORD PTR candidates$[rbp-97]
	mov	ebx, 11
	sub	rbx, rsi
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rbx*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1856 :             _Dest += _Count;

	lea	rax, QWORD PTR [rbx+rdi]
	mov	QWORD PTR candidates$[rbp-97], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1432 :         } else {

	jmp	SHORT $LN335@main
$LN334@main:

; 1433 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbx, QWORD PTR [rcx+44]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8d, 44					; 0000002cH
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1437 :             _Mylast = _Newlast;

	mov	QWORD PTR candidates$[rbp-97], rbx
$LN335@main:
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR result$[rbp-105], xmm0
	mov	QWORD PTR result$[rbp-89], rax

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	movdqu	XMMWORD PTR $T22[rbp-105], xmm0
	mov	QWORD PTR $T22[rbp-89], r13
; File G:\VSproject\\II\II\Main.cpp

; 105  : 	vector<vector<int>> result = Solution().combinationSum2(candidates, 10);

	lea	r8, QWORD PTR candidates$[rbp-105]
	lea	rdx, QWORD PTR result$[rbp-105]
	lea	rcx, QWORD PTR $T22[rbp-105]
	call	?combinationSum2@Solution@@QEAA?AV?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAV?$vector@HV?$allocator@H@std@@@3@H@Z ; Solution::combinationSum2
	npad	1
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR $T22[rbp-105]
	test	rcx, rcx
	je	SHORT $LN402@main

; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR $T22[rbp-89]
	sub	rax, rcx
	sar	rax, 2
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rax*4]
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN418@main

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN418@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN418@main:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR $T22[rbp-105], xmm0

; 2048 :             _Mylast  = nullptr;
; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR $T22[rbp-89], r13
$LN402@main:
; File G:\VSproject\\II\II\Main.cpp

; 106  : 	for (auto i : result) {

	mov	rsi, QWORD PTR result$[rbp-105]
	mov	r12, QWORD PTR result$[rbp-97]
	cmp	rsi, r12
	je	$LN446@main
$LN450@main:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	xorps	xmm1, xmm1
	movdqu	XMMWORD PTR i$27[rbp-105], xmm1
	mov	r15, r13
	mov	QWORD PTR i$27[rbp-89], r13

; 683  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rdx, QWORD PTR [rsi+8]
	sub	rdx, QWORD PTR [rsi]
	sar	rdx, 2
	mov	rbx, r13

; 2063 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN447@main

; 2004 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rcx
	ja	$LN429@main

; 2006 :         }
; 2007 : 
; 2008 :         _Buy_raw(_Newcapacity);

	lea	rcx, QWORD PTR i$27[rbp-105]
	call	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Buy_raw

; 2072 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rbx, QWORD PTR [rsi+8]
	mov	rdx, QWORD PTR [rsi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rdi, QWORD PTR i$27[rbp-105]
	mov	rcx, rdi
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1819 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 2
	lea	r14, QWORD PTR [rdi+rbx*4]
	mov	QWORD PTR i$27[rbp-97], r14
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2077 :             _Guard._Target = nullptr;

	mov	rbx, rdi
	mov	r15, QWORD PTR i$27[rbp-89]

; 2050 :         }
; 2051 :     }
; 2052 : 
; 2053 :     template <class... _Valty>
; 2054 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {
; 2055 :         // Dispatches between the three sized constructions.
; 2056 :         // 1-arg -> value-construction, e.g. vector(5)
; 2057 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2058 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2059 :         auto& _Al       = _Getal();
; 2060 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2061 :         auto& _My_data  = _Mypair._Myval2;
; 2062 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2063 :         if (_Count != 0) {

	jmp	SHORT $LN74@main
$LN447@main:
	mov	r14, QWORD PTR i$27[rbp-97]
	mov	rdi, QWORD PTR i$27[rbp-105]
$LN74@main:
; File G:\VSproject\\II\II\Main.cpp

; 107  : 		for (auto j : i) {

	cmp	rbx, r14
	je	SHORT $LN6@main
	npad	3
$LL7@main:

; 108  : 			cout << j << " ";

	mov	edx, DWORD PTR [rbx]
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
	mov	rcx, rax
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 107  : 		for (auto j : i) {

	add	rbx, 4
	cmp	rbx, r14
	jne	SHORT $LL7@main
$LN6@main:

; 109  : 		}
; 110  : 		cout << endl;

	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
	npad	1
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	test	rdi, rdi
	je	SHORT $LN2@main

; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	sub	r15, rdi
	sar	r15, 2
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r15*4]
	mov	rax, rdi

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN33@main

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rdi, QWORD PTR [rdi-8]
	sub	rax, rdi

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN30@main
$LN33@main:

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@main:
; File G:\VSproject\\II\II\Main.cpp

; 106  : 	for (auto i : result) {

	add	rsi, 24
	cmp	rsi, r12
	jne	$LN450@main
	mov	r12, QWORD PTR result$[rbp-97]
	mov	rsi, QWORD PTR result$[rbp-105]
$LN446@main:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	test	rsi, rsi
	je	SHORT $LN99@main

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdx, r12
	mov	rcx, rsi
	call	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >

; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR result$[rbp-89]
	mov	r8, QWORD PTR result$[rbp-105]
	sub	rcx, r8
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx+rdx*2]
	shl	rdx, 3
	mov	rax, r8

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN115@main

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [r8-8]
	sub	rax, r8

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN115@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN30@main:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN115@main:

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r8
	call	??3@YAXPEAX_K@Z				; operator delete
	xorps	xmm0, xmm0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	movdqu	XMMWORD PTR result$[rbp-105], xmm0

; 2048 :             _Mylast  = nullptr;
; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR result$[rbp-89], r13
$LN99@main:

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR candidates$[rbp-105]
	test	rcx, rcx
	je	SHORT $LN123@main

; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR candidates$[rbp-89]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4
	mov	rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN139@main

; 147  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN139@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN139@main:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN123@main:
; File G:\VSproject\\II\II\Main.cpp

; 112  : 	return 0;

	xor	eax, eax

; 113  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-105]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN429@main:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2005 :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
	npad	1
$LN449@main:
main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T22 = 32
$T14 = 32
$T10 = 32
$T1 = 32
candidates$ = 80
result$ = 104
i$27 = 128
__$ArrayPad$ = 152
main$dtor$0 PROC
	lea	rcx, QWORD PTR candidates$[rdx]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T22 = 32
$T14 = 32
$T10 = 32
$T1 = 32
candidates$ = 80
result$ = 104
i$27 = 128
__$ArrayPad$ = 152
main$dtor$2 PROC
	lea	rcx, QWORD PTR $T22[rdx]
	jmp	??1Solution@@QEAA@XZ
main$dtor$2 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T22 = 32
$T14 = 32
$T10 = 32
$T1 = 32
candidates$ = 80
result$ = 104
i$27 = 128
__$ArrayPad$ = 152
main$dtor$3 PROC
	lea	rcx, QWORD PTR result$[rdx]
	jmp	??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
main$dtor$3 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T22 = 32
$T14 = 32
$T10 = 32
$T1 = 32
candidates$ = 80
result$ = 104
i$27 = 128
__$ArrayPad$ = 152
main$dtor$4 PROC
	lea	rcx, QWORD PTR i$27[rdx]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
main$dtor$4 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0Solution@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Solution@@QEAA@XZ PROC				; Solution::Solution, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0Solution@@QEAA@XZ ENDP				; Solution::Solution
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z PROC ; std::vector<int,std::allocator<int> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z ENDP ; std::vector<int,std::allocator<int> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??1Solution@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Solution@@QEAA@XZ PROC				; Solution::~Solution, COMDAT
$LN34:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN6@Solution

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN22@Solution

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN19@Solution

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN22@Solution:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN6@Solution:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@Solution:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN31@Solution:
??1Solution@@QEAA@XZ ENDP				; Solution::~Solution
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::end, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1135 :         const auto _Scary = _Get_scary();
; 1136 :         return iterator(_Scary->_Myhead, _Scary);

	mov	rax, rdx

; 1137 :     }

	ret	0
?end@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::begin, COMDAT

; 1125 :         const auto _Scary = _Get_scary();
; 1126 :         return iterator(_Scary->_Myhead->_Left, _Scary);

	mov	rax, QWORD PTR [rcx]

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rcx, QWORD PTR [rax]

; 1125 :         const auto _Scary = _Get_scary();
; 1126 :         return iterator(_Scary->_Myhead->_Left, _Scary);

	mov	rax, rdx

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx

; 1127 :     }

	ret	0
?begin@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::~_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >, COMDAT

; 1079 :     ~_Tree() noexcept {

$LN29:
	push	rbx
	sub	rsp, 32					; 00000020H

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	r8, QWORD PTR [rcx]
	mov	rdx, rcx

; 1079 :     ~_Tree() noexcept {

	mov	rbx, rcx

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	r8, QWORD PTR [r8+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Erase_tree<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rbx]
	mov	edx, 56					; 00000038H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1086 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??1?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::~_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$dead$ = 24
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator-, COMDAT

; 329  :     _NODISCARD _CONSTEXPR20 _Vector_iterator operator-(const difference_type _Off) const noexcept {

	xor	eax, eax
	mov	QWORD PTR [rdx], rax

; 126  :         _Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	sub	rax, 24
	mov	QWORD PTR [rdx], rax

; 330  :         _Vector_iterator _Tmp = *this;
; 331  :         _Tmp -= _Off;
; 332  :         return _Tmp;

	mov	rax, rdx

; 333  :     }

	ret	0
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator==, COMDAT

; 162  :         _Compat(_Right);
; 163  :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 164  :     }

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\initializer_list
;	COMDAT ??0?$initializer_list@H@std@@QEAA@PEBH0@Z
_TEXT	SEGMENT
this$ = 8
_First_arg$ = 16
_Last_arg$ = 24
??0?$initializer_list@H@std@@QEAA@PEBH0@Z PROC		; std::initializer_list<int>::initializer_list<int>, COMDAT

; 35   :         : _First(_First_arg), _Last(_Last_arg) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0?$initializer_list@H@std@@QEAA@PEBH0@Z ENDP		; std::initializer_list<int>::initializer_list<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::end, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1135 :         const auto _Scary = _Get_scary();
; 1136 :         return iterator(_Scary->_Myhead, _Scary);

	mov	rax, rdx

; 1137 :     }

	ret	0
?end@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::begin, COMDAT

; 1125 :         const auto _Scary = _Get_scary();
; 1126 :         return iterator(_Scary->_Myhead->_Left, _Scary);

	mov	rax, QWORD PTR [rcx]

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rcx, QWORD PTR [rax]

; 1125 :         const auto _Scary = _Get_scary();
; 1126 :         return iterator(_Scary->_Myhead->_Left, _Scary);

	mov	rax, rdx

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rdx], rcx

; 1127 :     }

	ret	0
?begin@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >, COMDAT

; 1079 :     ~_Tree() noexcept {

$LN64:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	rbx, QWORD PTR [rcx]

; 1079 :     ~_Tree() noexcept {

	mov	rdi, rcx

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	rbx, QWORD PTR [rbx+8]

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN7@Tree
	npad	6
$LL6@Tree:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	r8, QWORD PTR [rbx+16]
	mov	rdx, rdi
	mov	rcx, rdi
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, rbx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rbx, QWORD PTR [rbx]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL6@Tree
$LN7@Tree:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rdi]
	mov	edx, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1086 :     }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?back@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAAEAV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAAEAV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::back, COMDAT

; 1937 :         auto& _My_data = _Mypair._Myval2;
; 1938 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1939 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1940 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1941 : 
; 1942 :         return _My_data._Mylast[-1];

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, 24

; 1943 :     }

	ret	0
?back@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAAEAV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Unchecked_end@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Unchecked_end, COMDAT

; 1853 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1854 :     }

	ret	0
?_Unchecked_end@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Unchecked_begin, COMDAT

; 1845 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1846 :     }

	ret	0
?_Unchecked_begin@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?end@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::end, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1803 :         auto& _My_data = _Mypair._Myval2;
; 1804 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	rax, rdx

; 1805 :     }

	ret	0
?end@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?begin@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::begin, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1793 :         auto& _My_data = _Mypair._Myval2;
; 1794 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	rax, rdx

; 1795 :     }

	ret	0
?begin@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?erase@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 96
__$ReturnUdt$ = 104
_Where$ = 112
?erase@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::erase, COMDAT

; 1715 :         is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

$LN88:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1716 :         const pointer _Whereptr = _Where._Ptr;
; 1717 :         auto& _My_data          = _Mypair._Myval2;
; 1718 :         pointer& _Mylast        = _My_data._Mylast;
; 1719 : 
; 1720 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1721 :         _STL_VERIFY(
; 1722 :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Mylast > _Whereptr,
; 1723 :             "vector erase iterator outside range");
; 1724 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1725 : 
; 1726 :         _Orphan_range(_Whereptr, _Mylast);
; 1727 :         _STD _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

	mov	rbp, QWORD PTR [rcx+8]
	lea	rax, QWORD PTR [r8+24]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4800 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	xor	r13d, r13d
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1715 :         is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

	mov	rbx, r8
	mov	r12, rdx
	mov	r15, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4800 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	cmp	rax, rbp
	je	SHORT $LN5@erase
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1715 :         is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

	lea	rdi, QWORD PTR [r8+40]
$LL6@erase:

; 735  :         if (this == _STD addressof(_Right)) {

	lea	r14, QWORD PTR [rdi-16]
	lea	rsi, QWORD PTR [rdi-40]
	cmp	rsi, r14
	je	SHORT $LN4@erase

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rsi]
	test	rcx, rcx
	je	SHORT $LN76@erase

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi-24]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN28@erase

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN58@erase

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN28@erase:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi-32], r13
$LN76@erase:

; 412  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [r14]
	mov	QWORD PTR [rsi], rax

; 413  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdi-8]
	mov	QWORD PTR [rdi-32], rax

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rdi-24], rax

; 415  : 
; 416  :         _Right._Myfirst = nullptr;

	mov	QWORD PTR [r14], r13

; 417  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [rdi-8], r13

; 418  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [rdi], r13
$LN4@erase:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4800 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	add	rdi, 24
	lea	rax, QWORD PTR [rdi-16]
	cmp	rax, rbp
	jne	SHORT $LL6@erase
$LN5@erase:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1728 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

	mov	rdi, QWORD PTR [r15+8]

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi-24]
	test	rcx, rcx
	je	SHORT $LN45@erase

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi-8]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN61@erase

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN58@erase

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN61@erase:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	mov	QWORD PTR [rdi-24], r13

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi-16], r13

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi-8], r13
$LN45@erase:

; 1729 :         _ASAN_VECTOR_MODIFY(-1);
; 1730 :         --_Mylast;

	add	QWORD PTR [r15+8], -24

; 1731 :         return iterator(_Whereptr, _STD addressof(_My_data));

	mov	rax, r12

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [r12], rbx

; 1732 :     }

	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN58@erase:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN85@erase:
?erase@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?push_back@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAX$$QEAV?$vector@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAX$$QEAV?$vector@HV?$allocator@H@std@@@2@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::push_back, COMDAT

; 779  :         if (_Mylast != _My_data._Myend) {

	mov	r10, QWORD PTR [rcx+8]

; 874  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

	mov	r9, rcx

; 779  :         if (_Mylast != _My_data._Myend) {

	cmp	r10, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+16]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r11d, r11d

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rdx+8]
	mov	rax, QWORD PTR [rdx]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r11
	mov	QWORD PTR [rdx+8], r11
	mov	QWORD PTR [rdx], r11
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10], rax
	mov	QWORD PTR [r10+8], rcx
	mov	QWORD PTR [r10+16], r8

; 804  :         ++_Mylast;

	add	QWORD PTR [r9+8], 24

; 875  :         // insert by moving into element at end, provide strong guarantee
; 876  :         _Emplace_one_at_back(_STD move(_Val));
; 877  :     }

	ret	0
$LN4@push_back:

; 783  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, r10
	jmp	??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_reallocate<std::vector<int,std::allocator<int> > >
?push_back@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAX$$QEAV?$vector@HV?$allocator@H@std@@@2@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 764  :     _CONSTEXPR20 ~vector() noexcept {

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdx, QWORD PTR [rbx+8]
	call	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >

; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rbx]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
	imul	rdx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx+rdx*2]
	shl	rdx, 3

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@vector

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@vector

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@vector:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 770  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@vector:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN28@vector:
??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 699  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 700  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 701  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 699  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 700  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 701  :     }

	ret	0
??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 609  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 610  :     }

	mov	rax, rcx
	ret	0
??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?back@?$vector@HV?$allocator@H@std@@@std@@QEAAAEAHXZ
_TEXT	SEGMENT
this$ = 8
?back@?$vector@HV?$allocator@H@std@@@std@@QEAAAEAHXZ PROC ; std::vector<int,std::allocator<int> >::back, COMDAT

; 1937 :         auto& _My_data = _Mypair._Myval2;
; 1938 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1939 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1940 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1941 : 
; 1942 :         return _My_data._Mylast[-1];

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, 4

; 1943 :     }

	ret	0
?back@?$vector@HV?$allocator@H@std@@@std@@QEAAAEAHXZ ENDP ; std::vector<int,std::allocator<int> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QEAAAEAH_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@HV?$allocator@H@std@@@std@@QEAAAEAH_K@Z PROC ; std::vector<int,std::allocator<int> >::operator[], COMDAT

; 1881 :         auto& _My_data = _Mypair._Myval2;
; 1882 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1883 :         _STL_VERIFY(
; 1884 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1885 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1886 : 
; 1887 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*4]

; 1888 :     }

	ret	0
??A?$vector@HV?$allocator@H@std@@@std@@QEAAAEAH_K@Z ENDP ; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT

; 1866 :         auto& _My_data = _Mypair._Myval2;
; 1867 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 1868 :     }

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ PROC ; std::vector<int,std::allocator<int> >::_Unchecked_end, COMDAT

; 1853 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1854 :     }

	ret	0
?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ PROC ; std::vector<int,std::allocator<int> >::_Unchecked_begin, COMDAT

; 1845 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1846 :     }

	ret	0
?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QEAAPEAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1803 :         auto& _My_data = _Mypair._Myval2;
; 1804 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	rax, rdx

; 1805 :     }

	ret	0
?end@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1793 :         auto& _My_data = _Mypair._Myval2;
; 1794 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	rax, rdx

; 1795 :     }

	ret	0
?begin@?$vector@HV?$allocator@H@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?pop_back@?$vector@HV?$allocator@H@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$vector@HV?$allocator@H@std@@@std@@QEAAXXZ PROC ; std::vector<int,std::allocator<int> >::pop_back, COMDAT

; 1701 :         auto& _My_data   = _Mypair._Myval2;
; 1702 :         pointer& _Mylast = _My_data._Mylast;
; 1703 : 
; 1704 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1705 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1706 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1707 : 
; 1708 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1709 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
; 1710 :         _ASAN_VECTOR_MODIFY(-1);
; 1711 :         --_Mylast;

	add	QWORD PTR [rcx+8], -4

; 1712 :     }

	ret	0
?pop_back@?$vector@HV?$allocator@H@std@@@std@@QEAAXXZ ENDP ; std::vector<int,std::allocator<int> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$dead$ = 56
?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z PROC ; std::vector<int,std::allocator<int> >::resize, COMDAT

; 1588 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

$LN31:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1555 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1588 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

	mov	rdi, rcx

; 1555 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, QWORD PTR [rcx]
	mov	rcx, rsi
	sub	rcx, rdx
	sar	rcx, 2

; 1556 :         if (_Newsize < _Oldsize) { // trim

	cmp	rcx, 51					; 00000033H
	jbe	SHORT $LN4@resize

; 1557 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+204]

; 1589 :         // trim or append value-initialized elements, provide strong guarantee
; 1590 :         _Resize(_Newsize, _Value_init_tag{});
; 1591 :     }

	mov	QWORD PTR [rdi+8], rax
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@resize:

; 1565 :         if (_Newsize > _Oldsize) { // append

	jae	SHORT $LN5@resize

; 1566 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rdx
	sar	rax, 2

; 1567 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rax, 51					; 00000033H
	jae	SHORT $LN6@resize

; 1568 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rdi

; 1589 :         // trim or append value-initialized elements, provide strong guarantee
; 1590 :         _Resize(_Newsize, _Value_init_tag{});
; 1591 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1568 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize_reallocate<std::_Value_init_tag>
$LN6@resize:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 2010 :             _Zero_range(_PFirst, _PFirst + _Count);

	mov	eax, 51					; 00000033H
	mov	QWORD PTR [rsp+56], rbx
	sub	rax, rcx

; 1995 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	rcx, rsi

; 2010 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [rax*4]

; 1995 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	call	memset

; 2011 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rsi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1578 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	rbx, QWORD PTR [rsp+56]

; 1589 :         // trim or append value-initialized elements, provide strong guarantee
; 1590 :         _Resize(_Newsize, _Value_init_tag{});
; 1591 :     }

	mov	QWORD PTR [rdi+8], rax
$LN5@resize:
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?resize@?$vector@HV?$allocator@H@std@@@std@@QEAAX_K@Z ENDP ; std::vector<int,std::allocator<int> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\initializer_list
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\initializer_list
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\initializer_list
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@V?$initializer_list@H@1@@Z
_TEXT	SEGMENT
this$ = 80
_Ilist$ = 88
??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@V?$initializer_list@H@1@@Z PROC ; std::vector<int,std::allocator<int> >::operator=, COMDAT

; 1501 :     _CONSTEXPR20 vector& operator=(initializer_list<_Ty> _Ilist) {

$LN71:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 32					; 00000020H

; 1391 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rdi, QWORD PTR [rcx]

; 1501 :     _CONSTEXPR20 vector& operator=(initializer_list<_Ty> _Ilist) {

	mov	rsi, rcx

; 1391 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	r15, QWORD PTR [rdx]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1391 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	sub	rcx, rdi
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	rbp, QWORD PTR [rdx+8]
	sub	rbp, r15
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1391 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	sar	rcx, 2
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\initializer_list

; 46   :         return static_cast<size_t>(_Last - _First);

	sar	rbp, 2
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1392 :         if (_Newsize > _Oldcapacity) {

	cmp	rbp, rcx
	jbe	SHORT $LN9@operator

; 1393 :             _Clear_and_reserve_geometric(_Newsize);

	mov	rdx, rbp
	mov	rcx, rsi
	call	?_Clear_and_reserve_geometric@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Clear_and_reserve_geometric

; 1394 :             if constexpr (_Nothrow_construct) {
; 1395 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdi, QWORD PTR [rsi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rbp*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	mov	rdx, r15
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1856 :             _Dest += _Count;

	lea	rcx, QWORD PTR [rbx+rdi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1505 :     }

	mov	rax, rsi

; 1395 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rcx

; 1505 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN9@operator:
	mov	QWORD PTR [rsp+96], r14

; 1405 :         if (_Newsize > _Oldsize) {

	mov	rdx, r15
	mov	r14, QWORD PTR [rsi+8]
	mov	rcx, rdi
	sub	r14, rdi
	sar	r14, 2
	cmp	rbp, r14
	jbe	SHORT $LN10@operator
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [r14*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1426 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	mov	rdi, QWORD PTR [rsi+8]
	lea	rdx, QWORD PTR [rbx+r15]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	sub	rbp, r14
$LN10@operator:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1433 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbx, QWORD PTR [rbp*4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
	mov	r14, QWORD PTR [rsp+96]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1433 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rbx+rdi]

; 1434 :             _Copy_n_unchecked4(_STD move(_First), _Newsize, _Myfirst);
; 1435 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1436 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1437 :             _Mylast = _Newlast;

	mov	QWORD PTR [rsi+8], rax

; 1505 :     }

	mov	rax, rsi
	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@V?$initializer_list@H@1@@Z ENDP ; std::vector<int,std::allocator<int> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\initializer_list
;	COMDAT ?size@?$initializer_list@H@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$initializer_list@H@std@@QEBA_KXZ PROC		; std::initializer_list<int>::size, COMDAT

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 47   :     }

	ret	0
?size@?$initializer_list@H@std@@QEBA_KXZ ENDP		; std::initializer_list<int>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QEAAXAEBH@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@HV?$allocator@H@std@@@std@@QEAAXAEBH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT

; 870  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	mov	r8, rdx

; 779  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN4@push_back

; 795  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax

; 796  :         } else {
; 797  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 798  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 799  :             _ASAN_VECTOR_RELEASE_GUARD;
; 800  :         }
; 801  : 
; 802  :         _Orphan_range(_Mylast, _Mylast);
; 803  :         _Ty& _Result = *_Mylast;
; 804  :         ++_Mylast;

	add	QWORD PTR [rcx+8], 4

; 871  :         _Emplace_one_at_back(_Val);
; 872  :     }

	ret	0
$LN4@push_back:

; 783  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
?push_back@?$vector@HV?$allocator@H@std@@@std@@QEAAXAEBH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT

; 764  :     _CONSTEXPR20 ~vector() noexcept {

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN4@vector

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN20@vector

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN17@vector

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN20@vector:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 770  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN17@vector:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN28@vector:
??1?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::vector<int,std::allocator<int> >::operator=, COMDAT

; 734  :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

$LN37:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx

; 735  :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN34@operator

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+64], rsi
	xor	esi, esi
	test	rcx, rcx
	je	SHORT $LN5@operator

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN21@operator

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN18@operator

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN21@operator:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx], rsi

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rsi

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rsi
$LN5@operator:

; 412  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rbx], rax

; 413  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+8], rax

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdi+16]
	mov	QWORD PTR [rbx+16], rax

; 415  : 
; 416  :         _Right._Myfirst = nullptr;

	mov	QWORD PTR [rdi], rsi

; 417  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rsi

; 418  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rsi
	mov	rsi, QWORD PTR [rsp+64]
$LN34@operator:

; 762  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN18@operator:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN33@operator:
??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::vector<int,std::allocator<int> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT

; 681  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN62:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax

; 681  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	rbx, rdx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], rax

; 681  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	mov	rsi, rcx

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 682  :         const auto& _Right_data = _Right._Mypair._Myval2;
; 683  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rdx, QWORD PTR [rdx+8]
	sub	rdx, QWORD PTR [rbx]
	sar	rdx, 2

; 2063 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN34@vector

; 2004 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN60@vector
	mov	QWORD PTR [rsp+64], rdi

; 2006 :         }
; 2007 : 
; 2008 :         _Buy_raw(_Newcapacity);

	call	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4432 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

	mov	rdx, QWORD PTR [rbx]

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rbx, QWORD PTR [rbx+8]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2072 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1819 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 2
	lea	rcx, QWORD PTR [rdi+rbx*4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2072 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rsi+8], rcx
$LN34@vector:

; 684  :         _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);
; 685  :     }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rax, rsi
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN60@vector:

; 2005 :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
	int	3
$LN58@vector:
??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QEAA@_KAEBHAEBV?$allocator@H@1@@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
_Val$ = 64
_Al$dead$ = 72
??0?$vector@HV?$allocator@H@std@@@std@@QEAA@_KAEBHAEBV?$allocator@H@1@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT

; 622  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN70:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 2008 :         _Buy_raw(_Newcapacity);

	mov	esi, 50					; 00000032H

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx], 0

; 2008 :         _Buy_raw(_Newcapacity);

	mov	edx, esi

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+8], 0

; 622  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	rdi, r8

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rcx+16], 0

; 622  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	mov	r14, rcx

; 2008 :         _Buy_raw(_Newcapacity);

	call	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4930 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	cmp	DWORD PTR [rdi], 0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2070 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);

	mov	rbx, QWORD PTR [r14]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4930 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	jne	SHORT $LL19@vector

; 4919 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	xor	edx, edx
	mov	r8d, 200				; 000000c8H
	mov	rcx, rbx
	call	memset
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1947 :                 return _First + _Count;

	add	rbx, 200				; 000000c8H
	jmp	SHORT $LN67@vector
	npad	1
$LL19@vector:

; 1777 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rbx+4], eax
	add	rbx, 8

; 1778 :         ++_Last;

	sub	rsi, 2

; 1953 :     for (; 0 < _Count; --_Count) {

	jne	SHORT $LL19@vector
$LN67@vector:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 624  :     }

	mov	rsi, QWORD PTR [rsp+64]
	mov	rax, r14
	mov	rdi, QWORD PTR [rsp+72]
	mov	QWORD PTR [r14+8], rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QEAA@_KAEBHAEBV?$allocator@H@1@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 609  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 610  :     }

	mov	rax, rcx
	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QEAA@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@H@std@@QEAA@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT

; 935  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@H@std@@QEAA@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@HPEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@HPEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QEAA@PEAU?$_Tree_node@HPEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__param0$ = 16
__param1$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 124  :             return _Ok;

	movzx	eax, BYTE PTR [rcx+8]

; 125  :         }

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 108  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 109  : #if !_HAS_EXCEPTIONS
; 110  :             const bool _Zero_uncaught_exceptions = true;
; 111  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 112  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

	call	QWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 113  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 114  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 115  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 116  : 
; 117  :             if (_Zero_uncaught_exceptions) {

	test	al, al
	jne	SHORT $LN2@sentry

; 118  :                 this->_Myostr._Osfx();

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN2@sentry:

; 78   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rcx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rcx]
	movsxd	rdx, DWORD PTR [rax+4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rdx+rcx+72]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream

; 79   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN11@sentry

; 80   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN11@sentry:

; 119  :             }
; 120  :         }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

$LN18:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	QWORD PTR [rcx], rdx

; 71   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [r8+rdx+72]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream

; 72   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN8@sentry

; 73   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	npad	1
$LN8@sentry:

; 92   :             if (!_Ostr.good()) {

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN1@sentry

; 93   :                 _Ok = false;
; 94   :                 return;
; 95   :             }
; 96   : 
; 97   :             const auto _Tied = _Ostr.tie();

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios

; 69   :         return _Tiestr;

	mov	rcx, QWORD PTR [rcx+rbx+80]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream

; 98   :             if (!_Tied || _Tied == &_Ostr) {

	test	rcx, rcx
	je	SHORT $LN4@sentry
	cmp	rcx, rbx
	je	SHORT $LN4@sentry

; 100  :                 return;
; 101  :             }
; 102  : 
; 103  :             _Tied->flush();

	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	jmp	SHORT $LN1@sentry
$LN4@sentry:

; 99   :                 _Ok = true;

	mov	al, 1
$LN1@sentry:

; 105  :         }

	mov	BYTE PTR [rdi+8], al
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Ostr$ = 56
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx

; 39   :         this->_Adopt(_Plist);
; 40   :     }

	mov	rax, rcx
	ret	0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_scary@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Get_scary, COMDAT

; 1967 :         return _STD addressof(_Mypair._Myval2._Myval2);

	mov	rax, rcx

; 1968 :     }

	ret	0
?_Get_scary@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Getal, COMDAT

; 1959 :         return _Mypair._Myval2._Get_first();

	mov	rax, rcx

; 1960 :     }

	ret	0
?_Getal@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator-=, COMDAT

; 126  :         _Ptr += _Off;

	add	QWORD PTR [rcx], -24

; 323  :         _Mybase::operator-=(_Off);
; 324  :         return *this;

	mov	rax, rcx

; 325  :     }

	ret	0
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Right$dead$ = 16
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Compat, COMDAT

; 195  :         // test for compatible iterator pair
; 196  : #if _ITERATOR_DEBUG_LEVEL == 0
; 197  :         (void) _Right;
; 198  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
; 199  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 200  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 201  :     }

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@PEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx

; 44   :         this->_Adopt(_Pvector);
; 45   :     }

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@HPEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@HPEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	QWORD PTR [rcx], rdx

; 39   :         this->_Adopt(_Plist);
; 40   :     }

	mov	rax, rcx
	ret	0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_Tree_node@HPEAX@1@PEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\initializer_list
;	COMDAT ?begin@?$initializer_list@H@std@@QEBAPEBHXZ
_TEXT	SEGMENT
this$ = 8
?begin@?$initializer_list@H@std@@QEBAPEBHXZ PROC	; std::initializer_list<int>::begin, COMDAT

; 38   :         return _First;

	mov	rax, QWORD PTR [rcx]

; 39   :     }

	ret	0
?begin@?$initializer_list@H@std@@QEBAPEBHXZ ENDP	; std::initializer_list<int>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT

; 43   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	mov	QWORD PTR [rcx], rdx

; 44   :         this->_Adopt(_Pvector);
; 45   :     }

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEAA@PEAHPEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_scary@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Get_scary, COMDAT

; 1967 :         return _STD addressof(_Mypair._Myval2._Myval2);

	mov	rax, rcx

; 1968 :     }

	ret	0
?_Get_scary@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getal, COMDAT

; 1959 :         return _Mypair._Myval2._Get_first();

	mov	rax, rcx

; 1960 :     }

	ret	0
?_Getal@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal, COMDAT

; 2179 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2180 :     }

	ret	0
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEBAXPEAV?$vector@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEBAXPEAV?$vector@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Orphan_range, COMDAT

; 2175 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEBAXPEAV?$vector@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy, COMDAT

; 2033 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN28:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2034 :         auto& _Al         = _Getal();
; 2035 :         auto& _My_data    = _Mypair._Myval2;
; 2036 :         pointer& _Myfirst = _My_data._Myfirst;
; 2037 :         pointer& _Mylast  = _My_data._Mylast;
; 2038 :         pointer& _Myend   = _My_data._Myend;
; 2039 : 
; 2040 :         _My_data._Orphan_all();
; 2041 : 
; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdx, QWORD PTR [rbx+8]
	call	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >

; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rbx]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
	imul	rdx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx+rdx*2]
	shl	rdx, 3

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Tidy

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Tidy

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Tidy:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2051 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN15@Tidy:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN25@Tidy:
?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Take_contents@?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Take_contents@?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAAXAEAV12@@Z PROC ; std::_Vector_val<std::_Simple_types<int> >::_Take_contents, COMDAT

; 411  :         this->_Swap_proxy_and_iterators(_Right);
; 412  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 413  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 415  : 
; 416  :         _Right._Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdx], rax

; 417  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [rdx+8], rax

; 418  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [rdx+16], rax

; 419  :     }

	ret	0
?_Take_contents@?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAAXAEAV12@@Z ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEBAAEBV?$allocator@H@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEBAAEBV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT

; 2183 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2184 :     }

	ret	0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEBAAEBV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAV?$allocator@H@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT

; 2179 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2180 :     }

	ret	0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@AEBAXPEAH0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@AEBAXPEAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Orphan_range, COMDAT

; 2175 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	ret	0
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@AEBAXPEAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AEAAXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT

; 2033 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN28:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2034 :         auto& _Al         = _Getal();
; 2035 :         auto& _My_data    = _Mypair._Myval2;
; 2036 :         pointer& _Myfirst = _My_data._Myfirst;
; 2037 :         pointer& _Mylast  = _My_data._Mylast;
; 2038 :         pointer& _Myend   = _My_data._Myend;
; 2039 : 
; 2040 :         _My_data._Orphan_all();
; 2041 : 
; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Tidy

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Tidy

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Tidy:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 2051 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN15@Tidy:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN25@Tidy:
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AEAAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction, COMDAT

; 695  :         return _Al;

	mov	rax, rcx

; 696  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 474  :         return static_cast<int_type>(EOF);

	mov	eax, -1

; 475  :     }

	ret	0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 466  :         return _Left == _Right;

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rcx], eax
	sete	al

; 467  :     }

	ret	0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
_First$dead$ = 8
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 388  :         // find length of null-terminated string
; 389  : #if _HAS_CXX17
; 390  : #ifdef __cpp_char8_t
; 391  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 392  : #if _HAS_U8_INTRINSICS
; 393  :             return __builtin_u8strlen(_First);
; 394  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 395  :             return _Primary_char_traits::length(_First);
; 396  : #endif // _HAS_U8_INTRINSICS
; 397  :         } else
; 398  : #endif // __cpp_char8_t
; 399  :         {
; 400  :             return __builtin_strlen(_First);
; 401  :         }
; 402  : #else // _HAS_CXX17
; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	eax, 1

; 404  : #endif // _HAS_CXX17
; 405  :     }

	ret	0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN9:
	sub	rsp, 40					; 00000028H

; 78   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rdx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rcx+rdx+72]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream

; 79   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN2@Sentry_bas

; 80   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN2@Sentry_bas:

; 81   :             }
; 82   :         }

	add	rsp, 40					; 00000028H
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rcx], rdx
	mov	rbx, rcx

; 71   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [r8+rdx+72]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream

; 72   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN7@Sentry_bas

; 73   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
$LN7@Sentry_bas:

; 74   :             }
; 75   :         }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first, COMDAT

; 1500 :         return *this;

	mov	rax, rcx

; 1501 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??Z?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??Z?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator-=, COMDAT

; 126  :         _Ptr += _Off;

	add	QWORD PTR [rcx], -24

; 143  :         return *this += -_Off;

	mov	rax, rcx

; 144  :     }

	ret	0
??Z?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_first, COMDAT

; 1500 :         return *this;

	mov	rax, rcx

; 1501 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QEAAAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first, COMDAT

; 1500 :         return *this;

	mov	rax, rcx

; 1501 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAAAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAAXQEAV?$vector@HV?$allocator@H@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAAXQEAV?$vector@HV?$allocator@H@std@@@2@_K@Z PROC ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate, COMDAT

; 943  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN21:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 944  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 945  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8+r8*2]
	shl	rdx, 3

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 947  :     }

	add	rsp, 40					; 00000028H

; 255  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAAXQEAV?$vector@HV?$allocator@H@std@@@2@_K@Z ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEBAAEBV?$allocator@H@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEBAAEBV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEBAAEBV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAAAEAV?$allocator@H@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAAAEAV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT

; 1500 :         return *this;

	mov	rax, rcx

; 1501 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAAAEAV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z PROC	; std::allocator<int>::deallocate, COMDAT

; 943  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN21:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 944  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 945  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8*4]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 947  :     }

	add	rsp, 40					; 00000028H

; 255  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@H@std@@QEAAXQEAH_K@Z ENDP	; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator+=, COMDAT

; 125  :         _Verify_offset(_Off);
; 126  :         _Ptr += _Off;

	add	QWORD PTR [rcx], -24

; 127  :         return *this;

	mov	rax, rcx

; 128  :     }

	ret	0
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBAX_J@Z
_TEXT	SEGMENT
this$dead$ = 8
_Off$dead$ = 16
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBAX_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Verify_offset, COMDAT

; 108  : #if _ITERATOR_DEBUG_LEVEL == 0
; 109  :         (void) _Off;
; 110  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
; 111  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 112  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 113  :         _STL_VERIFY(_Off == 0 || _Mycont, "cannot seek invalidated vector iterator");
; 114  :         if (_Off < 0) {
; 115  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 116  :         }
; 117  : 
; 118  :         if (_Off > 0) {
; 119  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 120  :         }
; 121  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 122  :     }

	ret	0
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBAX_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\set
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\set
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\set
;	COMDAT ??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z
_TEXT	SEGMENT
_Loc$1$ = 32
$T14 = 32
$T7 = 48
this$GSCopy$ = 64
_Loc$15 = 72
$T6 = 96
this$ = 176
_First$ = 184
_Last$ = 192
??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z PROC ; std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >, COMDAT

; 95   :     set(_Iter _First, _Iter _Last) : _Mybase(key_compare()) {

$LN139:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 128				; 00000080H
	mov	rbx, r8
	mov	rdi, rdx
	mov	r14, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	xor	r12d, r12d
	mov	QWORD PTR [rcx], r12
	mov	QWORD PTR [rcx+8], r12
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 77   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [r12+32]
	call	??2@YAPEAX_K@Z				; operator new
	mov	r15, rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1941 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR [r14], rax

; 1259 :         for (; _First != _Last; ++_First) {

	cmp	rdi, rbx
	je	$LN135@allocator
	mov	rbp, 576460752303423487			; 07ffffffffffffffH
	npad	11
$LL48@allocator:

; 1044 :             _Loc = _Find_hint(_Hint, _In_place_key_extractor::_Extract(_Vals...));

	mov	r9, rdi
	mov	r8, r15
	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, r14
	call	??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_hint<int>
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR _Loc$1$[rsp], xmm0
	movsd	xmm0, QWORD PTR [rax+16]
	movsd	QWORD PTR _Loc$15[rsp+16], xmm0

; 1045 :             if (_Loc._Duplicate) {

	cmp	BYTE PTR _Loc$15[rsp+16], 0
	jne	SHORT $LN46@allocator

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

	cmp	QWORD PTR [r14+8], rbp
	je	SHORT $LN131@allocator

; 1050 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

	mov	rsi, QWORD PTR [r14]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR $T7[rsp], r14

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T7[rsp+8], r12

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r8, rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [r8+28], eax

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [r8], rsi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [r8+8], rsi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [r8+16], rsi

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [r8+24], 0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T7[rsp+8], r12
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1066 :         return _Scary->_Insert_node(_Loc._Location, _Inserted);

	movups	xmm0, XMMWORD PTR _Loc$1$[rsp]
	movaps	XMMWORD PTR $T14[rsp], xmm0
	lea	rdx, QWORD PTR $T14[rsp]
	mov	rcx, r14
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@U?$_Tree_id@PEAU?$_Tree_node@HPEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Insert_node
$LN46@allocator:

; 1259 :         for (; _First != _Last; ++_First) {

	add	rdi, 4
	cmp	rdi, rbx
	jne	$LL48@allocator
$LN135@allocator:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\set

; 97   :     }

	mov	rax, r14
	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN131@allocator:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1630 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	npad	1
$LN136@allocator:
??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z ENDP ; std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Loc$1$ = 32
$T14 = 32
$T7 = 48
this$GSCopy$ = 64
_Loc$15 = 72
$T6 = 96
this$ = 176
_First$ = 184
_Last$ = 192
?dtor$0@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z@4HA PROC ; `std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
?dtor$0@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z@4HA ENDP ; `std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Loc$1$ = 32
$T14 = 32
$T7 = 48
this$GSCopy$ = 64
_Loc$15 = 72
$T6 = 96
this$ = 176
_First$ = 184
_Last$ = 192
?dtor$3@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z@4HA PROC ; `std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >'::`1'::dtor$3
	lea	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
?dtor$3@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z@4HA ENDP ; `std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$assign@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@$0A@@?$vector@HV?$allocator@H@std@@@std@@QEAAXV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__$ArrayPad$ = 32
this$ = 64
_First$ = 72
_Last$ = 80
??$assign@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@$0A@@?$vector@HV?$allocator@H@std@@@std@@QEAAXV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@0@Z PROC ; std::vector<int,std::allocator<int> >::assign<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,0>, COMDAT

; 1443 :     _CONSTEXPR20 void assign(_Iter _First, _Iter _Last) {

$LN57:
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1235 :         _Iter_diff_t<_InIt> _Off = 0;

	xor	r10d, r10d
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1443 :     _CONSTEXPR20 void assign(_Iter _First, _Iter _Last) {

	mov	r11, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1233 :         auto _UFirst             = _Get_unwrapped(_First);

	mov	rax, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 97   :         return _Ptr == _Right._Ptr;

	cmp	rdx, r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1236 :         for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN21@assign
$LL32@assign:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rcx, QWORD PTR [rax+16]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1237 :             ++_Off;

	inc	r10
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LN31@assign

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rcx, QWORD PTR [rax+8]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN30@assign
$LL29@assign:
	cmp	rax, QWORD PTR [rcx+16]
	jne	SHORT $LN30@assign

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rax, rcx
	mov	rcx, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL29@assign
$LN30@assign:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rax, rcx

; 58   :         } else {

	jmp	SHORT $LN47@assign
$LN31@assign:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	r9, QWORD PTR [rcx]

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rax, rcx

; 453  :         while (!_Pnode->_Left->_Isnil) {

	cmp	BYTE PTR [r9+25], 0
	jne	SHORT $LN47@assign
	npad	3
$LL35@assign:
	mov	rcx, QWORD PTR [r9]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rax, r9
	mov	r9, rcx
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL35@assign
$LN47@assign:

; 97   :         return _Ptr == _Right._Ptr;

	cmp	rax, r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1236 :         for (; _UFirst != _ULast; ++_UFirst) {

	jne	SHORT $LL32@assign
$LN21@assign:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1450 :             _Assign_counted_range(_UFirst, _Count);

	mov	r8, r10
	mov	rcx, r11
	call	??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@_K@Z ; std::vector<int,std::allocator<int> >::_Assign_counted_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> >

; 1451 : #ifdef __cpp_lib_concepts
; 1452 :         } else if constexpr (forward_iterator<_Iter>) {
; 1453 :             const auto _Length = _To_unsigned_like(_RANGES distance(_UFirst, _ULast));
; 1454 :             const auto _Count  = _Convert_size<size_type>(_Length);
; 1455 :             _Assign_counted_range(_UFirst, _Count);
; 1456 : #endif // __cpp_lib_concepts
; 1457 :         } else {
; 1458 :             _Assign_uncounted_range(_UFirst, _ULast);
; 1459 :         }
; 1460 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
??$assign@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@$0A@@?$vector@HV?$allocator@H@std@@@std@@QEAAXV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@0@Z ENDP ; std::vector<int,std::allocator<int> >::assign<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_It$ = 16
??$_Get_unwrapped@AEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &>, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 984  :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, rcx

; 985  :     } else {
; 986  :         return static_cast<_Iter&&>(_It);
; 987  :     }
; 988  : }

	ret	0
??$_Get_unwrapped@AEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\set
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\set
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\set
;	COMDAT ??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
$T7 = 32
_Loc$1$ = 48
$T15 = 48
this$GSCopy$ = 64
_Loc$16 = 72
$T6 = 96
this$ = 176
_First$ = 184
_Last$ = 192
??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z PROC ; std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >, COMDAT

; 95   :     set(_Iter _First, _Iter _Last) : _Mybase(key_compare()) {

$LN172:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 128				; 00000080H
	mov	rbx, r8
	mov	rdi, rdx
	mov	r15, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	xor	r13d, r13d
	mov	QWORD PTR [rcx], r13
	mov	QWORD PTR [rcx+8], r13
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 77   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [r13+56]
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbp, rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1941 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR [r15], rax

; 1259 :         for (; _First != _Last; ++_First) {

	cmp	rdi, rbx
	je	$LN168@allocator
	mov	r12, 329406144173384850			; 0492492492492492H
	npad	6
$LL48@allocator:

; 1044 :             _Loc = _Find_hint(_Hint, _In_place_key_extractor::_Extract(_Vals...));

	mov	r9, rdi
	mov	r8, rbp
	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, r15
	call	??$_Find_hint@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Find_hint<std::vector<int,std::allocator<int> > >
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR _Loc$1$[rsp], xmm0
	movsd	xmm0, QWORD PTR [rax+16]
	movsd	QWORD PTR _Loc$16[rsp+16], xmm0

; 1045 :             if (_Loc._Duplicate) {

	cmp	BYTE PTR _Loc$16[rsp+16], 0
	jne	SHORT $LN46@allocator

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

	cmp	QWORD PTR [r15+8], r12
	je	$LN164@allocator

; 1050 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

	mov	rsi, QWORD PTR [r15]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR $T7[rsp], r15

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T7[rsp+8], r13

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r14, rax
	mov	QWORD PTR $T7[rsp+8], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rcx, QWORD PTR [rax+32]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, rdi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [r14], rsi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [r14+8], rsi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [r14+16], rsi

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [r14+24], 0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T7[rsp+8], r13
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1066 :         return _Scary->_Insert_node(_Loc._Location, _Inserted);

	movups	xmm0, XMMWORD PTR _Loc$1$[rsp]
	movaps	XMMWORD PTR $T15[rsp], xmm0
	mov	r8, r14
	lea	rdx, QWORD PTR $T15[rsp]
	mov	rcx, r15
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Insert_node
$LN46@allocator:

; 1259 :         for (; _First != _Last; ++_First) {

	add	rdi, 24
	cmp	rdi, rbx
	jne	$LL48@allocator
$LN168@allocator:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\set

; 97   :     }

	mov	rax, r15
	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN164@allocator:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1630 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	npad	1
$LN169@allocator:
??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z ENDP ; std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T7 = 32
_Loc$1$ = 48
$T15 = 48
this$GSCopy$ = 64
_Loc$16 = 72
$T6 = 96
this$ = 176
_First$ = 184
_Last$ = 192
?dtor$0@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z@4HA PROC ; `std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::~_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >
?dtor$0@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z@4HA ENDP ; `std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T7 = 32
_Loc$1$ = 48
$T15 = 48
this$GSCopy$ = 64
_Loc$16 = 72
$T6 = 96
this$ = 176
_First$ = 184
_Last$ = 192
?dtor$3@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z@4HA PROC ; `std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >'::`1'::dtor$3
	lea	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
?dtor$3@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z@4HA ENDP ; `std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T7 = 32
_Loc$1$ = 48
$T15 = 48
this$GSCopy$ = 64
_Loc$16 = 72
$T6 = 96
this$ = 176
_First$ = 184
_Last$ = 192
?dtor$2@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z@4HA PROC ; `std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >'::`1'::dtor$2
	lea	rcx, QWORD PTR $T7[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$2@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$set@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z@4HA ENDP ; `std::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > >::set<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > > ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$assign@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@$0A@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAXV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__$ArrayPad$ = 32
this$ = 64
_First$ = 72
_Last$ = 80
??$assign@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@$0A@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAXV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::assign<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >,0>, COMDAT

; 1443 :     _CONSTEXPR20 void assign(_Iter _First, _Iter _Last) {

$LN57:
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1235 :         _Iter_diff_t<_InIt> _Off = 0;

	xor	r10d, r10d
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1443 :     _CONSTEXPR20 void assign(_Iter _First, _Iter _Last) {

	mov	r11, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1233 :         auto _UFirst             = _Get_unwrapped(_First);

	mov	rax, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 97   :         return _Ptr == _Right._Ptr;

	cmp	rdx, r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1236 :         for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN21@assign
$LL32@assign:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rcx, QWORD PTR [rax+16]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1237 :             ++_Off;

	inc	r10
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LN31@assign

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rcx, QWORD PTR [rax+8]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN30@assign
$LL29@assign:
	cmp	rax, QWORD PTR [rcx+16]
	jne	SHORT $LN30@assign

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rax, rcx
	mov	rcx, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL29@assign
$LN30@assign:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rax, rcx

; 58   :         } else {

	jmp	SHORT $LN47@assign
$LN31@assign:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	r9, QWORD PTR [rcx]

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rax, rcx

; 453  :         while (!_Pnode->_Left->_Isnil) {

	cmp	BYTE PTR [r9+25], 0
	jne	SHORT $LN47@assign
	npad	3
$LL35@assign:
	mov	rcx, QWORD PTR [r9]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rax, r9
	mov	r9, rcx
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL35@assign
$LN47@assign:

; 97   :         return _Ptr == _Right._Ptr;

	cmp	rax, r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1236 :         for (; _UFirst != _ULast; ++_UFirst) {

	jne	SHORT $LL32@assign
$LN21@assign:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1450 :             _Assign_counted_range(_UFirst, _Count);

	mov	r8, r10
	mov	rcx, r11
	call	??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@_K@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Assign_counted_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> >

; 1451 : #ifdef __cpp_lib_concepts
; 1452 :         } else if constexpr (forward_iterator<_Iter>) {
; 1453 :             const auto _Length = _To_unsigned_like(_RANGES distance(_UFirst, _ULast));
; 1454 :             const auto _Count  = _Convert_size<size_type>(_Length);
; 1455 :             _Assign_counted_range(_UFirst, _Count);
; 1456 : #endif // __cpp_lib_concepts
; 1457 :         } else {
; 1458 :             _Assign_uncounted_range(_UFirst, _ULast);
; 1459 :         }
; 1460 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
??$assign@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@$0A@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEAAXV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::assign<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_It$ = 16
??$_Get_unwrapped@AEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > > &>, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 984  :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, rcx

; 985  :     } else {
; 986  :         return static_cast<_Iter&&>(_It);
; 987  :     }
; 988  : }

	ret	0
??$_Get_unwrapped@AEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_First$ = 72
_Last$ = 80
_Val$ = 88
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >,std::vector<int,std::allocator<int> > >, COMDAT

; 5749 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

$LN45:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rdx
	mov	rsi, rcx

; 5739 :     for (; _First != _Last; ++_First) {

	cmp	rdx, r8
	je	SHORT $LN37@find
	mov	QWORD PTR [rsp+72], rbp
	mov	rbp, QWORD PTR [r9+8]
	mov	QWORD PTR [rsp+80], r14
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1867 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r14, QWORD PTR [r9]
	sub	rbp, r14
	sar	rbp, 2
	npad	2
$LL6@find:
	mov	rcx, QWORD PTR [rdi]
	mov	r8, QWORD PTR [rdi+8]
	sub	r8, rcx
	mov	rax, r8
	sar	rax, 2

; 2220 :     if (_Left.size() != _Right.size()) {

	cmp	rax, rbp
	jne	SHORT $LN35@find
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5149 :     return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));

	mov	rdx, r14
	call	memcmp

; 5172 :             return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;

	test	eax, eax

; 5740 :         if (*_First == _Val) {

	je	SHORT $LN38@find
$LN35@find:

; 5173 :         }
; 5174 :     }
; 5175 : 
; 5176 :     for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
; 5177 :         if (!_Pred(*_UFirst1, *_UFirst2)) {
; 5178 :             return false;
; 5179 :         }
; 5180 :     }
; 5181 : 
; 5182 :     return true;
; 5183 : }
; 5184 : 
; 5185 : #if _HAS_CXX17
; 5186 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5187 : _NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5188 :     _Pr _Pred) noexcept; // terminates
; 5189 : #endif // _HAS_CXX17
; 5190 : 
; 5191 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5192 : _NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
; 5193 :     // compare [_First1, _Last1) to [_First2, ...)
; 5194 :     return _STD equal(_First1, _Last1, _First2, equal_to<>{});
; 5195 : }
; 5196 : 
; 5197 : #if _HAS_CXX17
; 5198 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5199 : _NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2) noexcept
; 5200 : /* terminates */ {
; 5201 :     // compare [_First1, _Last1) to [_First2, ...)
; 5202 :     return _STD equal(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to{});
; 5203 : }
; 5204 : #endif // _HAS_CXX17
; 5205 : 
; 5206 : _EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
; 5207 : _NODISCARD _CONSTEXPR20 bool equal(
; 5208 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
; 5209 :     // compare [_First1, _Last1) to [_First2, _Last2)
; 5210 :     _Adl_verify_range(_First1, _Last1);
; 5211 :     _Adl_verify_range(_First2, _Last2);
; 5212 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5213 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5214 :     auto _UFirst2      = _Get_unwrapped(_First2);
; 5215 :     const auto _ULast2 = _Get_unwrapped(_Last2);
; 5216 :     if constexpr (_Is_ranges_random_iter_v<_InIt1> && _Is_ranges_random_iter_v<_InIt2>) {
; 5217 :         if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
; 5218 :             return false;
; 5219 :         }
; 5220 : 
; 5221 :         return _STD equal(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
; 5222 :     } else {
; 5223 :         for (;;) {
; 5224 :             if (_UFirst1 == _ULast1) {
; 5225 :                 return _UFirst2 == _ULast2;
; 5226 :             }
; 5227 : 
; 5228 :             if (_UFirst2 == _ULast2) {
; 5229 :                 return false;
; 5230 :             }
; 5231 : 
; 5232 :             if (!_Pred(*_UFirst1, *_UFirst2)) {
; 5233 :                 return false;
; 5234 :             }
; 5235 : 
; 5236 :             ++_UFirst1;
; 5237 :             ++_UFirst2;
; 5238 :         }
; 5239 :     }
; 5240 : }
; 5241 : 
; 5242 : #if _HAS_CXX17
; 5243 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5244 : _NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5245 :     const _FwdIt2 _Last2, _Pr _Pred) noexcept; // terminates
; 5246 : #endif // _HAS_CXX17
; 5247 : 
; 5248 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5249 : _NODISCARD _CONSTEXPR20 bool equal(
; 5250 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
; 5251 :     // compare [_First1, _Last1) to [_First2, _Last2)
; 5252 :     return _STD equal(_First1, _Last1, _First2, _Last2, equal_to<>{});
; 5253 : }
; 5254 : 
; 5255 : #if _HAS_CXX17
; 5256 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5257 : _NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5258 :     const _FwdIt2 _Last2) noexcept /* terminates */ {
; 5259 :     // compare [_First1, _Last1) to [_First2, _Last2)
; 5260 :     return _STD equal(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
; 5261 : }
; 5262 : #endif // _HAS_CXX17
; 5263 : 
; 5264 : #ifdef __cpp_lib_concepts
; 5265 : namespace ranges {
; 5266 :     template <forward_range _Rng, class _It>
; 5267 :     _NODISCARD constexpr iterator_t<_Rng> _Rewrap_iterator(_Rng&& _Range, _It&& _Val) {
; 5268 :         _STL_INTERNAL_STATIC_ASSERT(is_same_v<remove_cvref_t<_It>, _Unwrapped_iterator_t<_Rng>>);
; 5269 : 
; 5270 :         if constexpr (is_same_v<remove_cvref_t<_It>, iterator_t<_Rng>>) {
; 5271 :             return _STD forward<_It>(_Val);
; 5272 :         } else {
; 5273 :             auto _Result = _RANGES begin(_Range);
; 5274 :             _Result._Seek_to(_STD forward<_It>(_Val));
; 5275 :             return _Result;
; 5276 :         }
; 5277 :     }
; 5278 : 
; 5279 :     _EXPORT_STD template <class _In1, class _In2>
; 5280 :     struct in_in_result {
; 5281 :         /* [[no_unique_address]] */ _In1 in1;
; 5282 :         /* [[no_unique_address]] */ _In2 in2;
; 5283 : 
; 5284 :         template <_Convertible_from<const _In1&> _IIn1, _Convertible_from<const _In2&> _IIn2>
; 5285 :         constexpr operator in_in_result<_IIn1, _IIn2>() const& {
; 5286 :             return {in1, in2};
; 5287 :         }
; 5288 : 
; 5289 :         template <_Convertible_from<_In1> _IIn1, _Convertible_from<_In2> _IIn2>
; 5290 :         constexpr operator in_in_result<_IIn1, _IIn2>() && {
; 5291 :             return {_STD move(in1), _STD move(in2)};
; 5292 :         }
; 5293 :     };
; 5294 : 
; 5295 :     _EXPORT_STD template <class _In1, class _In2>
; 5296 :     using mismatch_result = in_in_result<_In1, _In2>;
; 5297 : 
; 5298 :     // clang-format off
; 5299 :     template <input_iterator _It1, input_iterator _It2, class _Pr, class _Pj1, class _Pj2>
; 5300 :         requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 5301 :     _NODISCARD constexpr mismatch_result<_It1, _It2> _Mismatch_n(
; 5302 :         _It1 _First1, _It2 _First2, iter_difference_t<_It1> _Count, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 5303 :         // clang-format on
; 5304 :         _STL_INTERNAL_CHECK(_Count >= 0);
; 5305 :         for (; _Count != 0; ++_First1, (void) ++_First2, --_Count) {
; 5306 :             if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
; 5307 :                 break;
; 5308 :             }
; 5309 :         }
; 5310 : 
; 5311 :         return {_STD move(_First1), _STD move(_First2)};
; 5312 :     }
; 5313 : 
; 5314 :     template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2, class _Pr,
; 5315 :         class _Pj1, class _Pj2>
; 5316 :         requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 5317 :     _NODISCARD constexpr mismatch_result<_It1, _It2> _Mismatch_4(
; 5318 :         _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
; 5319 : 
; 5320 :         for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) {
; 5321 :             if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
; 5322 :                 break;
; 5323 :             }
; 5324 :         }
; 5325 : 
; 5326 :         return {_STD move(_First1), _STD move(_First2)};
; 5327 :     }
; 5328 : 
; 5329 :     class _Mismatch_fn : private _Not_quite_object {
; 5330 :     public:
; 5331 :         using _Not_quite_object::_Not_quite_object;
; 5332 : 
; 5333 :         // clang-format off
; 5334 :         template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
; 5335 :             class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
; 5336 :             requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
; 5337 :         _NODISCARD constexpr mismatch_result<_It1, _It2> operator()(_It1 _First1, _Se1 _Last1,
; 5338 :             _It2 _First2, _Se2 _Last2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 5339 :             // clang-format on
; 5340 :             _Adl_verify_range(_First1, _Last1);
; 5341 :             _Adl_verify_range(_First2, _Last2);
; 5342 : 
; 5343 :             if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
; 5344 :                 iter_difference_t<_It1> _Count1       = _Last1 - _First1;
; 5345 :                 const iter_difference_t<_It2> _Count2 = _Last2 - _First2;
; 5346 :                 if (_Count1 > _Count2) {
; 5347 :                     _Count1 = static_cast<decltype(_Count1)>(_Count2);
; 5348 :                 }
; 5349 : 
; 5350 :                 auto _Result = _RANGES _Mismatch_n(_Get_unwrapped(_STD move(_First1)),
; 5351 :                     _Get_unwrapped(_STD move(_First2)), _Count1, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 5352 :                 _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5353 :                 _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5354 :                 return {_STD move(_First1), _STD move(_First2)};
; 5355 :             } else {
; 5356 :                 auto _Result = _RANGES _Mismatch_4(_Unwrap_iter<_Se1>(_STD move(_First1)),
; 5357 :                     _Unwrap_sent<_It1>(_STD move(_Last1)), _Unwrap_iter<_Se2>(_STD move(_First2)),
; 5358 :                     _Unwrap_sent<_It2>(_STD move(_Last2)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 5359 :                 _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5360 :                 _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5361 :                 return {_STD move(_First1), _STD move(_First2)};
; 5362 :             }
; 5363 :         }
; 5364 : 
; 5365 :         template <input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
; 5366 :             class _Pj2 = identity>
; 5367 :             requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
; 5368 :         _NODISCARD constexpr mismatch_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>> operator()(
; 5369 :             _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
; 5370 :             if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
; 5371 :                 range_difference_t<_Rng1> _Count1       = _RANGES distance(_Range1);
; 5372 :                 const range_difference_t<_Rng2> _Count2 = _RANGES distance(_Range2);
; 5373 :                 if (_Count1 > _Count2) {
; 5374 :                     _Count1 = static_cast<range_difference_t<_Rng1>>(_Count2);
; 5375 :                 }
; 5376 : 
; 5377 :                 auto _First1 = _RANGES begin(_Range1);
; 5378 :                 auto _First2 = _RANGES begin(_Range2);
; 5379 :                 auto _Result = _RANGES _Mismatch_n(_Get_unwrapped(_STD move(_First1)),
; 5380 :                     _Get_unwrapped(_STD move(_First2)), _Count1, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
; 5381 :                 _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5382 :                 _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5383 :                 return {_STD move(_First1), _STD move(_First2)};
; 5384 :             } else {
; 5385 :                 auto _First1 = _RANGES begin(_Range1);
; 5386 :                 auto _First2 = _RANGES begin(_Range2);
; 5387 :                 auto _Result = _RANGES _Mismatch_4(_Unwrap_range_iter<_Rng1>(_STD move(_First1)), _Uend(_Range1),
; 5388 :                     _Unwrap_range_iter<_Rng2>(_STD move(_First2)), _Uend(_Range2), _Pass_fn(_Pred), _Pass_fn(_Proj1),
; 5389 :                     _Pass_fn(_Proj2));
; 5390 :                 _Seek_wrapped(_First1, _STD move(_Result.in1));
; 5391 :                 _Seek_wrapped(_First2, _STD move(_Result.in2));
; 5392 :                 return {_STD move(_First1), _STD move(_First2)};
; 5393 :             }
; 5394 :         }
; 5395 :     };
; 5396 : 
; 5397 :     _EXPORT_STD inline constexpr _Mismatch_fn mismatch{_Not_quite_object::_Construct_tag {}};
; 5398 : } // namespace ranges
; 5399 : #endif // __cpp_lib_concepts
; 5400 : 
; 5401 : template <class _Elem1, class _Elem2>
; 5402 : _INLINE_VAR constexpr bool _Lex_compare_memcmp_classify_elements = conjunction_v<_Is_character_or_bool<_Elem1>,
; 5403 :     _Is_character_or_bool<_Elem2>, is_unsigned<_Elem1>, is_unsigned<_Elem2>>;
; 5404 : 
; 5405 : #ifdef __cpp_lib_byte
; 5406 : template <>
; 5407 : inline constexpr bool _Lex_compare_memcmp_classify_elements<byte, byte> = true;
; 5408 : #endif // __cpp_lib_byte
; 5409 : 
; 5410 : template <class _Elem1, class _Elem2, class _Pr>
; 5411 : struct _Lex_compare_memcmp_classify_pred {
; 5412 :     using _Pred = void;
; 5413 : };
; 5414 : 
; 5415 : template <class _Elem1, class _Elem2, class _Elem3>
; 5416 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<_Elem3>> {
; 5417 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
; 5418 :                                     && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
; 5419 :                                     && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
; 5420 :         less<int>, void>;
; 5421 : };
; 5422 : 
; 5423 : template <class _Elem1, class _Elem2>
; 5424 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<>> {
; 5425 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
; 5426 : };
; 5427 : 
; 5428 : template <class _Elem1, class _Elem2, class _Elem3>
; 5429 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<_Elem3>> {
; 5430 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
; 5431 :                                     && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
; 5432 :                                     && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
; 5433 :         greater<int>, void>;
; 5434 : };
; 5435 : 
; 5436 : template <class _Elem1, class _Elem2>
; 5437 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<>> {
; 5438 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
; 5439 : };
; 5440 : 
; 5441 : #ifdef __cpp_lib_concepts
; 5442 : template <class _Elem1, class _Elem2>
; 5443 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, _RANGES less> {
; 5444 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
; 5445 : };
; 5446 : 
; 5447 : template <class _Elem1, class _Elem2>
; 5448 : struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, _RANGES greater> {
; 5449 :     using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
; 5450 : };
; 5451 : #endif // __cpp_lib_concepts
; 5452 : 
; 5453 : template <class _It1, class _It2, class _Pr>
; 5454 : using _Lex_compare_memcmp_classify =
; 5455 :     conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
; 5456 :         typename _Lex_compare_memcmp_classify_pred<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Pr>::_Pred, void>;
; 5457 : 
; 5458 : _EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
; 5459 : _NODISCARD _CONSTEXPR20 bool lexicographical_compare(
; 5460 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
; 5461 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5462 :     _Adl_verify_range(_First1, _Last1);
; 5463 :     _Adl_verify_range(_First2, _Last2);
; 5464 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5465 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);
; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);
; 5468 : 
; 5469 :     using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
; 5470 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5471 : #if _HAS_CXX20
; 5472 :         if (!_STD is_constant_evaluated())
; 5473 : #endif // _HAS_CXX20
; 5474 :         {
; 5475 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5476 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5477 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5478 :             return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
; 5479 :         }
; 5480 :     }
; 5481 : 
; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it
; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {
; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {
; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;
; 5491 : }
; 5492 : 
; 5493 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5494 : _NODISCARD _CONSTEXPR20 bool lexicographical_compare(
; 5495 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
; 5496 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5497 :     return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>{});
; 5498 : }
; 5499 : 
; 5500 : #if _HAS_CXX17
; 5501 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5502 : _NODISCARD bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5503 :     const _FwdIt2 _Last2, _Pr _Pred) noexcept /* terminates */ {
; 5504 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5505 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 5506 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 5507 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
; 5508 :     return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2, _Pass_fn(_Pred));
; 5509 : }
; 5510 : 
; 5511 : _EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
; 5512 : _NODISCARD bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
; 5513 :     const _FwdIt2 _Last2) noexcept /* terminates */ {
; 5514 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5515 :     // not parallelized at present, parallelism expected to be feasible in a future release
; 5516 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
; 5517 :     _REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
; 5518 :     return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2);
; 5519 : }
; 5520 : #endif // _HAS_CXX17
; 5521 : 
; 5522 : #ifdef __cpp_lib_concepts
; 5523 : template <class _Elem1, class _Elem2, class _Cmp>
; 5524 : struct _Lex_compare_three_way_memcmp_classify_comp {
; 5525 :     using _Comp = void;
; 5526 : };
; 5527 : 
; 5528 : template <class _Elem1, class _Elem2>
; 5529 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, compare_three_way> {
; 5530 :     using _Comp = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>
; 5531 :                                     && three_way_comparable_with<const _Elem1&, const _Elem2&>,
; 5532 :         compare_three_way, void>;
; 5533 : };
; 5534 : 
; 5535 : template <class _Elem1, class _Elem2>
; 5536 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Strong_order::_Cpo> {
; 5537 :     using _Comp =
; 5538 :         conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_strong_order<_Elem1, _Elem2>,
; 5539 :             _Strong_order::_Cpo, void>;
; 5540 : };
; 5541 : 
; 5542 : template <class _Elem1, class _Elem2>
; 5543 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Weak_order::_Cpo> {
; 5544 :     using _Comp =
; 5545 :         conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_weak_order<_Elem1, _Elem2>,
; 5546 :             _Weak_order::_Cpo, void>;
; 5547 : };
; 5548 : 
; 5549 : template <class _Elem1, class _Elem2>
; 5550 : struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Partial_order::_Cpo> {
; 5551 :     using _Comp =
; 5552 :         conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_partial_order<_Elem1, _Elem2>,
; 5553 :             _Partial_order::_Cpo, void>;
; 5554 : };
; 5555 : 
; 5556 : template <class _It1, class _It2, class _Cmp>
; 5557 : using _Lex_compare_three_way_memcmp_classify =
; 5558 :     conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
; 5559 :         typename _Lex_compare_three_way_memcmp_classify_comp<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Cmp>::_Comp,
; 5560 :         void>;
; 5561 : 
; 5562 : _EXPORT_STD template <class _InIt1, class _InIt2, class _Cmp>
; 5563 : _NODISCARD constexpr auto lexicographical_compare_three_way(const _InIt1 _First1, const _InIt1 _Last1,
; 5564 :     const _InIt2 _First2, const _InIt2 _Last2, _Cmp _Comp) -> decltype(_Comp(*_First1, *_First2)) {
; 5565 :     _Adl_verify_range(_First1, _Last1);
; 5566 :     _Adl_verify_range(_First2, _Last2);
; 5567 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5568 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5569 :     auto _UFirst2      = _Get_unwrapped(_First2);
; 5570 :     const auto _ULast2 = _Get_unwrapped(_Last2);
; 5571 : 
; 5572 :     using _Memcmp_pred = _Lex_compare_three_way_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Cmp>;
; 5573 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5574 :         if (!_STD is_constant_evaluated()) {
; 5575 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5576 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5577 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5578 :             if (_Ans == 0) {
; 5579 :                 return _Num1 <=> _Num2;
; 5580 :             } else {
; 5581 :                 return _Memcmp_pred{}(_Ans, 0);
; 5582 :             }
; 5583 :         }
; 5584 :     }
; 5585 : 
; 5586 :     for (;;) {
; 5587 :         if (_UFirst1 == _ULast1) {
; 5588 :             return _UFirst2 == _ULast2 ? strong_ordering::equal : strong_ordering::less;
; 5589 :         }
; 5590 : 
; 5591 :         if (_UFirst2 == _ULast2) {
; 5592 :             return strong_ordering::greater;
; 5593 :         }
; 5594 : 
; 5595 :         if (const auto _CmpResult = _Comp(*_UFirst1, *_UFirst2); _CmpResult != 0) {
; 5596 :             return _CmpResult;
; 5597 :         }
; 5598 : 
; 5599 :         ++_UFirst1;
; 5600 :         ++_UFirst2;
; 5601 :     }
; 5602 : }
; 5603 : 
; 5604 : _EXPORT_STD template <class _InIt1, class _InIt2>
; 5605 : _NODISCARD constexpr auto lexicographical_compare_three_way(
; 5606 :     const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
; 5607 :     return _STD lexicographical_compare_three_way(_First1, _Last1, _First2, _Last2, compare_three_way{});
; 5608 : }
; 5609 : #endif // __cpp_lib_concepts
; 5610 : 
; 5611 : template <class _Ty, class _Elem>
; 5612 : struct _Vector_alg_in_find_is_safe_object_pointers : false_type {};
; 5613 : template <class _Ty1, class _Ty2>
; 5614 : struct _Vector_alg_in_find_is_safe_object_pointers<_Ty1*, _Ty2*>
; 5615 :     : conjunction<
; 5616 :           // _Ty1* is an object pointer type
; 5617 :           disjunction<is_object<_Ty1>, is_void<_Ty1>>,
; 5618 :           // _Ty2* is an object pointer type
; 5619 :           disjunction<is_object<_Ty2>, is_void<_Ty2>>,
; 5620 :           // either _Ty1 is the same as _Ty2 (ignoring cv-qualifiers), or one of the two is void
; 5621 :           disjunction<is_same<remove_cv_t<_Ty1>, remove_cv_t<_Ty2>>, is_void<_Ty1>, is_void<_Ty2>>> {};
; 5622 : 
; 5623 : // Can we activate the vector algorithms for find/count?
; 5624 : template <class _Iter, class _Ty, class _Elem = _Iter_value_t<_Iter>>
; 5625 : _INLINE_VAR constexpr bool _Vector_alg_in_find_is_safe =
; 5626 :     // The iterator must be contiguous so we can get raw pointers.
; 5627 :     _Iterator_is_contiguous<_Iter>
; 5628 :     // The iterator must not be volatile.
; 5629 :     && !_Iterator_is_volatile<_Iter>
; 5630 :     // And one of the following conditions must be met:
; 5631 :     && disjunction_v<
; 5632 : #ifdef __cpp_lib_byte
; 5633 :         // We're finding a std::byte in a range of std::byte.
; 5634 :         conjunction<is_same<_Ty, byte>, is_same<_Elem, byte>>,
; 5635 : #endif // __cpp_lib_byte
; 5636 :        // We're finding an integer in a range of integers.
; 5637 :        // This case is the one that requires careful runtime handling in _Could_compare_equal_to_value_type.
; 5638 :         conjunction<is_integral<_Ty>, is_integral<_Elem>>,
; 5639 :         // We're finding an (object or function) pointer in a range of pointers of the same type.
; 5640 :         conjunction<is_pointer<_Ty>, is_same<_Ty, _Elem>>,
; 5641 :         // We're finding a nullptr in a range of (object or function) pointers.
; 5642 :         conjunction<is_same<_Ty, nullptr_t>, is_pointer<_Elem>>,
; 5643 :         // We're finding an object pointer in a range of object pointers, and:
; 5644 :         // - One of the pointer types is a cv void*.
; 5645 :         // - One of the pointer types is a cv1 U* and the other is a cv2 U*.
; 5646 :         _Vector_alg_in_find_is_safe_object_pointers<_Ty, _Elem>>;
; 5647 : 
; 5648 : template <class _InIt, class _Ty>
; 5649 : _NODISCARD constexpr bool _Could_compare_equal_to_value_type(const _Ty& _Val) {
; 5650 :     // check whether _Val is within the limits of _Elem
; 5651 :     _STL_INTERNAL_STATIC_ASSERT(_Vector_alg_in_find_is_safe<_InIt, _Ty>);
; 5652 : 
; 5653 :     if constexpr (disjunction_v<
; 5654 : #ifdef __cpp_lib_byte
; 5655 :                       is_same<_Ty, byte>,
; 5656 : #endif // __cpp_lib_byte
; 5657 :                       is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
; 5658 :         return true;
; 5659 :     } else {
; 5660 :         using _Elem = _Iter_value_t<_InIt>;
; 5661 :         _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Elem> && is_integral_v<_Ty>);
; 5662 : 
; 5663 :         if constexpr (is_same_v<_Elem, bool>) {
; 5664 :             return _Val == true || _Val == false;
; 5665 :         } else if constexpr (is_signed_v<_Elem>) {
; 5666 :             // use instead of numeric_limits::min/max; avoid <limits> dependency
; 5667 :             constexpr _Elem _Min = static_cast<_Elem>(_Elem{1} << (sizeof(_Elem) * CHAR_BIT - 1));
; 5668 :             constexpr _Elem _Max = static_cast<_Elem>(~_Min);
; 5669 : 
; 5670 :             if constexpr (is_signed_v<_Ty>) {
; 5671 :                 // signed _Elem, signed _Ty
; 5672 :                 return _Min <= _Val && _Val <= _Max;
; 5673 :             } else {
; 5674 :                 // signed _Elem, unsigned _Ty
; 5675 :                 if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
; 5676 :                     // negative values of _Elem can compare equal to values of _Ty
; 5677 :                     return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
; 5678 :                 } else {
; 5679 :                     // negative values of _Elem cannot compare equal to values of _Ty
; 5680 :                     return _Val <= _Max;
; 5681 :                 }
; 5682 :             }
; 5683 :         } else {
; 5684 :             constexpr _Elem _Max = static_cast<_Elem>(~_Elem{0});
; 5685 : 
; 5686 :             if constexpr (is_unsigned_v<_Ty>) {
; 5687 :                 // unsigned _Elem, unsigned _Ty
; 5688 :                 return _Val <= _Max;
; 5689 :             } else {
; 5690 :                 // unsigned _Elem, signed _Ty
; 5691 :                 if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
; 5692 :                     // negative values of _Ty can compare equal to values of _Elem
; 5693 :                     return _Val <= _Max;
; 5694 :                 } else {
; 5695 :                     // negative values of _Ty cannot compare equal to values of _Elem
; 5696 :                     return 0 <= _Val && _Val <= _Max;
; 5697 :                 }
; 5698 :             }
; 5699 :         }
; 5700 :     }
; 5701 : }
; 5702 : 
; 5703 : template <class _InIt, class _Ty>
; 5704 : _NODISCARD _CONSTEXPR20 _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val) {
; 5705 :     // find first matching _Val; choose optimization
; 5706 :     // activate optimization for contiguous iterators to most scalar types (possibly const-qualified)
; 5707 :     if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {
; 5708 : #if _HAS_CXX20
; 5709 :         if (!_STD is_constant_evaluated())
; 5710 : #endif // _HAS_CXX20
; 5711 :         {
; 5712 :             if (!_STD _Could_compare_equal_to_value_type<_InIt>(_Val)) {
; 5713 :                 return _Last;
; 5714 :             }
; 5715 : #if _USE_STD_VECTOR_ALGORITHMS
; 5716 :             const auto _First_ptr = _To_address(_First);
; 5717 :             const auto _Result    = __std_find_trivial(_First_ptr, _To_address(_Last), _Val);
; 5718 :             if constexpr (is_pointer_v<_InIt>) {
; 5719 :                 return _Result;
; 5720 :             } else {
; 5721 :                 return _First + (_Result - _First_ptr);
; 5722 :             }
; 5723 : #else // ^^^ _USE_STD_VECTOR_ALGORITHMS / not _USE_STD_VECTOR_ALGORITHMS vvv
; 5724 :             if constexpr (sizeof(_Iter_value_t<_InIt>) == 1) {
; 5725 :                 const auto _First_ptr = _To_address(_First);
; 5726 :                 const auto _Result    = static_cast<remove_reference_t<_Iter_ref_t<_InIt>>*>(
; 5727 :                     _CSTD memchr(_First_ptr, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
; 5728 :                 if constexpr (is_pointer_v<_InIt>) {
; 5729 :                     return _Result ? _Result : _Last;
; 5730 :                 } else {
; 5731 :                     return _Result ? _First + (_Result - _First_ptr) : _Last;
; 5732 :                 }
; 5733 :             }
; 5734 :             // TRANSITION, DevCom-1614562: not trying wmemchr
; 5735 : #endif // ^^^ not _USE_STD_VECTOR_ALGORITHMS ^^^
; 5736 :         }
; 5737 :     }
; 5738 : 
; 5739 :     for (; _First != _Last; ++_First) {

	add	rdi, 24
	cmp	rdi, rbx
	jne	SHORT $LL6@find
$LN38@find:
	mov	rbp, QWORD PTR [rsp+72]

; 5750 :     _Adl_verify_range(_First, _Last);
; 5751 :     if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
; 5752 :         return _Find_vbool(_First, _Last, _Val);
; 5753 :     } else {
; 5754 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
; 5755 :         return _First;

	mov	rax, rsi
	mov	r14, QWORD PTR [rsp+80]
	mov	QWORD PTR [rsi], rdi

; 5756 :     }
; 5757 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN37@find:

; 5750 :     _Adl_verify_range(_First, _Last);
; 5751 :     if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
; 5752 :         return _Find_vbool(_First, _Last, _Val);
; 5753 :     } else {
; 5754 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
; 5755 :         return _First;

	mov	QWORD PTR [rcx], rdx
	mov	rax, rsi

; 5756 :     }
; 5757 : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V?$vector@HV?$allocator@H@std@@@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@V10@V10@AEBV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >,std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > &>, COMDAT

; 980  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 981  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 982  :         return _It + 0;
; 983  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 984  :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, QWORD PTR [rcx]

; 985  :     } else {
; 986  :         return static_cast<_Iter&&>(_It);
; 987  :     }
; 988  : }

	ret	0
??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > const &>, COMDAT

; 980  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 981  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 982  :         return _It + 0;
; 983  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 984  :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, QWORD PTR [rcx]

; 985  :     } else {
; 986  :         return static_cast<_Iter&&>(_It);
; 987  :     }
; 988  : }

	ret	0
??$_Get_unwrapped@AEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@std@@YA?A_TAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xiosbase
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xiosbase
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xiosbase
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_Ok$ = 32
_Ostr$ = 80
_Val$dead$ = 88
_State$ = 88
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 761  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

$LN104:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx

; 762  :     // insert NTBS into char stream
; 763  :     using _Elem = char;
; 764  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 765  : 
; 766  :     ios_base::iostate _State = ios_base::goodbit;

	xor	ebx, ebx
	mov	DWORD PTR _State$[rsp], ebx

; 768  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	rax, QWORD PTR [rcx]
	movsxd	rdx, DWORD PTR [rax+4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xiosbase

; 290  :         return _Wide;

	mov	rdi, QWORD PTR [rdx+rcx+40]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream

; 768  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	cmp	rdi, 2
	jl	SHORT $LN17@operator
	dec	rdi
	jmp	SHORT $LN18@operator
$LN17@operator:
	xor	edi, edi
$LN18@operator:

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	r14, rsi
	mov	QWORD PTR _Ok$[rsp], rsi
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rdx+rcx+72]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream

; 72   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN67@operator

; 73   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	npad	1
$LN67@operator:

; 92   :             if (!_Ostr.good()) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN99@operator

; 93   :                 _Ok = false;
; 94   :                 return;
; 95   :             }
; 96   : 
; 97   :             const auto _Tied = _Ostr.tie();

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios

; 69   :         return _Tiestr;

	mov	rcx, QWORD PTR [rcx+rsi+80]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream

; 98   :             if (!_Tied || _Tied == &_Ostr) {

	test	rcx, rcx
	je	SHORT $LN63@operator
	cmp	rcx, rsi
	je	SHORT $LN63@operator

; 100  :                 return;
; 101  :             }
; 102  : 
; 103  :             _Tied->flush();

	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	call	QWORD PTR __imp_?good@ios_base@std@@QEBA_NXZ
	jmp	SHORT $LN99@operator
$LN63@operator:

; 99   :                 _Ok = true;

	mov	al, 1
$LN99@operator:

; 105  :         }

	mov	BYTE PTR _Ok$[rsp+8], al

; 769  :     const typename _Myos::sentry _Ok(_Ostr);
; 770  : 
; 771  :     if (!_Ok) {

	test	al, al
	jne	SHORT $LN8@operator

; 772  :         _State |= ios_base::badbit;

	mov	ebx, 4

; 773  :     } else { // state okay, insert

	jmp	$LN22@operator
$LN8@operator:

; 775  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xiosbase

; 249  :         return _Fmtfl;

	mov	eax, DWORD PTR [rcx+rsi+24]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream

; 775  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN91@operator
	npad	3
$LL4@operator:

; 776  :             for (; 0 < _Pad; --_Pad) { // pad on left

	test	rdi, rdi
	jle	SHORT $LN91@operator

; 777  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	jne	SHORT $LN2@operator

; 778  :                     _State |= ios_base::badbit; // insertion failed, quit

	lea	ebx, QWORD PTR [rax+5]

; 779  :                     break;

	jmp	SHORT $LN101@operator
$LN2@operator:

; 776  :             for (; 0 < _Pad; --_Pad) { // pad on left

	dec	rdi
	jmp	SHORT $LL4@operator
$LN91@operator:

; 780  :                 }
; 781  :             }
; 782  :         }
; 783  : 
; 784  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5@
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
	cmp	rax, 1
	jne	SHORT $LN100@operator
$LL96@operator:

; 785  :             _State |= ios_base::badbit;
; 786  :         }
; 787  : 
; 788  :         if (_State == ios_base::goodbit) {
; 789  :             for (; 0 < _Pad; --_Pad) { // pad on right

	test	rdi, rdi
	jle	SHORT $LN6@operator

; 790  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	je	SHORT $LN100@operator

; 785  :             _State |= ios_base::badbit;
; 786  :         }
; 787  : 
; 788  :         if (_State == ios_base::goodbit) {
; 789  :             for (; 0 < _Pad; --_Pad) { // pad on right

	dec	rdi
	jmp	SHORT $LL96@operator
$LN100@operator:

; 791  :                     _State |= ios_base::badbit; // insertion failed, quit
; 792  :                     break;
; 793  :                 }
; 794  :             }
; 795  :         }
; 796  : 
; 797  :         _Ostr.width(0);

	or	ebx, 4
$LN101@operator:
	mov	DWORD PTR _State$[rsp], ebx
$LN6@operator:
	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xiosbase

; 296  :         _Wide                      = _Newwidth;

	mov	QWORD PTR [rcx+rsi+40], 0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
	jmp	SHORT $LN22@operator
$LN23@operator:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xiosbase
	mov	rsi, QWORD PTR _Ostr$[rsp]
	mov	ebx, DWORD PTR _State$[rsp]
	mov	r14, QWORD PTR _Ok$[rsp]
$LN22@operator:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream

; 801  :     _Ostr.setstate(_State);

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	xor	r8d, r8d
	mov	edx, ebx
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1

; 112  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

	call	QWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 113  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 114  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 115  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 116  : 
; 117  :             if (_Zero_uncaught_exceptions) {

	test	al, al
	jne	SHORT $LN25@operator

; 118  :                 this->_Myostr._Osfx();

	mov	rcx, r14
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN25@operator:

; 78   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [r14]
	movsxd	rcx, DWORD PTR [rax+4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ios

; 79   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rcx+r14+72]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream

; 79   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN97@operator

; 80   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN97@operator:

; 802  :     return _Ostr;
; 803  : }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 80
_Val$dead$ = 88
_State$ = 88
?dtor$11@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$11
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$11@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 80
_Val$dead$ = 88
_State$ = 88
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 80
_Val$dead$ = 88
_State$ = 88
?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$17

; 798  :         _CATCH_IO_(ios_base, _Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
	mov	rdx, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rdx
	mov	r8b, 1
	mov	edx, 4
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	mov	rax, 0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$17@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$17
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Ostr$ = 48
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1005 :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1006 :     _Ostr.put(_Ostr.widen('\n'));

	mov	rax, QWORD PTR [rcx]
	mov	rbx, rcx
	mov	dl, 10
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
	movzx	edx, al
	mov	rcx, rbx
	call	QWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z

; 1007 :     _Ostr.flush();

	mov	rcx, rbx
	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1008 :     return _Ostr;

	mov	rax, rbx

; 1009 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Erase_head@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$ = 56
??$_Erase_head@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Erase_head<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >, COMDAT

; 752  :     void _Erase_head(_Alnode& _Al) noexcept {

$LN26:
	push	rbx
	sub	rsp, 32					; 00000020H

; 753  :         this->_Orphan_all();
; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	r8, QWORD PTR [rcx]
	mov	rbx, rcx
	mov	r8, QWORD PTR [r8+8]
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Erase_tree<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rbx]
	mov	edx, 56					; 00000038H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 756  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Erase_head@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Erase_head<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Erase_head@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$ = 56
??$_Erase_head@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_head<std::allocator<std::_Tree_node<int,void *> > >, COMDAT

; 752  :     void _Erase_head(_Alnode& _Al) noexcept {

$LN61:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 753  :         this->_Orphan_all();
; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rdx
	mov	rdi, rcx
	mov	rbx, QWORD PTR [rbx+8]

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	jne	SHORT $LN5@Erase_head
	npad	14
$LL4@Erase_head:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	r8, QWORD PTR [rbx+16]
	mov	rdx, rsi
	mov	rcx, rdi
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, rbx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rbx, QWORD PTR [rbx]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL4@Erase_head
$LN5@Erase_head:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, QWORD PTR [rdi]
	mov	edx, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 756  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Erase_head@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_head<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 282  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Move_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@00@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
??$_Move_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@00@Z PROC ; std::_Move_unchecked<std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *>, COMDAT

; 4788 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

$LN48:
	mov	QWORD PTR [rsp+16], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rsi, rdx
	mov	rdi, rcx

; 4800 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN39@Move_unche

; 4788 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

	xor	ebp, ebp
	npad	4
$LL4@Move_unche:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 735  :         if (this == _STD addressof(_Right)) {

	cmp	rbx, rdi
	je	SHORT $LN2@Move_unche

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN38@Move_unche

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN26@Move_unche

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN23@Move_unche

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN26@Move_unche:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx], rbp

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rbp

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rbp
$LN38@Move_unche:

; 412  :         _Myfirst = _Right._Myfirst;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rbx], rax

; 413  :         _Mylast  = _Right._Mylast;

	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+8], rax

; 414  :         _Myend   = _Right._Myend;

	mov	rax, QWORD PTR [rdi+16]
	mov	QWORD PTR [rbx+16], rax

; 415  : 
; 416  :         _Right._Myfirst = nullptr;

	mov	QWORD PTR [rdi], rbp

; 417  :         _Right._Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rbp

; 418  :         _Right._Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rbp
$LN2@Move_unche:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4800 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

	add	rbx, 24
	add	rdi, 24
	cmp	rdi, rsi
	jne	SHORT $LL4@Move_unche
$LN39@Move_unche:

; 4801 :         *_Dest = _STD move(*_First);
; 4802 :     }
; 4803 : 
; 4804 :     return _Dest;

	mov	rax, rbx

; 4805 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN23@Move_unche:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN45@Move_unche:
??$_Move_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@00@Z ENDP ; std::_Move_unchecked<std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@@Z PROC ; std::_Unfancy<std::vector<int,std::allocator<int> > >, COMDAT

; 294  :     return _Ptr;

	mov	rax, rcx

; 295  : }

	ret	0
??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@@Z ENDP ; std::_Unfancy<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >, COMDAT

; 682  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdx]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 682  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	rbx, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN9@destroy

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdx+16]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN25@destroy

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN22@destroy

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN25@destroy:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN9@destroy:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 688  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@destroy:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN35@destroy:
??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$move@AEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z PROC ; std::move<std::vector<int,std::allocator<int> > &>, COMDAT

; 1450 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1451 : }

	ret	0
??$move@AEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z ENDP ; std::move<std::vector<int,std::allocator<int> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$_Emplace_one_at_back@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAAEAV?$vector@HV?$allocator@H@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_one_at_back@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAAEAV?$vector@HV?$allocator@H@std@@@1@$$QEAV21@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_one_at_back<std::vector<int,std::allocator<int> > >, COMDAT

; 775  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 776  :         auto& _My_data   = _Mypair._Myval2;
; 777  :         pointer& _Mylast = _My_data._Mylast;
; 778  : 
; 779  :         if (_Mylast != _My_data._Myend) {

	mov	r10, QWORD PTR [rcx+8]
	mov	r9, rcx
	cmp	r10, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [rdx+8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r11d, r11d

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rdx+16]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r11
	mov	QWORD PTR [rdx+8], r11
	mov	QWORD PTR [rdx], r11
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10+8], rcx
	mov	QWORD PTR [r10], rax
	mov	QWORD PTR [r10+16], r8

; 803  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [r9+8]

; 804  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+24]
	mov	QWORD PTR [r9+8], rcx

; 784  :     }

	ret	0
$LN2@Emplace_on:

; 780  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 781  :         }
; 782  : 
; 783  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, r10
	jmp	??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_reallocate<std::vector<int,std::allocator<int> > >
??$_Emplace_one_at_back@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAAEAV?$vector@HV?$allocator@H@std@@@1@$$QEAV21@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_one_at_back<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@AEAV10@@Z PROC ; std::move<std::allocator<std::vector<int,std::allocator<int> > > &>, COMDAT

; 1450 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1451 : }

	ret	0
??$move@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<std::vector<int,std::allocator<int> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
;	COMDAT ??$exchange@PEAV?$vector@HV?$allocator@H@std@@@std@@$$T@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@AEAPEAV10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAV?$vector@HV?$allocator@H@std@@@std@@$$T@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@AEAPEAV10@$$QEA$$T@Z PROC ; std::exchange<std::vector<int,std::allocator<int> > *,std::nullptr_t>, COMDAT

; 755  :     // assign _New_val to _Val, return previous _Val
; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 758  :     return _Old_val;
; 759  : }

	ret	0
??$exchange@PEAV?$vector@HV?$allocator@H@std@@@std@@$$T@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@AEAPEAV10@$$QEA$$T@Z ENDP ; std::exchange<std::vector<int,std::allocator<int> > *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$?0V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@PEAV?$vector@HV?$allocator@H@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@$$QEAPEAV?$vector@HV?$allocator@H@std@@@1@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@PEAV?$vector@HV?$allocator@H@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@$$QEAPEAV?$vector@HV?$allocator@H@std@@@1@22@Z PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > >,std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *>, COMDAT

; 1497 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1497 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1497 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@PEAV?$vector@HV?$allocator@H@std@@@1@PEAV21@PEAV21@@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@$$QEAPEAV?$vector@HV?$allocator@H@std@@@1@22@Z ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > >,std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><>, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1492 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 282  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$_Unfancy@H@std@@YAPEAHPEAH@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@H@std@@YAPEAHPEAH@Z PROC			; std::_Unfancy<int>, COMDAT

; 294  :     return _Ptr;

	mov	rax, rcx

; 295  : }

	ret	0
??$_Unfancy@H@std@@YAPEAHPEAH@Z ENDP			; std::_Unfancy<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$dead$ = 16
??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::destroy<int>, COMDAT

; 683  : #if _HAS_CXX20
; 684  :         _STD destroy_at(_Ptr);
; 685  : #else // _HAS_CXX20
; 686  :         _Ptr->~_Uty();
; 687  : #endif // _HAS_CXX20
; 688  :     }

	ret	0
??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::destroy<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$dead$ = 56
_Val$dead$ = 64
??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<int,std::allocator<int> >::_Resize<std::_Value_init_tag>, COMDAT

; 1549 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

$LN29:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1550 :         // trim or append elements, provide strong guarantee
; 1551 :         auto& _Al           = _Getal();
; 1552 :         auto& _My_data      = _Mypair._Myval2;
; 1553 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1554 :         pointer& _Mylast    = _My_data._Mylast;
; 1555 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]
	mov	rdi, rcx
	mov	rdx, QWORD PTR [rcx]
	mov	rcx, rsi
	sub	rcx, rdx
	sar	rcx, 2

; 1556 :         if (_Newsize < _Oldsize) { // trim

	cmp	rcx, 51					; 00000033H
	jbe	SHORT $LN2@Resize

; 1557 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rdx+204]

; 1579 :             }
; 1580 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1581 :             _Orphan_range(_Oldlast, _Oldlast);
; 1582 :         }
; 1583 : 
; 1584 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1585 :     }

	mov	QWORD PTR [rdi+8], rax
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Resize:

; 1558 :             _Orphan_range(_Newlast, _Mylast);
; 1559 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1560 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1561 :             _Mylast = _Newlast;
; 1562 :             return;
; 1563 :         }
; 1564 : 
; 1565 :         if (_Newsize > _Oldsize) { // append

	jae	SHORT $LN3@Resize

; 1566 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

	mov	rax, QWORD PTR [rdi+16]
	sub	rax, rdx
	sar	rax, 2

; 1567 :             if (_Newsize > _Oldcapacity) { // reallocate

	cmp	rax, 51					; 00000033H
	jae	SHORT $LN4@Resize

; 1568 :                 _Resize_reallocate(_Newsize, _Val);

	mov	rcx, rdi

; 1579 :             }
; 1580 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1581 :             _Orphan_range(_Oldlast, _Oldlast);
; 1582 :         }
; 1583 : 
; 1584 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1585 :     }

	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1568 :                 _Resize_reallocate(_Newsize, _Val);

	jmp	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize_reallocate<std::_Value_init_tag>
$LN4@Resize:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 2010 :             _Zero_range(_PFirst, _PFirst + _Count);

	mov	eax, 51					; 00000033H
	mov	QWORD PTR [rsp+56], rbx
	sub	rax, rcx

; 1995 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	rcx, rsi

; 2010 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [rax*4]

; 1995 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	call	memset

; 2011 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rsi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1578 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

	mov	rbx, QWORD PTR [rsp+56]

; 1579 :             }
; 1580 :             _ASAN_VECTOR_RELEASE_GUARD;
; 1581 :             _Orphan_range(_Oldlast, _Oldlast);
; 1582 :         }
; 1583 : 
; 1584 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1585 :     }

	mov	QWORD PTR [rdi+8], rax
$LN3@Resize:
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<int,std::allocator<int> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Convert_size@_K_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K_K@std@@YA_K_K@Z PROC		; std::_Convert_size<unsigned __int64,unsigned __int64>, COMDAT

; 1082 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1083 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1084 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1085 : 
; 1086 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1087 :         if (_Len > (numeric_limits<_Size_type>::max)()) {
; 1088 :             _Xlength_error("size is too long for _Size_type");
; 1089 :         }
; 1090 :     }
; 1091 : 
; 1092 :     return static_cast<_Size_type>(_Len);

	mov	rax, rcx

; 1093 : }

	ret	0
??$_Convert_size@_K_K@std@@YA_K_K@Z ENDP		; std::_Convert_size<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z
_TEXT	SEGMENT
this$ = 80
_First$ = 88
_Newsize$ = 96
??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z PROC ; std::vector<int,std::allocator<int> >::_Assign_counted_range<int const *>, COMDAT

; 1379 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN68:
	push	rbx
	push	rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1380 :         // assign elements from counted range _First + [0, _Newsize)
; 1381 :         auto& _Al         = _Getal();
; 1382 :         auto& _My_data    = _Mypair._Myval2;
; 1383 :         pointer& _Myfirst = _My_data._Myfirst;
; 1384 :         pointer& _Mylast  = _My_data._Mylast;
; 1385 :         pointer& _Myend   = _My_data._Myend;
; 1386 : 
; 1387 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1388 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1389 : 
; 1390 :         _My_data._Orphan_all();
; 1391 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rdi, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rax, QWORD PTR [rcx+16]
	mov	r15, rdx
	sub	rax, rdi
	mov	r14, rcx
	sar	rax, 2

; 1392 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rax
	jbe	SHORT $LN5@Assign_cou

; 1393 :             _Clear_and_reserve_geometric(_Newsize);

	mov	rdx, r8
	call	?_Clear_and_reserve_geometric@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Clear_and_reserve_geometric

; 1394 :             if constexpr (_Nothrow_construct) {
; 1395 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdi, QWORD PTR [r14]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rbp*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	mov	rdx, r15
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1401 :             return;

	jmp	SHORT $LN65@Assign_cou
$LN5@Assign_cou:
	mov	QWORD PTR [rsp+104], rsi

; 1402 :         }
; 1403 : 
; 1404 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1405 :         if (_Newsize > _Oldsize) {

	mov	rcx, rdi
	sub	rsi, rdi
	sar	rsi, 2
	cmp	rbp, rsi
	jbe	SHORT $LN6@Assign_cou
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rsi*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1426 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	mov	rdi, QWORD PTR [r14+8]
	lea	rdx, QWORD PTR [rbx+r15]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	sub	rbp, rsi

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rbp*4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1432 :         } else {

	jmp	SHORT $LN64@Assign_cou
$LN6@Assign_cou:

; 1433 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbx, QWORD PTR [r8*4]
$LN64@Assign_cou:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
	mov	rsi, QWORD PTR [rsp+104]
$LN65@Assign_cou:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1439 :     }

	lea	rax, QWORD PTR [rbx+rdi]
	mov	QWORD PTR [r14+8], rax
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
??$_Assign_counted_range@PEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEBH_K@Z ENDP ; std::vector<int,std::allocator<int> >::_Assign_counted_range<int const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAHAEBH@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_one_at_back@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAHAEBH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_one_at_back<int const &>, COMDAT

; 774  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

	mov	r8, rdx

; 775  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 776  :         auto& _My_data   = _Mypair._Myval2;
; 777  :         pointer& _Mylast = _My_data._Mylast;
; 778  : 
; 779  :         if (_Mylast != _My_data._Myend) {

	mov	rdx, QWORD PTR [rcx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	je	SHORT $LN2@Emplace_on

; 795  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax

; 796  :         } else {
; 797  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 798  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 799  :             _ASAN_VECTOR_RELEASE_GUARD;
; 800  :         }
; 801  : 
; 802  :         _Orphan_range(_Mylast, _Mylast);
; 803  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 804  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+4]
	mov	QWORD PTR [rcx+8], rdx

; 784  :     }

	ret	0
$LN2@Emplace_on:

; 780  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 781  :         }
; 782  : 
; 783  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
??$_Emplace_one_at_back@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAHAEBH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_one_at_back<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$addressof@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z PROC ; std::addressof<std::vector<int,std::allocator<int> > >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 282  : }

	ret	0
??$addressof@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@H@std@@@std@@YAXAEAV?$allocator@H@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocma@V?$allocator@H@std@@@std@@YAXAEAV?$allocator@H@0@0@Z PROC ; std::_Pocma<std::allocator<int> >, COMDAT

; 1044 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1045 :         _Left = _STD move(_Right);
; 1046 :     }
; 1047 : }

	ret	0
??$_Pocma@V?$allocator@H@std@@@std@@YAXAEAV?$allocator@H@0@0@Z ENDP ; std::_Pocma<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@H@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@H@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1497 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@H@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
<_Val_0>$ = 96
<_Val_1>$ = 104
??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z PROC ; std::vector<int,std::allocator<int> >::_Construct_n<int * const &,int * const &>, COMDAT

; 2054 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN56:

; 2055 :         // Dispatches between the three sized constructions.
; 2056 :         // 1-arg -> value-construction, e.g. vector(5)
; 2057 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2058 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2059 :         auto& _Al       = _Getal();
; 2060 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2061 :         auto& _My_data  = _Mypair._Myval2;
; 2062 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2063 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN52@Construct_
	push	rbx
	push	rsi
	push	r14
	sub	rsp, 48					; 00000030H

; 2004 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 2054 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	r14, r9
	mov	rbx, r8
	mov	rsi, rcx

; 2004 :         if (_Newcapacity > max_size()) {

	cmp	rdx, rax
	ja	SHORT $LN54@Construct_
	mov	QWORD PTR [rsp+40], rdi

; 2006 :         }
; 2007 : 
; 2008 :         _Buy_raw(_Newcapacity);

	call	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4432 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

	mov	rdx, QWORD PTR [rbx]

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rbx, QWORD PTR [r14]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2072 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1819 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 2
	lea	rax, QWORD PTR [rdi+rbx*4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2072 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+40]
	mov	QWORD PTR [rsi+8], rax

; 2073 :             } else {
; 2074 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2075 :             }
; 2076 :             _ASAN_VECTOR_CREATE;
; 2077 :             _Guard._Target = nullptr;
; 2078 :         }
; 2079 : 
; 2080 :         _Proxy._Release();
; 2081 :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rsi
	pop	rbx
$LN52@Construct_:
	ret	0
$LN54@Construct_:

; 2005 :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
	int	3
$LN51@Construct_:
??$_Construct_n@AEBQEAHAEBQEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBQEAH1@Z ENDP ; std::vector<int,std::allocator<int> >::_Construct_n<int * const &,int * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@H@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@H@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1497 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@H@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$_Construct_n@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBH@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
<_Val_0>$ = 64
??$_Construct_n@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBH@Z PROC ; std::vector<int,std::allocator<int> >::_Construct_n<int const &>, COMDAT

; 2054 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

$LN63:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 2008 :         _Buy_raw(_Newcapacity);

	mov	esi, 50					; 00000032H

; 2054 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	rdi, r8

; 2008 :         _Buy_raw(_Newcapacity);

	mov	edx, esi

; 2054 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	mov	r14, rcx

; 2008 :         _Buy_raw(_Newcapacity);

	call	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4930 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	cmp	DWORD PTR [rdi], 0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2070 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);

	mov	rbx, QWORD PTR [r14]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4930 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	jne	SHORT $LL13@Construct_

; 4919 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	xor	edx, edx
	mov	r8d, 200				; 000000c8H
	mov	rcx, rbx
	call	memset
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1947 :                 return _First + _Count;

	add	rbx, 200				; 000000c8H
	jmp	SHORT $LN60@Construct_
	npad	8
$LL13@Construct_:

; 1777 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rbx+4], eax
	add	rbx, 8

; 1778 :         ++_Last;

	sub	rsi, 2

; 1953 :     for (; 0 < _Count; --_Count) {

	jne	SHORT $LL13@Construct_
$LN60@Construct_:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2081 :     }

	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	mov	QWORD PTR [r14+8], rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Construct_n@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBH@Z ENDP ; std::vector<int,std::allocator<int> >::_Construct_n<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1492 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 65   :     // return smaller of _Left and _Right
; 66   :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rdx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 67   : }

	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 282  : }

	ret	0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<int> > >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 282  : }

	ret	0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPEAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 1059 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

$LN52:

; 1063 :         for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN49@Destroy_ra
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rsp+56], rsi
	mov	rdi, rdx
	xor	esi, esi
	mov	rbx, rcx
	npad	4
$LL4@Destroy_ra:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN14@Destroy_ra

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN30@Destroy_ra

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN27@Destroy_ra

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN30@Destroy_ra:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx], rsi

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rsi

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rsi
$LN14@Destroy_ra:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1063 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rdi
	jne	SHORT $LL4@Destroy_ra

; 1064 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1065 :         }
; 1066 :     }
; 1067 : }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
$LN49@Destroy_ra:
	ret	0
$LN27@Destroy_ra:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN48@Destroy_ra:
??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPEAHQEAHAEAV?$allocator@H@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPEAHQEAHAEAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 1060 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1061 :     using _Ty = typename _Alloc::value_type;
; 1062 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1063 :         for (; _First != _Last; ++_First) {
; 1064 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1065 :         }
; 1066 :     }
; 1067 : }

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPEAHQEAHAEAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16,0>, COMDAT

; 242  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN18:
	sub	rsp, 40					; 00000028H

; 243  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 244  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 245  :     if (_STD is_constant_evaluated()) {
; 246  :         ::operator delete(_Ptr);
; 247  :     } else
; 248  : #endif // _HAS_CXX20
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN13@Deallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN10@Deallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN13@Deallocate:

; 256  :     }
; 257  : }

	add	rsp, 40					; 00000028H

; 252  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 253  :         }
; 254  : #endif // defined(_M_IX86) || defined(_M_X64)
; 255  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN10@Deallocate:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN15@Deallocate:
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::__autoclassinit2, COMDAT
	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	ret	0
?__autoclassinit2@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAX_K@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??_G?$vector@HV?$allocator@H@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$vector@HV?$allocator@H@std@@@std@@QEAAPEAXI@Z PROC ; std::vector<int,std::allocator<int> >::`scalar deleting destructor', COMDAT
$LN35:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN7@scalar

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN23@scalar

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN20@scalar

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN23@scalar:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN7@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN20@scalar:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN32@scalar:
??_G?$vector@HV?$allocator@H@std@@@std@@QEAAPEAXI@Z ENDP ; std::vector<int,std::allocator<int> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >, COMDAT

; 33   :     _CONSTEXPR20 ~_Tidy_guard() {

$LN33:
	push	rbx
	sub	rsp, 32					; 00000020H

; 34   :         if (_Target) {

	mov	rbx, QWORD PTR [rcx]
	test	rbx, rbx
	je	SHORT $LN5@Tidy_guard
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN5@Tidy_guard

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN21@Tidy_guard

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN18@Tidy_guard

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN21@Tidy_guard:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN5@Tidy_guard:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 37   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@Tidy_guard:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN30@Tidy_guard:
??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Unwrapped@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unwrapped@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >::_Unwrapped, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 251  :         return _Tree_unchecked_const_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));

	mov	rax, rdx

; 252  :     }

	ret	0
?_Unwrapped@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$dead$ = 56
??0?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >, COMDAT

; 882  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

$LN41:
	push	rbx
	sub	rsp, 32					; 00000020H

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	xor	eax, eax

; 882  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

	mov	rbx, rcx

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 77   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+56]
	call	??2@YAPEAX_K@Z				; operator new
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1941 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR [rbx], rax

; 883  :         _Alloc_sentinel_and_proxy();
; 884  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAA@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBAPEAV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBAPEAV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Unwrapped, COMDAT

; 342  :         return _Unfancy(this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 343  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEBAPEAV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Unwrapped@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unwrapped@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::_Unwrapped, COMDAT

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 251  :         return _Tree_unchecked_const_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));

	mov	rax, rdx

; 252  :     }

	ret	0
?_Unwrapped@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QEBA?AV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$dead$ = 56
??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >, COMDAT

; 882  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

$LN41:
	push	rbx
	sub	rsp, 32					; 00000020H

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	xor	eax, eax

; 882  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

	mov	rbx, rcx

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 77   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+32]
	call	??2@YAPEAX_K@Z				; operator new
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1941 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR [rbx], rax

; 883  :         _Alloc_sentinel_and_proxy();
; 884  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAA@AEBU?$less@H@1@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@00@Z PROC ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@00@Z ENDP ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >, COMDAT

; 935  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z PROC ; std::vector<int,std::allocator<int> >::_Buy_nonzero, COMDAT

; 1993 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

$LN7:
	sub	rsp, 40					; 00000028H

; 1994 :         // allocate array with _Newcapacity elements
; 1995 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1996 :         auto& _My_data    = _Mypair._Myval2;
; 1997 :         pointer& _Myfirst = _My_data._Myfirst;
; 1998 :         pointer& _Mylast  = _My_data._Mylast;
; 1999 :         pointer& _Myend   = _My_data._Myend;
; 2000 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2001 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2002 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2003 : 
; 2004 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN6@Buy_nonzer

; 2009 :     }

	add	rsp, 40					; 00000028H

; 2006 :         }
; 2007 : 
; 2008 :         _Buy_raw(_Newcapacity);

	jmp	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
$LN6@Buy_nonzer:

; 2005 :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
	int	3
$LN4@Buy_nonzer:
?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ENDP ; std::vector<int,std::allocator<int> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
?_Clear_and_reserve_geometric@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z PROC ; std::vector<int,std::allocator<int> >::_Clear_and_reserve_geometric, COMDAT

; 1644 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN38:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1645 :         auto& _Al         = _Getal();
; 1646 :         auto& _My_data    = _Mypair._Myval2;
; 1647 :         pointer& _Myfirst = _My_data._Myfirst;
; 1648 :         pointer& _Mylast  = _My_data._Mylast;
; 1649 :         pointer& _Myend   = _My_data._Myend;
; 1650 : 
; 1651 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1652 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1653 :         _Check_all_orphaned();
; 1654 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1655 : 
; 1656 :         if (_Newsize > max_size()) {

	mov	rbx, 4611686018427387903		; 3fffffffffffffffH
	mov	r8, rdx
	mov	rdi, rcx
	cmp	rdx, rbx
	ja	$LN36@Clear_and_

; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx]

; 1964 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbx

; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
	sar	rdx, 2

; 1964 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, rdx
	shr	r9, 1
	sub	rax, r9
	cmp	rdx, rax
	ja	SHORT $LN7@Clear_and_

; 1965 :             return _Max; // geometric growth would overflow
; 1966 :         }
; 1967 : 
; 1968 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rbx, QWORD PTR [r9+rdx]

; 1969 : 
; 1970 :         if (_Geometric < _Newsize) {

	cmp	rbx, r8
	cmovb	rbx, r8
$LN7@Clear_and_:

; 1658 :         }
; 1659 : 
; 1660 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1661 : 
; 1662 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN3@Clear_and_
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx*4]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN25@Clear_and_

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN22@Clear_and_

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN25@Clear_and_:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1667 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rdi], rax

; 1668 :             _Mylast  = nullptr;

	mov	QWORD PTR [rdi+8], rax

; 1669 :             _Myend   = nullptr;

	mov	QWORD PTR [rdi+16], rax
$LN3@Clear_and_:

; 1670 :         }
; 1671 : 
; 1672 :         _Buy_raw(_Newcapacity);

	mov	rdx, rbx
	mov	rcx, rdi

; 1673 :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 1670 :         }
; 1671 : 
; 1672 :         _Buy_raw(_Newcapacity);

	jmp	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
$LN22@Clear_and_:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN36@Clear_and_:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1657 :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
	int	3
$LN34@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ENDP ; std::vector<int,std::allocator<int> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Alloc_sentinel_and_proxy, COMDAT

; 1937 :     void _Alloc_sentinel_and_proxy() {

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1938 :         const auto _Scary = _Get_scary();
; 1939 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1940 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 1941 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR [rbx], rax

; 1942 :         _Proxy._Release();
; 1943 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Alloc_sentinel_and_proxy, COMDAT

; 1937 :     void _Alloc_sentinel_and_proxy() {

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 1938 :         const auto _Scary = _Get_scary();
; 1939 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1940 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 1941 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

	mov	QWORD PTR [rbx], rax

; 1942 :         _Proxy._Release();
; 1943 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 2135 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2136 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z PROC ; std::vector<int,std::allocator<int> >::_Buy_raw, COMDAT

; 1977 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN39:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1977 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

	mov	rdi, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	cmp	rdx, rax
	ja	SHORT $LN30@Buy_raw

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	lea	rbx, QWORD PTR [rdx*4]

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN10@Buy_raw

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN30@Buy_raw

; 77   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN19@Buy_raw

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN19@Buy_raw:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN10@Buy_raw:

; 234  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN11@Buy_raw

; 77   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 235  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN11@Buy_raw:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	eax, eax
$LN9@Buy_raw:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1988 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1989 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1990 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 1991 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN30@Buy_raw:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN37@Buy_raw:
?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ENDP ; std::vector<int,std::allocator<int> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@AEBA_K_K@Z PROC ; std::vector<int,std::allocator<int> >::_Calculate_growth, COMDAT

; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1960 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1961 :         const size_type _Oldcapacity = capacity();
; 1962 :         const auto _Max              = max_size();
; 1963 : 
; 1964 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]

; 1960 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1961 :         const size_type _Oldcapacity = capacity();
; 1962 :         const auto _Max              = max_size();
; 1963 : 
; 1964 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rcx, rax

; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sar	r8, 2

; 1960 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1961 :         const size_type _Oldcapacity = capacity();
; 1962 :         const auto _Max              = max_size();
; 1963 : 
; 1964 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r9, r8
	shr	r9, 1
	sub	rcx, r9
	cmp	r8, rcx
	ja	SHORT $LN1@Calculate_

; 1965 :             return _Max; // geometric growth would overflow
; 1966 :         }
; 1967 : 
; 1968 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r9+r8]

; 1969 : 
; 1970 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	cmovb	rax, rdx
$LN1@Calculate_:

; 1971 :             return _Newsize; // geometric growth would be insufficient
; 1972 :         }
; 1973 : 
; 1974 :         return _Geometric; // geometric growth is sufficient
; 1975 :     }

	ret	0
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<int,std::allocator<int> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT

; 1871 :         return (_STD min)(

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 1872 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1873 :     }

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT

; 1876 :         auto& _My_data = _Mypair._Myval2;
; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 1878 :     }

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QEBA_KXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA_KAEBV?$allocator@H@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA_KAEBV?$allocator@H@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::max_size, COMDAT

; 691  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 692  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA_KAEBV?$allocator@H@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QEAAPEAH_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@H@std@@QEAAPEAH_K@Z PROC		; std::allocator<int>::allocate, COMDAT

; 949  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN31:
	sub	rsp, 40					; 00000028H

; 60   :         if (_Count > _Max_possible) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN27@allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rdx*4]

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN27@allocate

; 77   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN17@allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 950  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 951  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 952  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN17@allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@allocate:

; 234  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN9@allocate

; 950  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 951  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 952  :     }

	add	rsp, 40					; 00000028H

; 77   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN9@allocate:

; 238  :     return nullptr;

	xor	eax, eax

; 950  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 951  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 952  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN27@allocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN29@allocate:
?allocate@?$allocator@H@std@@QEAAPEAH_K@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$move@AEAH@std@@YA$$QEAHAEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAH@std@@YA$$QEAHAEAH@Z PROC			; std::move<int &>, COMDAT

; 1450 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1451 : }

	ret	0
??$move@AEAH@std@@YA$$QEAHAEAH@Z ENDP			; std::move<int &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z
_TEXT	SEGMENT
_Loc$1$ = 32
$T9 = 32
$T2 = 48
_Loc$10 = 64
$T1 = 88
this$ = 160
_First$ = 168
_Last$ = 176
??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >, COMDAT

; 1266 :     void insert(_Iter _First, _Iter _Last) {

$LN98:

; 1259 :         for (; _First != _Last; ++_First) {

	cmp	rdx, r8
	je	$LN95@insert
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H

; 1266 :     void insert(_Iter _First, _Iter _Last) {

	mov	rbx, r8
	mov	rdi, rdx
	mov	r14, rcx

; 1258 :         const auto _Myhead = _Get_scary()->_Myhead;

	mov	rbp, QWORD PTR [rcx]
	mov	r15, 576460752303423487			; 07ffffffffffffffH
	xor	r12d, r12d
	npad	8
$LL6@insert:

; 1044 :             _Loc = _Find_hint(_Hint, _In_place_key_extractor::_Extract(_Vals...));

	mov	r9, rdi
	mov	r8, rbp
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, r14
	call	??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_hint<int>
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR _Loc$1$[rsp], xmm0
	movsd	xmm0, QWORD PTR [rax+16]
	movsd	QWORD PTR _Loc$10[rsp+16], xmm0

; 1045 :             if (_Loc._Duplicate) {

	cmp	BYTE PTR _Loc$10[rsp+16], 0
	jne	SHORT $LN4@insert

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

	cmp	QWORD PTR [r14+8], r15
	je	SHORT $LN89@insert

; 1050 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

	mov	rsi, QWORD PTR [r14]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR $T2[rsp], r14

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T2[rsp+8], r12

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r8, rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [r8+28], eax

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [r8], rsi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [r8+8], rsi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [r8+16], rsi

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [r8+24], 0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T2[rsp+8], r12
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1066 :         return _Scary->_Insert_node(_Loc._Location, _Inserted);

	movups	xmm0, XMMWORD PTR _Loc$1$[rsp]
	movaps	XMMWORD PTR $T9[rsp], xmm0
	lea	rdx, QWORD PTR $T9[rsp]
	mov	rcx, r14
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@U?$_Tree_id@PEAU?$_Tree_node@HPEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Insert_node
$LN4@insert:

; 1259 :         for (; _First != _Last; ++_First) {

	add	rdi, 4
	cmp	rdi, rbx
	jne	$LL6@insert

; 1267 :         _Adl_verify_range(_First, _Last);
; 1268 :         _Insert_range_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last));
; 1269 :     }

	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
$LN95@insert:
	ret	0
$LN89@insert:

; 1630 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN94@insert:
??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Loc$1$ = 32
$T9 = 32
$T2 = 48
_Loc$10 = 64
$T1 = 88
this$ = 160
_First$ = 168
_Last$ = 176
?dtor$2@?0???$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z@4HA PROC ; `std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
?dtor$2@?0???$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@0@Z@4HA ENDP ; `std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > &>, COMDAT

; 980  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 981  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 982  :         return _It + 0;
; 983  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 984  :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rax, QWORD PTR [rcx]

; 985  :     } else {
; 986  :         return static_cast<_Iter&&>(_It);
; 987  :     }
; 988  : }

	ret	0
??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >, COMDAT

; 957  :     // check that [_First, _Last) forms an iterator range
; 958  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 959  :         _Verify_range(_First, _Last);
; 960  :     }
; 961  : }

	ret	0
??$_Adl_verify_range@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> >, COMDAT

; 1229 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1230 :         return _Last - _First; // assume the iterator will do debug checking
; 1231 :     } else {
; 1232 :         _Adl_verify_range(_First, _Last);
; 1233 :         auto _UFirst             = _Get_unwrapped(_First);
; 1234 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1235 :         _Iter_diff_t<_InIt> _Off = 0;

	xor	r10d, r10d
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 97   :         return _Ptr == _Right._Ptr;

	cmp	rcx, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1236 :         for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN36@distance
	npad	8
$LL14@distance:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rcx+16]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1237 :             ++_Off;

	inc	r10
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN13@distance

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN12@distance
$LL11@distance:
	cmp	rcx, QWORD PTR [rax+16]
	jne	SHORT $LN12@distance

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rcx, rax
	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL11@distance
$LN12@distance:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rcx, rax

; 58   :         } else {

	jmp	SHORT $LN29@distance
$LN13@distance:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	r9, QWORD PTR [rax]

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rcx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	cmp	BYTE PTR [r9+25], 0
	jne	SHORT $LN29@distance
	npad	4
$LL17@distance:
	mov	r8, QWORD PTR [r9]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rcx, r9
	mov	r9, r8
	cmp	BYTE PTR [r8+25], 0
	je	SHORT $LL17@distance
$LN29@distance:

; 97   :         return _Ptr == _Right._Ptr;

	cmp	rcx, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1236 :         for (; _UFirst != _ULast; ++_UFirst) {

	jne	SHORT $LL14@distance
$LN36@distance:

; 1238 :         }
; 1239 : 
; 1240 :         return _Off;
; 1241 :     }
; 1242 : }

	mov	rax, r10
	ret	0
??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@@Z PROC ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> &>, COMDAT

; 980  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 981  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 982  :         return _It + 0;
; 983  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 984  :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 985  :     } else {
; 986  :         return static_cast<_Iter&&>(_It);

	mov	rax, rcx

; 987  :     }
; 988  : }

	ret	0
??$_Get_unwrapped@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@@Z ENDP ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@_K@Z
_TEXT	SEGMENT
__$ArrayPad$ = 32
this$ = 64
_First$ = 72
_Newsize$ = 80
??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@_K@Z PROC ; std::vector<int,std::allocator<int> >::_Assign_counted_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> >, COMDAT

; 1379 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN169:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1380 :         // assign elements from counted range _First + [0, _Newsize)
; 1381 :         auto& _Al         = _Getal();
; 1382 :         auto& _My_data    = _Mypair._Myval2;
; 1383 :         pointer& _Myfirst = _My_data._Myfirst;
; 1384 :         pointer& _Mylast  = _My_data._Mylast;
; 1385 :         pointer& _Myend   = _My_data._Myend;
; 1386 : 
; 1387 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1388 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1389 : 
; 1390 :         _My_data._Orphan_all();
; 1391 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	r9, QWORD PTR [rcx]
	mov	rdi, r8
	mov	rax, QWORD PTR [rcx+16]
	mov	rbx, rdx
	sub	rax, r9
	mov	rsi, rcx
	sar	rax, 2

; 1392 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rax
	jbe	$LN5@Assign_cou

; 1393 :             _Clear_and_reserve_geometric(_Newsize);

	mov	rdx, r8
	call	?_Clear_and_reserve_geometric@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Clear_and_reserve_geometric
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1766 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	rdx, QWORD PTR [rsi]

; 1862 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdi, rdi
	je	$LN78@Assign_cou
$LL52@Assign_cou:

; 1777 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [rbx+28]
	mov	DWORD PTR [rdx], eax

; 1778 :         ++_Last;

	add	rdx, 4
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rbx+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN57@Assign_cou

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN141@Assign_cou
	npad	1
$LL55@Assign_cou:
	cmp	rbx, QWORD PTR [rax+16]
	jne	SHORT $LN141@Assign_cou

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rbx, rax
	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL55@Assign_cou
$LN141@Assign_cou:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rbx, rax

; 58   :         } else {

	jmp	SHORT $LN62@Assign_cou
$LN57@Assign_cou:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rax]

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rbx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN62@Assign_cou
	npad	12
$LL61@Assign_cou:
	mov	rax, QWORD PTR [rcx]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rcx
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL61@Assign_cou
$LN62@Assign_cou:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1862 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	sub	rdi, 1
	jne	SHORT $LL52@Assign_cou
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1401 :             return;

	jmp	$LN78@Assign_cou
$LN5@Assign_cou:

; 1402 :         }
; 1403 : 
; 1404 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rdx, QWORD PTR [rcx+8]
	mov	r8, rdx
	sub	r8, r9
	sar	r8, 2

; 1405 :         if (_Newsize > _Oldsize) {

	cmp	rdi, r8
	jbe	$LN6@Assign_cou

; 1419 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	cmp	r9, rdx
	je	SHORT $LN3@Assign_cou
	npad	10
$LL41@Assign_cou:

; 1420 :                     *_Mid = *_First;

	mov	eax, DWORD PTR [rbx+28]
	mov	DWORD PTR [r9], eax
	add	r9, 4
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rbx+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN40@Assign_cou

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN142@Assign_cou
	npad	2
$LL38@Assign_cou:
	cmp	rbx, QWORD PTR [rax+16]
	jne	SHORT $LN142@Assign_cou

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rbx, rax
	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL38@Assign_cou
$LN142@Assign_cou:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rbx, rax

; 58   :         } else {

	jmp	SHORT $LN45@Assign_cou
$LN40@Assign_cou:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rax]

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rbx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN45@Assign_cou
	npad	12
$LL44@Assign_cou:
	mov	rax, QWORD PTR [rcx]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rcx
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL44@Assign_cou
$LN45@Assign_cou:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1419 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	mov	rdx, QWORD PTR [rsi+8]
	cmp	r9, rdx
	jne	SHORT $LL41@Assign_cou
$LN3@Assign_cou:

; 1421 :                 }
; 1422 :             }
; 1423 : 
; 1424 :             if constexpr (_Nothrow_construct) {
; 1425 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1426 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	rdi, r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1862 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	je	$LN78@Assign_cou
$LL13@Assign_cou:

; 1777 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [rbx+28]
	mov	DWORD PTR [rdx], eax

; 1778 :         ++_Last;

	add	rdx, 4
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rbx+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN18@Assign_cou

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN143@Assign_cou
	npad	2
$LL16@Assign_cou:
	cmp	rbx, QWORD PTR [rax+16]
	jne	SHORT $LN143@Assign_cou

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rbx, rax
	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL16@Assign_cou
$LN143@Assign_cou:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rbx, rax

; 58   :         } else {

	jmp	SHORT $LN23@Assign_cou
$LN18@Assign_cou:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rax]

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rbx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN23@Assign_cou
	npad	12
$LL22@Assign_cou:
	mov	rax, QWORD PTR [rcx]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rcx
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL22@Assign_cou
$LN23@Assign_cou:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1862 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	sub	rdi, 1
	jne	SHORT $LL13@Assign_cou
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1432 :         } else {

	jmp	SHORT $LN78@Assign_cou
$LN6@Assign_cou:

; 1433 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rdx, QWORD PTR [r9+rdi*4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4474 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdi, rdi
	je	SHORT $LN78@Assign_cou
$LL79@Assign_cou:

; 4475 :         *_Dest = *_First;

	mov	eax, DWORD PTR [rbx+28]
	mov	DWORD PTR [r9], eax
	lea	r9, QWORD PTR [r9+4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rbx+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN84@Assign_cou

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN144@Assign_cou
	npad	2
$LL82@Assign_cou:
	cmp	rbx, QWORD PTR [rax+16]
	jne	SHORT $LN144@Assign_cou

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rbx, rax
	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL82@Assign_cou
$LN144@Assign_cou:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rbx, rax

; 58   :         } else {

	jmp	SHORT $LN89@Assign_cou
$LN84@Assign_cou:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rax]

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rbx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN89@Assign_cou
	npad	12
$LL88@Assign_cou:
	mov	rax, QWORD PTR [rcx]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rcx
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL88@Assign_cou
$LN89@Assign_cou:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4474 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	sub	rdi, 1
	jne	SHORT $LL79@Assign_cou
$LN78@Assign_cou:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1439 :     }

	mov	QWORD PTR [rsi+8], rdx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@_K@Z ENDP ; std::vector<int,std::allocator<int> >::_Assign_counted_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
$T2 = 32
_Loc$1$ = 48
$T10 = 48
_Loc$11 = 64
$T1 = 88
this$ = 160
_First$ = 168
_Last$ = 176
??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >, COMDAT

; 1266 :     void insert(_Iter _First, _Iter _Last) {

$LN131:

; 1259 :         for (; _First != _Last; ++_First) {

	cmp	rdx, r8
	je	$LN128@insert
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H

; 1266 :     void insert(_Iter _First, _Iter _Last) {

	mov	rbx, r8
	mov	rdi, rdx
	mov	r15, rcx

; 1258 :         const auto _Myhead = _Get_scary()->_Myhead;

	mov	rbp, QWORD PTR [rcx]
	mov	r12, 329406144173384850			; 0492492492492492H
	xor	r13d, r13d
	npad	2
$LL6@insert:

; 1044 :             _Loc = _Find_hint(_Hint, _In_place_key_extractor::_Extract(_Vals...));

	mov	r9, rdi
	mov	r8, rbp
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, r15
	call	??$_Find_hint@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Find_hint<std::vector<int,std::allocator<int> > >
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR _Loc$1$[rsp], xmm0
	movsd	xmm0, QWORD PTR [rax+16]
	movsd	QWORD PTR _Loc$11[rsp+16], xmm0

; 1045 :             if (_Loc._Duplicate) {

	cmp	BYTE PTR _Loc$11[rsp+16], 0
	jne	SHORT $LN4@insert

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

	cmp	QWORD PTR [r15+8], r12
	je	$LN122@insert

; 1050 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

	mov	rsi, QWORD PTR [r15]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR $T2[rsp], r15

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T2[rsp+8], r13

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r14, rax
	mov	QWORD PTR $T2[rsp+8], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rcx, QWORD PTR [rax+32]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, rdi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [r14], rsi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [r14+8], rsi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [r14+16], rsi

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [r14+24], 0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T2[rsp+8], r13
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1066 :         return _Scary->_Insert_node(_Loc._Location, _Inserted);

	movups	xmm0, XMMWORD PTR _Loc$1$[rsp]
	movaps	XMMWORD PTR $T10[rsp], xmm0
	mov	r8, r14
	lea	rdx, QWORD PTR $T10[rsp]
	mov	rcx, r15
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Insert_node
$LN4@insert:

; 1259 :         for (; _First != _Last; ++_First) {

	add	rdi, 24
	cmp	rdi, rbx
	jne	$LL6@insert

; 1267 :         _Adl_verify_range(_First, _Last);
; 1268 :         _Insert_range_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last));
; 1269 :     }

	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
$LN128@insert:
	ret	0
$LN122@insert:

; 1630 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN127@insert:
??$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
_Loc$1$ = 48
$T10 = 48
_Loc$11 = 64
$T1 = 88
this$ = 160
_First$ = 168
_Last$ = 176
?dtor$2@?0???$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z@4HA PROC ; `std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
?dtor$2@?0???$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z@4HA ENDP ; `std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
_Loc$1$ = 48
$T10 = 48
_Loc$11 = 64
$T1 = 88
this$ = 160
_First$ = 168
_Last$ = 176
?dtor$1@?0???$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z@4HA PROC ; `std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >'::`1'::dtor$1
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0???$insert@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEAAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@1@0@Z@4HA ENDP ; `std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::insert<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > > >, COMDAT

; 957  :     // check that [_First, _Last) forms an iterator range
; 958  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 959  :         _Verify_range(_First, _Last);
; 960  :     }
; 961  : }

	ret	0
??$_Adl_verify_range@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> >, COMDAT

; 1229 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1230 :         return _Last - _First; // assume the iterator will do debug checking
; 1231 :     } else {
; 1232 :         _Adl_verify_range(_First, _Last);
; 1233 :         auto _UFirst             = _Get_unwrapped(_First);
; 1234 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1235 :         _Iter_diff_t<_InIt> _Off = 0;

	xor	r10d, r10d
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 97   :         return _Ptr == _Right._Ptr;

	cmp	rcx, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1236 :         for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN36@distance
	npad	8
$LL14@distance:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rcx+16]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1237 :             ++_Off;

	inc	r10
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN13@distance

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN12@distance
$LL11@distance:
	cmp	rcx, QWORD PTR [rax+16]
	jne	SHORT $LN12@distance

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rcx, rax
	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL11@distance
$LN12@distance:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rcx, rax

; 58   :         } else {

	jmp	SHORT $LN29@distance
$LN13@distance:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	r9, QWORD PTR [rax]

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rcx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	cmp	BYTE PTR [r9+25], 0
	jne	SHORT $LN29@distance
	npad	4
$LL17@distance:
	mov	r8, QWORD PTR [r9]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rcx, r9
	mov	r9, r8
	cmp	BYTE PTR [r8+25], 0
	je	SHORT $LL17@distance
$LN29@distance:

; 97   :         return _Ptr == _Right._Ptr;

	cmp	rcx, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 1236 :         for (; _UFirst != _ULast; ++_UFirst) {

	jne	SHORT $LL14@distance
$LN36@distance:

; 1238 :         }
; 1239 : 
; 1240 :         return _Off;
; 1241 :     }
; 1242 : }

	mov	rax, r10
	ret	0
??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA_JV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z PROC ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> &>, COMDAT

; 980  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 981  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 982  :         return _It + 0;
; 983  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 984  :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 985  :     } else {
; 986  :         return static_cast<_Iter&&>(_It);

	mov	rax, rcx

; 987  :     }
; 988  : }

	ret	0
??$_Get_unwrapped@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z ENDP ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@_K@Z
_TEXT	SEGMENT
this$ = 64
_First$ = 72
_Newsize$ = 80
??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@_K@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Assign_counted_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> >, COMDAT

; 1379 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN80:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 1380 :         // assign elements from counted range _First + [0, _Newsize)
; 1381 :         auto& _Al         = _Getal();
; 1382 :         auto& _My_data    = _Mypair._Myval2;
; 1383 :         pointer& _Myfirst = _My_data._Myfirst;
; 1384 :         pointer& _Mylast  = _My_data._Mylast;
; 1385 :         pointer& _Myend   = _My_data._Myend;
; 1386 : 
; 1387 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1388 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1389 : 
; 1390 :         _My_data._Orphan_all();
; 1391 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rdi, QWORD PTR [rcx]
	mov	rbx, rdx
	mov	r14, rcx
	mov	r9, 3074457345618258603			; 2aaaaaaaaaaaaaabH
	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, r9
	sub	rcx, rdi
	mov	rsi, r8
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1392 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rdx
	jbe	SHORT $LN5@Assign_cou

; 1393 :             _Clear_and_reserve_geometric(_Newsize);

	mov	rdx, r8
	mov	rcx, r14
	call	?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Clear_and_reserve_geometric

; 1394 :             if constexpr (_Nothrow_construct) {
; 1395 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1396 :                 _ASAN_VECTOR_CREATE;
; 1397 :             } else {
; 1398 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1399 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	r8, QWORD PTR [r14]
	mov	r9, r14
	mov	rdx, rsi
	mov	rcx, rbx
	call	??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_copy_n<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>,std::allocator<std::vector<int,std::allocator<int> > > >

; 1436 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1437 :             _Mylast = _Newlast;
; 1438 :         }
; 1439 :     }

	mov	QWORD PTR [r14+8], rax
	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN5@Assign_cou:

; 1400 :             }
; 1401 :             return;
; 1402 :         }
; 1403 : 
; 1404 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	r8, QWORD PTR [r14+8]
	mov	rax, r9
	mov	QWORD PTR [rsp+72], rbp
	mov	rcx, r8
	sub	rcx, rdi
	imul	rcx
	mov	rbp, rdx
	sar	rbp, 2
	mov	rax, rbp
	shr	rax, 63					; 0000003fH
	add	rbp, rax

; 1405 :         if (_Newsize > _Oldsize) {

	cmp	rsi, rbp
	jbe	$LN6@Assign_cou

; 1419 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	cmp	rdi, r8
	je	SHORT $LN3@Assign_cou
	npad	11
$LL14@Assign_cou:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 43   :         return _Ptr->_Myval;

	lea	rdx, QWORD PTR [rbx+32]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1420 :                     *_Mid = *_First;

	mov	rcx, rdi
	call	??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<int,std::allocator<int> >::operator=
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rbx+16]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1419 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	add	rdi, 24
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN13@Assign_cou

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN63@Assign_cou
$LL11@Assign_cou:
	cmp	rbx, QWORD PTR [rax+16]
	jne	SHORT $LN63@Assign_cou

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rbx, rax
	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL11@Assign_cou
$LN63@Assign_cou:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rbx, rax

; 58   :         } else {

	jmp	SHORT $LN18@Assign_cou
$LN13@Assign_cou:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rax]

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rbx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN18@Assign_cou
	npad	8
$LL17@Assign_cou:
	mov	rax, QWORD PTR [rcx]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rcx
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL17@Assign_cou
$LN18@Assign_cou:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1419 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

	mov	r8, QWORD PTR [r14+8]
	cmp	rdi, r8
	jne	SHORT $LL14@Assign_cou
$LN3@Assign_cou:

; 1421 :                 }
; 1422 :             }
; 1423 : 
; 1424 :             if constexpr (_Nothrow_construct) {
; 1425 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1426 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1427 :             } else {
; 1428 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1429 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	sub	rsi, rbp
	mov	r9, r14
	mov	rdx, rsi
	mov	rcx, rbx
	call	??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_copy_n<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>,std::allocator<std::vector<int,std::allocator<int> > > >

; 1436 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1437 :             _Mylast = _Newlast;
; 1438 :         }
; 1439 :     }

	mov	QWORD PTR [r14+8], rax
	jmp	$LN77@Assign_cou
$LN6@Assign_cou:

; 1430 :                 _ASAN_VECTOR_RELEASE_GUARD;
; 1431 :             }
; 1432 :         } else {
; 1433 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rax, QWORD PTR [rsi+rsi*2]
	lea	rbp, QWORD PTR [rdi+rax*8]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4474 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rsi, rsi
	je	SHORT $LN24@Assign_cou
	npad	1
$LL25@Assign_cou:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 43   :         return _Ptr->_Myval;

	lea	rdx, QWORD PTR [rbx+32]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4475 :         *_Dest = *_First;

	mov	rcx, rdi
	call	??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<int,std::allocator<int> >::operator=
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rbx+16]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4474 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rdi, 24
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN30@Assign_cou

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN64@Assign_cou
$LL28@Assign_cou:
	cmp	rbx, QWORD PTR [rax+16]
	jne	SHORT $LN64@Assign_cou

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rbx, rax
	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL28@Assign_cou
$LN64@Assign_cou:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rbx, rax

; 58   :         } else {

	jmp	SHORT $LN35@Assign_cou
$LN30@Assign_cou:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rax]

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rbx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN35@Assign_cou
	npad	8
$LL34@Assign_cou:
	mov	rax, QWORD PTR [rcx]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rcx
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL34@Assign_cou
$LN35@Assign_cou:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4474 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	sub	rsi, 1
	jne	SHORT $LL25@Assign_cou
$LN24@Assign_cou:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1435 :             _Destroy_range(_Newlast, _Mylast, _Al);

	mov	rdx, QWORD PTR [r14+8]
	mov	rcx, rbp
	call	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >

; 1436 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1437 :             _Mylast = _Newlast;
; 1438 :         }
; 1439 :     }

	mov	QWORD PTR [r14+8], rbp
$LN77@Assign_cou:
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
??$_Assign_counted_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@_K@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Assign_counted_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >, COMDAT

; 957  :     // check that [_First, _Last) forms an iterator range
; 958  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 959  :         _Verify_range(_First, _Last);
; 960  :     }
; 961  : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Val$ = 64
??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z PROC ; std::_Find_unchecked<std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > >, COMDAT

; 5704 : _NODISCARD _CONSTEXPR20 _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val) {

$LN43:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rsi, rdx
	mov	rbx, rcx

; 5739 :     for (; _First != _Last; ++_First) {

	cmp	rcx, rdx
	je	SHORT $LN35@Find_unche
	mov	QWORD PTR [rsp+48], rbp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1867 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rbp, QWORD PTR [r8]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5739 :     for (; _First != _Last; ++_First) {

	mov	QWORD PTR [rsp+56], rdi
	mov	rdi, QWORD PTR [r8+8]
	sub	rdi, rbp
	sar	rdi, 2
	npad	3
$LL4@Find_unche:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1867 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rbx]
	mov	r8, QWORD PTR [rbx+8]
	sub	r8, rcx
	mov	rax, r8
	sar	rax, 2

; 2220 :     if (_Left.size() != _Right.size()) {

	cmp	rax, rdi
	jne	SHORT $LN33@Find_unche
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5149 :     return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));

	mov	rdx, rbp
	call	memcmp

; 5172 :             return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;

	test	eax, eax

; 5740 :         if (*_First == _Val) {

	je	SHORT $LN36@Find_unche
$LN33@Find_unche:

; 5739 :     for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rsi
	jne	SHORT $LL4@Find_unche
$LN36@Find_unche:
	mov	rbp, QWORD PTR [rsp+48]

; 5741 :             break;
; 5742 :         }
; 5743 :     }
; 5744 : 
; 5745 :     return _First;

	mov	rax, rbx
	mov	rdi, QWORD PTR [rsp+56]

; 5746 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN35@Find_unche:
	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rcx
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
??$_Find_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@QEAV10@AEBV10@@Z ENDP ; std::_Find_unchecked<std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@PEAV?$vector@HV?$allocator@H@std@@@2@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@$$QEAPEAV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@PEAV?$vector@HV?$allocator@H@std@@@2@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@$$QEAPEAV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >,std::vector<int,std::allocator<int> > *>, COMDAT

; 1080 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1081 :         _It._Seek_to(_STD forward<_UIter>(_UIt));

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 1082 :     } else {
; 1083 :         _It = _STD forward<_UIter>(_UIt);
; 1084 :     }
; 1085 : }

	ret	0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@PEAV?$vector@HV?$allocator@H@std@@@2@@std@@YAXAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@0@$$QEAPEAV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >,std::vector<int,std::allocator<int> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z
_TEXT	SEGMENT
this$ = 80
_Al$ = 88
_Rootnode$ = 96
??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Erase_tree<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >, COMDAT

; 744  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

$LN76:
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [r8+25], 0
	mov	rdi, r8
	mov	rbp, rdx
	mov	rsi, rcx
	jne	$LN66@Erase_tree
	mov	QWORD PTR [rsp+40], rbx
	mov	QWORD PTR [rsp+32], r14
	xor	r14d, r14d
	npad	7
$LL2@Erase_tree:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	r8, QWORD PTR [rdi+16]
	mov	rdx, rbp
	mov	rcx, rsi
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Erase_tree<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rbx, rdi

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdi, QWORD PTR [rdi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+32]
	test	rcx, rcx
	je	SHORT $LN17@Erase_tree

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+48]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN33@Erase_tree

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, rax

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rcx, -8
	cmp	rcx, 31
	ja	SHORT $LN30@Erase_tree

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, rax
$LN33@Erase_tree:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	mov	QWORD PTR [rbx+32], r14

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+40], r14

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+48], r14
$LN17@Erase_tree:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rdi+25], r14b
	je	SHORT $LL2@Erase_tree
	mov	rbx, QWORD PTR [rsp+40]
	mov	r14, QWORD PTR [rsp+32]
$LN66@Erase_tree:

; 749  :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN30@Erase_tree:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN73@Erase_tree:
??$_Erase_tree@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Erase_tree<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$_Freenode0@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_Tree_node<std::vector<int,std::allocator<int> >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >, COMDAT

; 371  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

	mov	rcx, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode0@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_Tree_node<std::vector<int,std::allocator<int> >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@@Z
_TEXT	SEGMENT
this$ = 64
_Al$ = 72
_Rootnode$ = 80
??$_Erase_tree@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >, COMDAT

; 744  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

$LN38:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [r8+25], 0
	mov	rbx, r8
	mov	rsi, rdx
	mov	rdi, rcx
	jne	SHORT $LN3@Erase_tree
	npad	8
$LL2@Erase_tree:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

	mov	r8, QWORD PTR [rbx+16]
	mov	rdx, rsi
	mov	rcx, rdi
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, rbx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rbx, QWORD PTR [rbx]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [rbx+25], 0
	je	SHORT $LL2@Erase_tree
$LN3@Erase_tree:

; 747  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));
; 748  :         }
; 749  :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
??$_Erase_tree@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$_Freenode0@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU01@@Z PROC ; std::_Tree_node<int,void *>::_Freenode0<std::allocator<std::_Tree_node<int,void *> > >, COMDAT

; 371  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

	mov	rcx, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode0@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU01@@Z ENDP ; std::_Tree_node<int,void *>::_Freenode0<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z PROC ; std::forward<std::vector<int,std::allocator<int> > >, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z ENDP ; std::forward<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAAEAV?$vector@HV?$allocator@H@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAAEAV?$vector@HV?$allocator@H@std@@@1@$$QEAV21@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back_with_unused_capacity<std::vector<int,std::allocator<int> > >, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 265  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	r10, QWORD PTR [rcx+8]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 787  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	mov	r11, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	ecx, ecx
	mov	r9, QWORD PTR [rdx+16]

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], rcx
	mov	QWORD PTR [rdx+8], rcx
	mov	QWORD PTR [rdx], rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10], rax
	mov	QWORD PTR [r10+8], r8
	mov	QWORD PTR [r10+16], r9

; 788  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 789  :         auto& _My_data   = _Mypair._Myval2;
; 790  :         pointer& _Mylast = _My_data._Mylast;
; 791  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 792  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 793  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 794  :             _ASAN_VECTOR_MODIFY(1);
; 795  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);
; 796  :         } else {
; 797  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 798  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 799  :             _ASAN_VECTOR_RELEASE_GUARD;
; 800  :         }
; 801  : 
; 802  :         _Orphan_range(_Mylast, _Mylast);
; 803  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [r11+8]

; 804  :         ++_Mylast;

	lea	rcx, QWORD PTR [rax+24]
	mov	QWORD PTR [r11+8], rcx

; 805  : 
; 806  :         return _Result;
; 807  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAAEAV?$vector@HV?$allocator@H@std@@@1@$$QEAV21@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back_with_unused_capacity<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z
_TEXT	SEGMENT
this$ = 96
_Whereptr$ = 104
<_Val_0>$ = 112
??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_reallocate<std::vector<int,std::allocator<int> > >, COMDAT

; 810  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN204:
	push	rsi
	push	rdi
	push	r12
	push	r15
	sub	rsp, 56					; 00000038H

; 811  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 812  :         _Alty& _Al        = _Getal();
; 813  :         auto& _My_data    = _Mypair._Myval2;
; 814  :         pointer& _Myfirst = _My_data._Myfirst;
; 815  :         pointer& _Mylast  = _My_data._Mylast;
; 816  : 
; 817  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 818  : 
; 819  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	r9, rdx
	mov	rdi, rdx
	mov	r10, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	rsi, rcx
	mov	r15, r8
	mov	rax, r10
	mov	r8, QWORD PTR [rcx]

; 820  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rcx, QWORD PTR [rcx+8]
	sub	r9, r8
	imul	r9
	sub	rcx, r8

; 821  : 
; 822  :         if (_Oldsize == max_size()) {

	mov	r9, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	mov	r12, rdx
	sar	r12, 2
	mov	rax, r12
	shr	rax, 63					; 0000003fH
	add	r12, rax
	mov	rax, r10
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
	cmp	rdx, r9
	je	$LN202@Emplace_re

; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rsi+16]
	mov	rax, r10
	sub	rcx, r8
	mov	QWORD PTR [rsp+120], rbx
	mov	QWORD PTR [rsp+48], rbp

; 824  :         }
; 825  : 
; 826  :         const size_type _Newsize     = _Oldsize + 1;

	lea	rbp, QWORD PTR [rdx+1]

; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	imul	rcx
	mov	QWORD PTR [rsp+40], r13
	sar	rdx, 2
	mov	rax, rdx
	mov	QWORD PTR [rsp+32], r14
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1964 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r9
	mov	rcx, rdx
	shr	rcx, 1
	sub	rax, rcx
	cmp	rdx, rax
	ja	$LN179@Emplace_re

; 1965 :             return _Max; // geometric growth would overflow
; 1966 :         }
; 1967 : 
; 1968 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rcx+rdx]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	mov	rcx, rbp
	cmp	rax, rbp
	cmovae	rcx, rax
	cmp	rcx, r9
	ja	$LN179@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rcx+rcx*2]

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	xor	r13d, r13d

; 65   :     return _Count * _Ty_size;

	lea	r14, QWORD PTR [rax*8]

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	r14, 4096				; 00001000H
	jb	SHORT $LN24@Emplace_re

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [r14+39]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	rcx, r14
	jbe	$LN179@Emplace_re

; 77   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN72@Emplace_re

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	r14, r14
	je	SHORT $LN25@Emplace_re

; 77   :         return ::operator new(_Bytes);

	mov	rcx, r14
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 235  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	mov	rbx, r13
$LN23@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r15]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 834  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	rax, QWORD PTR [r12+r12*2]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [r15+16]
	mov	rdx, QWORD PTR [r15+8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r15+16], r13
	mov	QWORD PTR [r15+8], r13
	mov	QWORD PTR [r15], r13
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 834  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	r15, QWORD PTR [rbx+rax*8]

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r15], rcx

; 835  :         _Constructed_first = _Newvec + _Whereoff;
; 836  : 
; 837  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rbx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r15+8], rdx
	mov	QWORD PTR [r15+16], r8

; 835  :         _Constructed_first = _Newvec + _Whereoff;
; 836  : 
; 837  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	r10, QWORD PTR [rsi+8]
	mov	rax, QWORD PTR [rsi]
	cmp	rdi, r10
	jne	SHORT $LN4@Emplace_re
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1920 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, r10
	je	$LN139@Emplace_re
	npad	14
$LL82@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [rax+16]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rax]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rax+16], r13
	mov	QWORD PTR [rax+8], r13
	mov	QWORD PTR [rax], r13
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1920 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rax, 24
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1778 :         ++_Last;

	add	rcx, 24

; 1920 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, r10
	jne	SHORT $LL82@Emplace_re
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 843  :         } else { // provide basic guarantee

	jmp	$LN139@Emplace_re
$LN4@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1920 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, rdi
	je	SHORT $LN110@Emplace_re
	npad	8
$LL111@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [rax+16]
	mov	r8, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rax]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rax+16], r13
	mov	QWORD PTR [rax+8], r13
	mov	QWORD PTR [rax], r13
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1920 :     for (; _UFirst != _ULast; ++_UFirst) {

	add	rax, 24
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1778 :         ++_Last;

	add	rcx, 24

; 1920 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rax, rdi
	jne	SHORT $LL111@Emplace_re
$LN110@Emplace_re:

; 1772 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rcx
	call	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >

; 1907 :     const auto _ULast = _Get_unwrapped(_Last);

	mov	r10, QWORD PTR [rsi+8]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 846  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	lea	rcx, QWORD PTR [r15+24]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1920 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rdi, r10
	je	SHORT $LN139@Emplace_re

; 1772 :         _Destroy_range(_First, _Last, _Al);

	mov	r9, rdi
	mov	rax, r15
	sub	r9, r15
	add	r9, -16
	add	r9, rcx
	sub	rax, rdi
	lea	r11, QWORD PTR [rax+24]
	lea	rdi, QWORD PTR [rax+32]
	npad	2
$LL140@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [r9-8]
	mov	r8, QWORD PTR [r9+8]
	mov	rdx, QWORD PTR [r9]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r9+8], r13
	mov	QWORD PTR [r9], r13
	mov	QWORD PTR [r9-8], r13
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1778 :         ++_Last;

	add	rcx, 24
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r11+r9], rdx
	mov	QWORD PTR [rdi+r9], r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1778 :         ++_Last;

	lea	r9, QWORD PTR [r9+24]

; 1920 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rax, QWORD PTR [r9-8]
	cmp	rax, r10
	jne	SHORT $LL140@Emplace_re
$LN139@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 846  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	rdx, rcx
	call	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >

; 2021 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rsi]
	test	rcx, rcx
	je	SHORT $LN65@Emplace_re

; 2022 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdx, QWORD PTR [rsi+8]
	call	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >

; 2023 :             _ASAN_VECTOR_REMOVE;
; 2024 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	r8, QWORD PTR [rsi]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	rcx, QWORD PTR [rsi+16]
	sub	rcx, r8
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx+rdx*2]
	shl	rdx, 3

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN75@Emplace_re

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [r8-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	r8, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [r8-8]
	cmp	rax, 31
	ja	SHORT $LN72@Emplace_re

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	r8, rcx
$LN75@Emplace_re:

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN65@Emplace_re:
	mov	r13, QWORD PTR [rsp+40]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2028 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [rbp*2]
	add	rcx, rbp
	mov	QWORD PTR [rsi], rbx
	mov	rbp, QWORD PTR [rsp+48]

; 847  :         }
; 848  :         _CATCH_ALL
; 849  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 850  :         _Al.deallocate(_Newvec, _Newcapacity);
; 851  :         _RERAISE;
; 852  :         _CATCH_END
; 853  : 
; 854  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 855  :         return _Newvec + _Whereoff;

	mov	rax, r15

; 2028 :         _Mylast  = _Newvec + _Newsize;

	lea	rdx, QWORD PTR [rbx+rcx*8]

; 2029 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [r14+rbx]
	mov	QWORD PTR [rsi+8], rdx
	mov	rbx, QWORD PTR [rsp+120]
	mov	r14, QWORD PTR [rsp+32]
	mov	QWORD PTR [rsi+16], rcx

; 856  :     }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN72@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN202@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 823  :             _Xlength();

	call	?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
	int	3
$LN179@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN200@Emplace_re:
??$_Emplace_reallocate@V?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@$$QEAV21@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_reallocate<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@PEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QEAPEAV?$vector@HV?$allocator@H@std@@@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QEAPEAV?$vector@HV?$allocator@H@std@@@0@AEAPEAV10@@Z PROC ; std::forward<std::vector<int,std::allocator<int> > *>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@PEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YA$$QEAPEAV?$vector@HV?$allocator@H@std@@@0@AEAPEAV10@@Z ENDP ; std::forward<std::vector<int,std::allocator<int> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$dead$ = 56
_Val$dead$ = 64
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<int,std::allocator<int> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT

; 1509 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

$LN111:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 1510 :         if (_Newsize > max_size()) {
; 1511 :             _Xlength();
; 1512 :         }
; 1513 : 
; 1514 :         auto& _Al         = _Getal();
; 1515 :         auto& _My_data    = _Mypair._Myval2;
; 1516 :         pointer& _Myfirst = _My_data._Myfirst;
; 1517 :         pointer& _Mylast  = _My_data._Mylast;
; 1518 : 
; 1519 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rbp, QWORD PTR [rcx+8]
	mov	rdi, rcx
	sub	rbp, QWORD PTR [rcx]

; 1964 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	r8, 4611686018427387903			; 3fffffffffffffffH

; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]

; 1964 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r8

; 1510 :         if (_Newsize > max_size()) {
; 1511 :             _Xlength();
; 1512 :         }
; 1513 : 
; 1514 :         auto& _Al         = _Getal();
; 1515 :         auto& _My_data    = _Mypair._Myval2;
; 1516 :         pointer& _Myfirst = _My_data._Myfirst;
; 1517 :         pointer& _Mylast  = _My_data._Mylast;
; 1518 : 
; 1519 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

	sar	rbp, 2

; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	rcx, QWORD PTR [rdi]
	sar	rcx, 2

; 1964 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rcx, rax
	ja	$LN97@Resize_rea

; 1965 :             return _Max; // geometric growth would overflow
; 1966 :         }
; 1967 : 
; 1968 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	add	rcx, rdx

; 1969 : 
; 1970 :         if (_Geometric < _Newsize) {

	cmp	rcx, 51					; 00000033H
	jae	SHORT $LN11@Resize_rea

; 1971 :             return _Newsize; // geometric growth would be insufficient

	mov	ecx, 204				; 000000ccH
	mov	esi, ecx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 77   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 235  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN21@Resize_rea
$LN11@Resize_rea:

; 60   :         if (_Count > _Max_possible) {

	cmp	rcx, r8
	ja	$LN97@Resize_rea

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	lea	rcx, QWORD PTR [rcx*4]
	mov	rsi, rcx

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN22@Resize_rea

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN97@Resize_rea

; 77   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN88@Resize_rea

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN21@Resize_rea
$LN22@Resize_rea:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN23@Resize_rea

; 77   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 235  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN21@Resize_rea
$LN23@Resize_rea:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	ebx, ebx
$LN21@Resize_rea:

; 1995 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8d, 51					; 00000033H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1523 :         const pointer _Appended_first = _Newvec + _Oldsize;

	lea	rcx, QWORD PTR [rbx+rbp*4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1995 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	sub	r8, rbp
	xor	edx, edx
	shl	r8, 2
	call	memset
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4432 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

	mov	rdx, QWORD PTR [rdi]

; 4433 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4434 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	sub	r8, rdx
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2021 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN81@Resize_rea

; 2022 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2023 :             _ASAN_VECTOR_REMOVE;
; 2024 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN91@Resize_rea

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN88@Resize_rea

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN91@Resize_rea:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN81@Resize_rea:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1546 :     }

	mov	rbp, QWORD PTR [rsp+64]

; 2028 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rbx+204]
	mov	QWORD PTR [rdi], rbx
	mov	QWORD PTR [rdi+8], rax

; 2029 :         _Myend   = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rsi+rbx]

; 1546 :     }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+72]

; 2029 :         _Myend   = _Newvec + _Newcapacity;

	mov	QWORD PTR [rdi+16], rax

; 1546 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN88@Resize_rea:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN97@Resize_rea:

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN108@Resize_rea:
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<int,std::allocator<int> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@H@std@@@std@@YAPEAHPEAH_KAEAV?$allocator@H@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@V?$allocator@H@std@@@std@@YAPEAHPEAH_KAEAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<int> >, COMDAT

; 2001 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

$LN20:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2002 :     // value-initialize _Count objects to raw _First, using _Al
; 2003 :     using _Ptrty = typename _Alloc::value_type*;
; 2004 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2005 : #if _HAS_CXX20
; 2006 :         if (!_STD is_constant_evaluated())
; 2007 : #endif // _HAS_CXX20
; 2008 :         {
; 2009 :             auto _PFirst = _Unfancy(_First);
; 2010 :             _Zero_range(_PFirst, _PFirst + _Count);

	lea	rbx, QWORD PTR [rdx*4]
	mov	rdi, rcx

; 1995 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rbx
	xor	edx, edx
	call	memset

; 2011 :             return _First + _Count;

	lea	rax, QWORD PTR [rbx+rdi]

; 2012 :         }
; 2013 :     }
; 2014 : 
; 2015 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2016 :     for (; 0 < _Count; --_Count) {
; 2017 :         _Backout._Emplace_back();
; 2018 :     }
; 2019 : 
; 2020 :     return _Backout._Release();
; 2021 : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_value_construct_n@V?$allocator@H@std@@@std@@YAPEAHPEAH_KAEAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$move@AEAPEBH@std@@YA$$QEAPEBHAEAPEBH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEBH@std@@YA$$QEAPEBHAEAPEBH@Z PROC		; std::move<int const * &>, COMDAT

; 1450 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1451 : }

	ret	0
??$move@AEAPEBH@std@@YA$$QEAPEBHAEAPEBH@Z ENDP		; std::move<int const * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped@PEBH@std@@YA?A_T$$QEAPEBH@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEBH@std@@YA?A_T$$QEAPEBH@Z PROC	; std::_Get_unwrapped<int const *>, COMDAT

; 980  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 981  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 982  :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 983  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 984  :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 985  :     } else {
; 986  :         return static_cast<_Iter&&>(_It);
; 987  :     }
; 988  : }

	ret	0
??$_Get_unwrapped@PEBH@std@@YA?A_T$$QEAPEBH@Z ENDP	; std::_Get_unwrapped<int const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEBHV?$allocator@H@std@@@std@@YAPEAHPEBH_KPEAHAEAV?$allocator@H@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy_n@PEBHV?$allocator@H@std@@@std@@YAPEAHPEBH_KPEAHAEAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy_n<int const *,std::allocator<int> >, COMDAT

; 1839 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN20:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rdx*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1856 :             _Dest += _Count;

	lea	rax, QWORD PTR [rbx+rdi]

; 1857 :             return _Dest;
; 1858 :         }
; 1859 :     }
; 1860 : 
; 1861 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1862 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {
; 1863 :         _Backout._Emplace_back(*_UFirst);
; 1864 :     }
; 1865 : 
; 1866 :     return _Backout._Release();
; 1867 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEBHV?$allocator@H@std@@@std@@YAPEAHPEBH_KPEAHAEAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy_n<int const *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Copy_memmove_n@PEBHPEAH@std@@YAPEAHPEBH_KPEAH@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_memmove_n@PEBHPEAH@std@@YAPEAHPEBH_KPEAH@Z PROC ; std::_Copy_memmove_n<int const *,int *>, COMDAT

; 4445 : _OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Count, _OutCtgIt _Dest) {

$LN6:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rdx*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4437 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4438 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4447 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4448 :         return _Result;
; 4449 :     } else { // _Result is unused so the compiler can optimize it away
; 4450 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Count);
; 4451 :     }
; 4452 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove_n@PEBHPEAH@std@@YAPEAHPEBH_KPEAH@Z ENDP ; std::_Copy_memmove_n<int const *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEBH_KPEAH@std@@YAPEAHPEBH_KPEAH@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEBH_KPEAH@std@@YAPEAHPEBH_KPEAH@Z PROC ; std::_Copy_n_unchecked4<int const *,unsigned __int64,int *>, COMDAT

; 4458 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN11:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rdx*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4437 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4438 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4459 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4460 :     // note: has callers outside the copy family
; 4461 : #ifdef __cpp_lib_concepts
; 4462 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4463 : #endif // __cpp_lib_concepts
; 4464 : 
; 4465 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4466 : #if _HAS_CXX20
; 4467 :         if (!_STD is_constant_evaluated())
; 4468 : #endif // _HAS_CXX20
; 4469 :         {
; 4470 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
; 4471 :         }
; 4472 :     }
; 4473 : 
; 4474 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {
; 4475 :         *_Dest = *_First;
; 4476 :     }
; 4477 : 
; 4478 :     return _Dest;
; 4479 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_n_unchecked4@PEBH_KPEAH@std@@YAPEAHPEBH_KPEAH@Z ENDP ; std::_Copy_n_unchecked4<int const *,unsigned __int64,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@AEBH@std@@YAAEBHAEBH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBH@std@@YAAEBHAEBH@Z PROC			; std::forward<int const &>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@AEBH@std@@YAAEBHAEBH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAHAEBH@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAHAEBH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int const &>, COMDAT

; 788  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 789  :         auto& _My_data   = _Mypair._Myval2;
; 790  :         pointer& _Mylast = _My_data._Mylast;
; 791  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 792  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 793  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 794  :             _ASAN_VECTOR_MODIFY(1);
; 795  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx+8]
	mov	DWORD PTR [r8], eax

; 796  :         } else {
; 797  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 798  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 799  :             _ASAN_VECTOR_RELEASE_GUARD;
; 800  :         }
; 801  : 
; 802  :         _Orphan_range(_Mylast, _Mylast);
; 803  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 804  :         ++_Mylast;

	lea	rdx, QWORD PTR [rax+4]
	mov	QWORD PTR [rcx+8], rdx

; 805  : 
; 806  :         return _Result;
; 807  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAAEAHAEBH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z
_TEXT	SEGMENT
this$ = 80
_Whereptr$ = 88
<_Val_0>$ = 96
??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>, COMDAT

; 810  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN133:
	push	rbp
	push	rdi
	push	r12
	push	r14
	sub	rsp, 40					; 00000028H

; 811  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 812  :         _Alty& _Al        = _Getal();
; 813  :         auto& _My_data    = _Mypair._Myval2;
; 814  :         pointer& _Myfirst = _My_data._Myfirst;
; 815  :         pointer& _Mylast  = _My_data._Mylast;
; 816  : 
; 817  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 818  : 
; 819  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
; 820  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	mov	rbp, rdx
	mov	rdx, QWORD PTR [rcx]
	mov	r14, rbp
	sub	r14, rdx
	sub	rax, rdx
	mov	r12, r8
	sar	r14, 2
	sar	rax, 2

; 821  : 
; 822  :         if (_Oldsize == max_size()) {

	mov	r8, 4611686018427387903			; 3fffffffffffffffH
	mov	rdi, rcx
	cmp	rax, r8
	je	$LN131@Emplace_re

; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rdx
	mov	QWORD PTR [rsp+96], rbx
	sar	rcx, 2
	mov	QWORD PTR [rsp+104], rsi

; 1964 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rdx, rcx
	shr	rdx, 1
	mov	QWORD PTR [rsp+32], r15

; 824  :         }
; 825  : 
; 826  :         const size_type _Newsize     = _Oldsize + 1;

	lea	r15, QWORD PTR [rax+1]

; 1964 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, r8
	sub	rax, rdx
	cmp	rcx, rax
	ja	$LN112@Emplace_re

; 1965 :             return _Max; // geometric growth would overflow
; 1966 :         }
; 1967 : 
; 1968 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	mov	rsi, r15
	cmp	rax, r15
	cmovae	rsi, rax
	cmp	rsi, r8
	ja	$LN112@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	lea	rsi, QWORD PTR [rsi*4]

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rsi, 4096				; 00001000H
	jb	SHORT $LN24@Emplace_re

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rsi+39]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rsi
	jbe	$LN112@Emplace_re

; 77   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN58@Emplace_re

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	rsi, rsi
	je	SHORT $LN25@Emplace_re

; 77   :         return ::operator new(_Bytes);

	mov	rcx, rsi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 235  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	ebx, ebx
$LN23@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 834  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR [r12]
	lea	r14, QWORD PTR [rbx+r14*4]
	mov	DWORD PTR [r14], eax

; 835  :         _Constructed_first = _Newvec + _Whereoff;
; 836  : 
; 837  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rcx, rbx
	mov	r8, QWORD PTR [rdi+8]
	mov	rdx, QWORD PTR [rdi]
	cmp	rbp, r8
	jne	SHORT $LN4@Emplace_re
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 843  :         } else { // provide basic guarantee

	jmp	SHORT $LN129@Emplace_re
$LN4@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, rbp
	sub	r8, rdx

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, QWORD PTR [rdi+8]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 846  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	lea	rcx, QWORD PTR [r14+4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rbp

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rbp
$LN129@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 846  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	call	memmove

; 2021 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN51@Emplace_re

; 2022 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2023 :             _ASAN_VECTOR_REMOVE;
; 2024 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN61@Emplace_re

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN58@Emplace_re

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN61@Emplace_re:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN51@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2028 :         _Mylast  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [rbx+r15*4]
	mov	QWORD PTR [rdi], rbx
	mov	r15, QWORD PTR [rsp+32]

; 847  :         }
; 848  :         _CATCH_ALL
; 849  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 850  :         _Al.deallocate(_Newvec, _Newcapacity);
; 851  :         _RERAISE;
; 852  :         _CATCH_END
; 853  : 
; 854  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 855  :         return _Newvec + _Whereoff;

	mov	rax, r14

; 2028 :         _Mylast  = _Newvec + _Newsize;

	mov	QWORD PTR [rdi+8], rcx

; 2029 :         _Myend   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [rsi+rbx]
	mov	rsi, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+96]
	mov	QWORD PTR [rdi+16], rcx

; 856  :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
$LN58@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN131@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 823  :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
	int	3
$LN112@Emplace_re:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN128@Emplace_re:
??$_Emplace_reallocate@AEBH@?$vector@HV?$allocator@H@std@@@std@@AEAAPEAHQEAHAEBH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@H@std@@@std@@YA$$QEAV?$allocator@H@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@H@std@@@std@@YA$$QEAV?$allocator@H@0@AEAV10@@Z PROC ; std::move<std::allocator<int> &>, COMDAT

; 1450 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1451 : }

	ret	0
??$move@AEAV?$allocator@H@std@@@std@@YA$$QEAV?$allocator@H@0@AEAV10@@Z ENDP ; std::move<std::allocator<int> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@V?$allocator@H@std@@@std@@YA$$QEAV?$allocator@H@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@H@std@@@std@@YA$$QEAV?$allocator@H@0@AEAV10@@Z PROC ; std::forward<std::allocator<int> >, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@V?$allocator@H@std@@@std@@YA$$QEAV?$allocator@H@0@AEAV10@@Z ENDP ; std::forward<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@AEBQEAH@std@@YAAEBQEAHAEBQEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAH@std@@YAAEBQEAHAEBQEAH@Z PROC		; std::forward<int * const &>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@AEBQEAH@std@@YAAEBQEAHAEBQEAH@Z ENDP		; std::forward<int * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped@PEAH@std@@YA?A_T$$QEAPEAH@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@PEAH@std@@YA?A_T$$QEAPEAH@Z PROC	; std::_Get_unwrapped<int *>, COMDAT

; 980  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 981  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 982  :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 983  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 984  :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 985  :     } else {
; 986  :         return static_cast<_Iter&&>(_It);
; 987  :     }
; 988  : }

	ret	0
??$_Get_unwrapped@PEAH@std@@YA?A_T$$QEAPEAH@Z ENDP	; std::_Get_unwrapped<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAHPEAHV?$allocator@H@std@@@std@@YAPEAHPEAH00AEAV?$allocator@H@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy@PEAHPEAHV?$allocator@H@std@@@std@@YAPEAHPEAH00AEAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 1794 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN18:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1819 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 2
	lea	rax, QWORD PTR [rdi+rbx*4]

; 1820 :             } else {
; 1821 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1822 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1823 :                 _Dest += _Count;
; 1824 :             }
; 1825 :             return _Dest;
; 1826 :         }
; 1827 :     }
; 1828 : 
; 1829 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1830 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1831 :         _Backout._Emplace_back(*_UFirst);
; 1832 :     }
; 1833 : 
; 1834 :     return _Backout._Release();
; 1835 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy@PEAHPEAHV?$allocator@H@std@@@std@@YAPEAHPEAH00AEAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_To_address@PEAH@std@@YA?A_PAEBQEAH@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAH@std@@YA?A_PAEBQEAH@Z PROC		; std::_To_address<int *>, COMDAT

; 4307 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4308 :     return _Val;

	mov	rax, QWORD PTR [rcx]

; 4309 : }

	ret	0
??$_To_address@PEAH@std@@YA?A_PAEBQEAH@Z ENDP		; std::_To_address<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@H@std@@@std@@YAAEBV?$allocator@H@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@H@std@@@std@@YAAEBV?$allocator@H@0@AEBV10@@Z PROC ; std::forward<std::allocator<int> const &>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@AEBV?$allocator@H@std@@@std@@YAAEBV?$allocator@H@0@AEBV10@@Z ENDP ; std::forward<std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@V?$allocator@H@std@@@std@@YAPEAHPEAH_KAEBHAEAV?$allocator@H@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$dead$ = 56
_Val$ = 64
_Al$dead$ = 72
??$_Uninitialized_fill_n@V?$allocator@H@std@@@std@@YAPEAHPEAH_KAEBHAEAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_fill_n<std::allocator<int> >, COMDAT

; 1929 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al) {

$LN29:
	push	rbx
	sub	rsp, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4930 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	cmp	DWORD PTR [r8], 0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1929 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al) {

	mov	rbx, rcx
	mov	ecx, 50					; 00000032H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4930 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	jne	SHORT $LL5@Uninitiali

; 4919 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	xor	edx, edx
	mov	r8d, 200				; 000000c8H
	mov	rcx, rbx
	call	memset
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1947 :                 return _First + _Count;

	lea	rax, QWORD PTR [rbx+200]

; 1958 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LL5@Uninitiali:

; 1777 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rbx], eax
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rbx+4], eax
	add	rbx, 8

; 1778 :         ++_Last;

	sub	rcx, 2

; 1948 :             }
; 1949 :         }
; 1950 :     }
; 1951 : 
; 1952 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1953 :     for (; 0 < _Count; --_Count) {

	jne	SHORT $LL5@Uninitiali

; 1954 :         _Backout._Emplace_back(_Val);
; 1955 :     }
; 1956 : 
; 1957 :     return _Backout._Release();

	mov	rax, rbx

; 1958 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninitialized_fill_n@V?$allocator@H@std@@@std@@YAPEAHPEAH_KAEBHAEAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_fill_n<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$?0AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$dead$ = 32
??$?0AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<std::vector<int,std::allocator<int> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>,1>::_Compressed_pair<std::less<std::vector<int,std::allocator<int> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>,1><std::less<std::vector<int,std::allocator<int> > > const &,std::_Zero_then_variadic_args_t>, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1497 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@1@$$QEAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<std::vector<int,std::allocator<int> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>,1>::_Compressed_pair<std::less<std::vector<int,std::allocator<int> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>,1><std::less<std::vector<int,std::allocator<int> > > const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$?0AEBU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@H@1@$$QEAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$dead$ = 32
??$?0AEBU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@H@1@$$QEAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1497 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBU?$less@H@1@$$QEAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Get_size_of_n@$03@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$03@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<4>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
	sub	rsp, 40					; 00000028H

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rcx, rax
	ja	SHORT $LN6@Get_size_o

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rcx*4]

; 66   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Get_size_o:

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN4@Get_size_o:
??$_Get_size_of_n@$03@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits,0>, COMDAT

; 221  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN24:
	sub	rsp, 40					; 00000028H

; 222  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 223  : #if defined(_M_IX86) || defined(_M_X64)
; 224  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 225  :     if (!_STD is_constant_evaluated())
; 226  : #endif // _HAS_CXX20
; 227  :     {
; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN2@Allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN23@Allocate

; 77   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN11@Allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 239  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN11@Allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2@Allocate:

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN3@Allocate

; 239  : }

	add	rsp, 40					; 00000028H

; 77   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN3@Allocate:

; 235  :         return _Traits::_Allocate(_Bytes);
; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	eax, eax

; 239  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN23@Allocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN21@Allocate:
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
??$_Buyheadnode@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z PROC ; std::_Tree_node<std::vector<int,std::allocator<int> >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >, COMDAT

; 344  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

$LN28:
	sub	rsp, 40					; 00000028H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 351  :         _Pnode->_Isnil = true;
; 352  :         return _Pnode;
; 353  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Tree_node<std::vector<int,std::allocator<int> >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z PROC ; std::_Tree_node<int,void *>::_Buyheadnode<std::allocator<std::_Tree_node<int,void *> > >, COMDAT

; 344  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

$LN28:
	sub	rsp, 40					; 00000028H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

	mov	QWORD PTR [rax], rax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

	mov	QWORD PTR [rax+8], rax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

	mov	QWORD PTR [rax+16], rax

; 350  :         _Pnode->_Color = _Black;

	mov	WORD PTR [rax+24], 257			; 00000101H

; 351  :         _Pnode->_Isnil = true;
; 352  :         return _Pnode;
; 353  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAPEAU01@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z ENDP ; std::_Tree_node<int,void *>::_Buyheadnode<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAPEAHXZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAPEAHXZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release, COMDAT

; 1782 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1783 :         return _Last;
; 1784 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAPEAHXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >, COMDAT

; 1772 :         _Destroy_range(_First, _Last, _Al);
; 1773 :     }

	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@PEAHAEAV?$allocator@H@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@PEAHAEAV?$allocator@H@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >, COMDAT

; 1766 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAA@PEAHAEAV?$allocator@H@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator!=, COMDAT

; 102  :         return !(*this == _Right);

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	setne	al

; 103  :     }

	ret	0
??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator++, COMDAT

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rdx, QWORD PTR [rcx]
	mov	r8, rcx
	mov	r9, QWORD PTR [rdx+16]
	cmp	BYTE PTR [r9+25], 0
	je	SHORT $LN4@operator

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rdx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN3@operator
	npad	5
$LL2@operator:
	cmp	rdx, QWORD PTR [rax+16]
	jne	SHORT $LN3@operator

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	QWORD PTR [rcx], rax
	mov	rdx, rax
	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())
; 58   :         } else {
; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 60   :         }
; 61   : 
; 62   :         return *this;

	mov	QWORD PTR [rcx], rax

; 63   :     }

	mov	rax, r8
	ret	0
$LN4@operator:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [r9]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN9@operator
	npad	10
$LL8@operator:
	mov	rax, QWORD PTR [rcx]

; 454  :             _Pnode = _Pnode->_Left;

	mov	r9, rcx
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL8@operator
$LN9@operator:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())
; 58   :         } else {
; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 60   :         }
; 61   : 
; 62   :         return *this;

	mov	QWORD PTR [r8], r9

; 63   :     }

	mov	rax, r8
	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBV?$vector@HV?$allocator@H@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBV?$vector@HV?$allocator@H@std@@@1@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator*, COMDAT

; 43   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 32					; 00000020H

; 44   :     }

	ret	0
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBV?$vector@HV?$allocator@H@std@@@1@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::deallocate, COMDAT

; 656  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

	mov	rcx, rdx

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$dead$ = 16
?allocate@?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >::allocate, COMDAT

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 56					; 00000038H
	jmp	??2@YAPEAX_K@Z				; operator new
?allocate@?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAXPEBV?$vector@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_It$ = 16
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAXPEBV?$vector@HV?$allocator@H@std@@@2@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Seek_to, COMDAT

; 218  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

	mov	QWORD PTR [rcx], rdx

; 219  :     }

	ret	0
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@QEAAXPEBV?$vector@HV?$allocator@H@std@@@2@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator!=, COMDAT

; 102  :         return !(*this == _Right);

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	setne	al

; 103  :     }

	ret	0
??9?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator++, COMDAT

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rdx, QWORD PTR [rcx]
	mov	r8, rcx
	mov	r9, QWORD PTR [rdx+16]
	cmp	BYTE PTR [r9+25], 0
	je	SHORT $LN4@operator

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rdx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN3@operator
	npad	5
$LL2@operator:
	cmp	rdx, QWORD PTR [rax+16]
	jne	SHORT $LN3@operator

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	QWORD PTR [rcx], rax
	mov	rdx, rax
	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())
; 58   :         } else {
; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 60   :         }
; 61   : 
; 62   :         return *this;

	mov	QWORD PTR [rcx], rax

; 63   :     }

	mov	rax, r8
	ret	0
$LN4@operator:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [r9]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN9@operator
	npad	10
$LL8@operator:
	mov	rax, QWORD PTR [rcx]

; 454  :             _Pnode = _Pnode->_Left;

	mov	r9, rcx
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL8@operator
$LN9@operator:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())
; 58   :         } else {
; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 60   :         }
; 61   : 
; 62   :         return *this;

	mov	QWORD PTR [r8], r9

; 63   :     }

	mov	rax, r8
	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBHXZ
_TEXT	SEGMENT
this$ = 8
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBHXZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator*, COMDAT

; 43   :         return _Ptr->_Myval;

	mov	rax, QWORD PTR [rcx]
	add	rax, 28

; 44   :     }

	ret	0
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBHXZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAPEAHXZ
_TEXT	SEGMENT
this$ = 8
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAPEAHXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Unwrapped, COMDAT

; 342  :         return _Unfancy(this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 343  :     }

	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QEBAPEAHXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@2@QEAU?$_Tree_node@HPEAX@2@_K@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@2@QEAU?$_Tree_node@HPEAX@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::deallocate, COMDAT

; 656  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

	mov	rcx, rdx

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@2@QEAU?$_Tree_node@HPEAX@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@HPEAX@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$dead$ = 16
?allocate@?$allocator@U?$_Tree_node@HPEAX@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@_K@Z PROC ; std::allocator<std::_Tree_node<int,void *> >::allocate, COMDAT

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	jmp	??2@YAPEAX_K@Z				; operator new
?allocate@?$allocator@U?$_Tree_node@HPEAX@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@_K@Z ENDP ; std::allocator<std::_Tree_node<int,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength, COMDAT

; 2135 :     [[noreturn]] static void _Xlength() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2136 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Change_array@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXQEAV?$vector@HV?$allocator@H@std@@@2@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXQEAV?$vector@HV?$allocator@H@std@@@2@_K1@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Change_array, COMDAT

; 2011 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN28:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 2012 :         // orphan all iterators, discard old array, acquire new array
; 2013 :         auto& _Al         = _Getal();
; 2014 :         auto& _My_data    = _Mypair._Myval2;
; 2015 :         pointer& _Myfirst = _My_data._Myfirst;
; 2016 :         pointer& _Mylast  = _My_data._Mylast;
; 2017 :         pointer& _Myend   = _My_data._Myend;
; 2018 : 
; 2019 :         _My_data._Orphan_all();
; 2020 : 
; 2021 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	r14, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 2022 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdx, QWORD PTR [rbx+8]
	call	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >

; 2023 :             _ASAN_VECTOR_REMOVE;
; 2024 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rcx, QWORD PTR [rbx]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
	imul	rdx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx+rdx*2]
	shl	rdx, 3

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Change_arr

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Change_arr

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Change_arr:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2027 :         _Myfirst = _Newvec;

	mov	QWORD PTR [rbx], rdi

; 2028 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [r14+r14*2]
	lea	rcx, QWORD PTR [rdi+rax*8]
	mov	QWORD PTR [rbx+8], rcx

; 2029 :         _Myend   = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rsi+rsi*2]

; 2031 :     }

	mov	rsi, QWORD PTR [rsp+64]
	lea	rcx, QWORD PTR [rdi+rax*8]
	mov	rdi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+16], rcx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN15@Change_arr:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN25@Change_arr:
?_Change_array@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAXQEAV?$vector@HV?$allocator@H@std@@@2@_K1@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEBA_K_K@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Calculate_growth, COMDAT

; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1959 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

	mov	r9, rdx

; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	sub	r8, QWORD PTR [rcx]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	r8
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1960 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1961 :         const size_type _Oldcapacity = capacity();
; 1962 :         const auto _Max              = max_size();
; 1963 : 
; 1964 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	mov	r8, rdx
	mov	rcx, rax
	shr	r8, 1
	sub	rcx, r8
	cmp	rdx, rcx
	ja	SHORT $LN1@Calculate_

; 1965 :             return _Max; // geometric growth would overflow
; 1966 :         }
; 1967 : 
; 1968 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [r8+rdx]

; 1969 : 
; 1970 :         if (_Geometric < _Newsize) {

	cmp	rax, r9
	cmovb	rax, r9
$LN1@Calculate_:

; 1971 :             return _Newsize; // geometric growth would be insufficient
; 1972 :         }
; 1973 : 
; 1974 :         return _Geometric; // geometric growth is sufficient
; 1975 :     }

	ret	0
?_Calculate_growth@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEBA_K_K@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size, COMDAT

; 1871 :         return (_STD min)(

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 1872 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1873 :     }

	ret	0
?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Clear_and_reserve_geometric, COMDAT

; 1644 :     _CONSTEXPR20 void _Clear_and_reserve_geometric(const size_type _Newsize) {

$LN77:
	push	rbp
	push	rsi
	sub	rsp, 40					; 00000028H

; 1645 :         auto& _Al         = _Getal();
; 1646 :         auto& _My_data    = _Mypair._Myval2;
; 1647 :         pointer& _Myfirst = _My_data._Myfirst;
; 1648 :         pointer& _Mylast  = _My_data._Mylast;
; 1649 :         pointer& _Myend   = _My_data._Myend;
; 1650 : 
; 1651 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1652 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1653 :         _Check_all_orphaned();
; 1654 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1655 : 
; 1656 :         if (_Newsize > max_size()) {

	mov	rbp, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	mov	r8, rdx
	mov	rsi, rcx
	cmp	rdx, rbp
	ja	$LN75@Clear_and_

; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	r9, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, r9
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+88], rdi
	mov	QWORD PTR [rsp+32], r14
	mov	r14, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	rax, r14
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1964 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	rax, rbp
	mov	rcx, rdx
	shr	rcx, 1
	sub	rax, rcx
	cmp	rdx, rax
	jbe	SHORT $LN6@Clear_and_

; 1965 :             return _Max; // geometric growth would overflow

	mov	rdi, rbp
	jmp	SHORT $LN7@Clear_and_
$LN6@Clear_and_:

; 1966 :         }
; 1967 : 
; 1968 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rdi, QWORD PTR [rcx+rdx]

; 1969 : 
; 1970 :         if (_Geometric < _Newsize) {

	cmp	rdi, r8
	cmovb	rdi, r8
$LN7@Clear_and_:

; 1658 :         }
; 1659 : 
; 1660 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1661 : 
; 1662 :         if (_Myfirst) { // destroy and deallocate old array

	xor	ebx, ebx
	test	r9, r9
	je	SHORT $LN3@Clear_and_

; 1663 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, r9
	call	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >

; 1664 :             _ASAN_VECTOR_REMOVE;
; 1665 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	r8, QWORD PTR [rsi]
	mov	rax, r14
	mov	rcx, QWORD PTR [rsi+16]
	sub	rcx, r8
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx+rdx*2]
	shl	rdx, 3

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN55@Clear_and_

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [r8-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	r8, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [r8-8]
	cmp	rax, 31
	ja	SHORT $LN29@Clear_and_

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	r8, rcx
$LN55@Clear_and_:

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	rcx, r8
	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1667 :             _Myfirst = nullptr;

	mov	QWORD PTR [rsi], rbx

; 1668 :             _Mylast  = nullptr;

	mov	QWORD PTR [rsi+8], rbx

; 1669 :             _Myend   = nullptr;

	mov	QWORD PTR [rsi+16], rbx
$LN3@Clear_and_:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	cmp	rdi, rbp
	ja	SHORT $LN58@Clear_and_

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdi+rdi*2]
	lea	rdi, QWORD PTR [rax*8]

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdi, 4096				; 00001000H
	jb	SHORT $LN20@Clear_and_

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdi+39]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdi
	jbe	SHORT $LN58@Clear_and_

; 77   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN29@Clear_and_

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN21@Clear_and_
$LN29@Clear_and_:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN20@Clear_and_:

; 234  :     if (_Bytes != 0) {

	test	rdi, rdi
	je	SHORT $LN21@Clear_and_

; 77   :         return ::operator new(_Bytes);

	mov	rcx, rdi
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
$LN21@Clear_and_:
	mov	r14, QWORD PTR [rsp+32]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1990 :         _Myend             = _Newvec + _Newcapacity;

	lea	rax, QWORD PTR [rdi+rbx]
	mov	rdi, QWORD PTR [rsp+88]

; 1971 :             return _Newsize; // geometric growth would be insufficient
; 1972 :         }
; 1973 : 
; 1974 :         return _Geometric; // geometric growth is sufficient
; 1975 :     }
; 1976 : 
; 1977 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {
; 1978 :         // allocate array with _Newcapacity elements
; 1979 :         auto& _My_data    = _Mypair._Myval2;
; 1980 :         pointer& _Myfirst = _My_data._Myfirst;
; 1981 :         pointer& _Mylast  = _My_data._Mylast;
; 1982 :         pointer& _Myend   = _My_data._Myend;
; 1983 : 
; 1984 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1985 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1986 : 
; 1987 :         const auto _Newvec = _Getal().allocate(_Newcapacity);
; 1988 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rsi], rbx

; 1989 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rsi+8], rbx
	mov	rbx, QWORD PTR [rsp+80]

; 1990 :         _Myend             = _Newvec + _Newcapacity;

	mov	QWORD PTR [rsi+16], rax

; 1673 :     }

	add	rsp, 40					; 00000028H
	pop	rsi
	pop	rbp
	ret	0
$LN75@Clear_and_:

; 1657 :             _Xlength();

	call	?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
	int	3
$LN58@Clear_and_:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN73@Clear_and_:
?_Clear_and_reserve_geometric@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@_K@Z PROC ; std::allocator<std::vector<int,std::allocator<int> > >::allocate, COMDAT

; 949  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN31:
	sub	rsp, 40					; 00000028H

; 60   :         if (_Count > _Max_possible) {

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	rdx, rax
	ja	SHORT $LN27@allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*2]
	lea	rcx, QWORD PTR [rax*8]

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN27@allocate

; 77   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN17@allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 950  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 951  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 952  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN17@allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN8@allocate:

; 234  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN9@allocate

; 950  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 951  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 952  :     }

	add	rsp, 40					; 00000028H

; 77   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN9@allocate:

; 238  :     return nullptr;

	xor	eax, eax

; 950  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 951  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 952  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN27@allocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN29@allocate:
?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@_K@Z ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AEAAXQEAH_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AEAAXQEAH_K1@Z PROC ; std::vector<int,std::allocator<int> >::_Change_array, COMDAT

; 2011 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN28:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 2012 :         // orphan all iterators, discard old array, acquire new array
; 2013 :         auto& _Al         = _Getal();
; 2014 :         auto& _My_data    = _Mypair._Myval2;
; 2015 :         pointer& _Myfirst = _My_data._Myfirst;
; 2016 :         pointer& _Mylast  = _My_data._Mylast;
; 2017 :         pointer& _Myend   = _My_data._Myend;
; 2018 : 
; 2019 :         _My_data._Orphan_all();
; 2020 : 
; 2021 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN8@Change_arr

; 2022 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2023 :             _ASAN_VECTOR_REMOVE;
; 2024 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN18@Change_arr

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN15@Change_arr

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN18@Change_arr:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN8@Change_arr:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2028 :         _Mylast  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp*4]
	mov	QWORD PTR [rbx], rdi

; 2031 :     }

	mov	rbp, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi*4]
	mov	rsi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN15@Change_arr:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN25@Change_arr:
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AEAAXQEAH_K1@Z ENDP ; std::vector<int,std::allocator<int> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 80
_Right$ = 88
??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<int,std::allocator<int> >::operator=, COMDAT

; 1480 :     _CONSTEXPR20 vector& operator=(const vector& _Right) {

$LN77:
	push	rsi
	sub	rsp, 64					; 00000040H
	mov	rsi, rcx

; 1481 :         if (this == _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	$LN65@operator
	mov	QWORD PTR [rsp+56], rbp

; 1482 :             return *this;
; 1483 :         }
; 1484 : 
; 1485 :         auto& _Al       = _Getal();
; 1486 :         auto& _Right_al = _Right._Getal();
; 1487 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1488 :             if (_Al != _Right_al) {
; 1489 :                 _Tidy();
; 1490 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1491 :             }
; 1492 :         }
; 1493 : 
; 1494 :         _Pocca(_Al, _Right_al);
; 1495 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1496 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	rbp, QWORD PTR [rdx+8]
	mov	QWORD PTR [rsp+48], rdi

; 1391 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rdi, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+16]

; 1481 :         if (this == _STD addressof(_Right)) {

	mov	QWORD PTR [rsp+32], r15

; 1391 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	sub	rcx, rdi

; 1482 :             return *this;
; 1483 :         }
; 1484 : 
; 1485 :         auto& _Al       = _Getal();
; 1486 :         auto& _Right_al = _Right._Getal();
; 1487 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1488 :             if (_Al != _Right_al) {
; 1489 :                 _Tidy();
; 1490 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1491 :             }
; 1492 :         }
; 1493 : 
; 1494 :         _Pocca(_Al, _Right_al);
; 1495 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1496 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	mov	r15, QWORD PTR [rdx]
	sub	rbp, r15

; 1391 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	sar	rcx, 2

; 1482 :             return *this;
; 1483 :         }
; 1484 : 
; 1485 :         auto& _Al       = _Getal();
; 1486 :         auto& _Right_al = _Right._Getal();
; 1487 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1488 :             if (_Al != _Right_al) {
; 1489 :                 _Tidy();
; 1490 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1491 :             }
; 1492 :         }
; 1493 : 
; 1494 :         _Pocca(_Al, _Right_al);
; 1495 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1496 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

	sar	rbp, 2
	mov	QWORD PTR [rsp+96], rbx

; 1392 :         if (_Newsize > _Oldcapacity) {

	cmp	rbp, rcx
	jbe	SHORT $LN8@operator

; 1393 :             _Clear_and_reserve_geometric(_Newsize);

	mov	rdx, rbp
	mov	rcx, rsi
	call	?_Clear_and_reserve_geometric@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Clear_and_reserve_geometric

; 1394 :             if constexpr (_Nothrow_construct) {
; 1395 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdi, QWORD PTR [rsi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rbp*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	mov	rdx, r15
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1856 :             _Dest += _Count;

	lea	rcx, QWORD PTR [rbx+rdi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1498 :         return *this;

	mov	rax, rsi

; 1395 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	QWORD PTR [rsi+8], rcx

; 1396 :                 _ASAN_VECTOR_CREATE;
; 1397 :             } else {
; 1398 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1399 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1400 :             }
; 1401 :             return;

	jmp	SHORT $LN72@operator
$LN8@operator:
	mov	QWORD PTR [rsp+40], r14

; 1402 :         }
; 1403 : 
; 1404 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1405 :         if (_Newsize > _Oldsize) {

	mov	rdx, r15
	mov	r14, QWORD PTR [rsi+8]
	mov	rcx, rdi
	sub	r14, rdi
	sar	r14, 2
	cmp	rbp, r14
	jbe	SHORT $LN9@operator
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [r14*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1426 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	mov	rdi, QWORD PTR [rsi+8]
	lea	rdx, QWORD PTR [rbx+r15]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	sub	rbp, r14
$LN9@operator:

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	lea	rbx, QWORD PTR [rbp*4]
	mov	r8, rbx
	call	memmove
	mov	r14, QWORD PTR [rsp+40]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1856 :             _Dest += _Count;

	lea	rax, QWORD PTR [rbx+rdi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1426 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	mov	QWORD PTR [rsi+8], rax

; 1498 :         return *this;

	mov	rax, rsi
$LN72@operator:
	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+48]
	mov	r15, QWORD PTR [rsp+32]

; 1499 :     }

	add	rsp, 64					; 00000040H
	pop	rsi
	ret	0
$LN65@operator:

; 1498 :         return *this;

	mov	rax, rsi

; 1499 :     }

	add	rsp, 64					; 00000040H
	pop	rsi
	ret	0
??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<int,std::allocator<int> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator==, COMDAT

; 97   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 98   :     }

	ret	0
??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Min@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@PEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Min, COMDAT

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rdx, QWORD PTR [rcx]
	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN9@Min
	npad	7
$LL2@Min:
	mov	rcx, QWORD PTR [rdx]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rax, rdx
	mov	rdx, rcx
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL2@Min

; 458  :     }

	ret	0
$LN9@Min:

; 455  :         }
; 456  : 
; 457  :         return _Pnode;

	mov	rax, rcx

; 458  :     }

	ret	0
?_Min@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@PEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator==, COMDAT

; 97   :         return _Ptr == _Right._Ptr;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	sete	al

; 98   :     }

	ret	0
??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPEAU?$_Tree_node@HPEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Min@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPEAU?$_Tree_node@HPEAX@2@PEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Min, COMDAT

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rdx, QWORD PTR [rcx]
	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN9@Min
	npad	7
$LL2@Min:
	mov	rcx, QWORD PTR [rdx]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rax, rdx
	mov	rdx, rcx
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL2@Min

; 458  :     }

	ret	0
$LN9@Min:

; 455  :         }
; 456  : 
; 457  :         return _Pnode;

	mov	rax, rcx

; 458  :     }

	ret	0
?_Min@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPEAU?$_Tree_node@HPEAX@2@PEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal, COMDAT

; 2183 :         return _Mypair._Get_first();

	mov	rax, rcx

; 2184 :     }

	ret	0
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEBAAEBV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw, COMDAT

; 1977 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

$LN39:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1977 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

	mov	rdi, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 60   :         if (_Count > _Max_possible) {

	cmp	rdx, rax
	ja	SHORT $LN30@Buy_raw

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rdx+rdx*2]
	lea	rbx, QWORD PTR [rax*8]

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rbx, 4096				; 00001000H
	jb	SHORT $LN10@Buy_raw

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rbx+39]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	rcx, rbx
	jbe	SHORT $LN30@Buy_raw

; 77   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN19@Buy_raw

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN19@Buy_raw:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN10@Buy_raw:

; 234  :     if (_Bytes != 0) {

	test	rbx, rbx
	je	SHORT $LN11@Buy_raw

; 77   :         return ::operator new(_Bytes);

	mov	rcx, rbx
	call	??2@YAPEAX_K@Z				; operator new

; 235  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN9@Buy_raw
$LN11@Buy_raw:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	eax, eax
$LN9@Buy_raw:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1988 :         _Myfirst           = _Newvec;

	mov	QWORD PTR [rdi], rax

; 1989 :         _Mylast            = _Newvec;

	mov	QWORD PTR [rdi+8], rax

; 1990 :         _Myend             = _Newvec + _Newcapacity;

	add	rax, rbx

; 1991 :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi+16], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN30@Buy_raw:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN37@Buy_raw:
?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AEAAX_K@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?capacity@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::capacity, COMDAT

; 1876 :         auto& _My_data = _Mypair._Myval2;
; 1877 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rdx, QWORD PTR [rcx+16]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, QWORD PTR [rcx]
	imul	rdx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx

; 1878 :     }

	ret	0
?capacity@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size, COMDAT

; 691  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 692  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1><>, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1492 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1><>, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1492 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >, COMDAT

; 957  :     // check that [_First, _Last) forms an iterator range
; 958  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 959  :         _Verify_range(_First, _Last);
; 960  :     }
; 961  : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z
_TEXT	SEGMENT
_Loc$1$ = 32
$T9 = 32
$T2 = 48
_Loc$10 = 64
$T1 = 88
this$ = 160
_First$ = 168
_Last$ = 176
??$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_range_unchecked<int *,int *>, COMDAT

; 1257 :     void _Insert_range_unchecked(_Iter _First, const _Sent _Last) {

$LN95:

; 1259 :         for (; _First != _Last; ++_First) {

	cmp	rdx, r8
	je	$LN92@Insert_ran
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H

; 1257 :     void _Insert_range_unchecked(_Iter _First, const _Sent _Last) {

	mov	rbp, r8
	mov	rbx, rdx
	mov	rsi, rcx

; 1258 :         const auto _Myhead = _Get_scary()->_Myhead;

	mov	r14, QWORD PTR [rcx]
	mov	r15, 576460752303423487			; 07ffffffffffffffH
	xor	r12d, r12d
	npad	8
$LL4@Insert_ran:

; 1044 :             _Loc = _Find_hint(_Hint, _In_place_key_extractor::_Extract(_Vals...));

	mov	r9, rbx
	mov	r8, r14
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rsi
	call	??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_hint<int>
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR _Loc$1$[rsp], xmm0
	movsd	xmm0, QWORD PTR [rax+16]
	movsd	QWORD PTR _Loc$10[rsp+16], xmm0

; 1045 :             if (_Loc._Duplicate) {

	cmp	BYTE PTR _Loc$10[rsp+16], 0
	jne	SHORT $LN2@Insert_ran

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

	cmp	QWORD PTR [rsi+8], r15
	je	SHORT $LN86@Insert_ran

; 1050 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

	mov	rdi, QWORD PTR [rsi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR $T2[rsp], rsi

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T2[rsp+8], r12

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	r8, rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	eax, DWORD PTR [rbx]
	mov	DWORD PTR [r8+28], eax

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [r8], rdi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [r8+8], rdi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [r8+16], rdi

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [r8+24], 0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T2[rsp+8], r12
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1066 :         return _Scary->_Insert_node(_Loc._Location, _Inserted);

	movups	xmm0, XMMWORD PTR _Loc$1$[rsp]
	movaps	XMMWORD PTR $T9[rsp], xmm0
	lea	rdx, QWORD PTR $T9[rsp]
	mov	rcx, rsi
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@U?$_Tree_id@PEAU?$_Tree_node@HPEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Insert_node
$LN2@Insert_ran:

; 1259 :         for (; _First != _Last; ++_First) {

	add	rbx, 4
	cmp	rbx, rbp
	jne	$LL4@Insert_ran

; 1260 :             _Emplace_hint(_Myhead, *_First);
; 1261 :         }
; 1262 :     }

	lea	r11, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [r11+64]
	mov	rbp, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
$LN92@Insert_ran:
	ret	0
$LN86@Insert_ran:

; 1630 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN91@Insert_ran:
??$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_range_unchecked<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Loc$1$ = 32
$T9 = 32
$T2 = 48
_Loc$10 = 64
$T1 = 88
this$ = 160
_First$ = 168
_Last$ = 176
?dtor$2@?0???$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z@4HA PROC ; `std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_range_unchecked<int *,int *>'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
?dtor$2@?0???$_Insert_range_unchecked@PEAHPEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXPEAHQEAH@Z@4HA ENDP ; `std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_range_unchecked<int *,int *>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> >, COMDAT

; 957  :     // check that [_First, _Last) forms an iterator range
; 958  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 959  :         _Verify_range(_First, _Last);
; 960  :     }
; 961  : }

	ret	0
??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$move@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z PROC ; std::move<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> &>, COMDAT

; 1450 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1451 : }

	ret	0
??$move@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z ENDP ; std::move<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_T$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_T$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@@Z PROC ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> >, COMDAT

; 980  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 981  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 982  :         return _It + 0;
; 983  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 984  :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 985  :     } else {
; 986  :         return static_cast<_Iter&&>(_It);

	mov	rax, rcx

; 987  :     }
; 988  : }

	ret	0
??$_Get_unwrapped@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_T$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@@Z ENDP ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@H@2@@std@@YAPEAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@_KPEAHAEAV?$allocator@H@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Dest$ = 24
_Al$dead$ = 32
??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@H@2@@std@@YAPEAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@_KPEAHAEAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy_n<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>,std::allocator<int> >, COMDAT

; 1839 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	r9, r8
	mov	r10, rdx

; 1862 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdx, rdx
	je	SHORT $LN40@Uninitiali
	npad	5
$LL4@Uninitiali:

; 1777 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR [rcx+28]
	mov	DWORD PTR [r9], eax

; 1778 :         ++_Last;

	add	r9, 4
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rcx+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN9@Uninitiali

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN8@Uninitiali
	npad	2
$LL7@Uninitiali:
	cmp	rcx, QWORD PTR [rax+16]
	jne	SHORT $LN8@Uninitiali

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rcx, rax
	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL7@Uninitiali
$LN8@Uninitiali:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rcx, rax

; 58   :         } else {

	jmp	SHORT $LN10@Uninitiali
$LN9@Uninitiali:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	r8, QWORD PTR [rax]

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rcx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	cmp	BYTE PTR [r8+25], 0
	jne	SHORT $LN10@Uninitiali
	npad	11
$LL13@Uninitiali:
	mov	rdx, QWORD PTR [r8]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rcx, r8
	mov	r8, rdx
	cmp	BYTE PTR [rdx+25], 0
	je	SHORT $LL13@Uninitiali
$LN10@Uninitiali:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1862 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	sub	r10, 1
	jne	SHORT $LL4@Uninitiali
$LN40@Uninitiali:

; 1863 :         _Backout._Emplace_back(*_UFirst);
; 1864 :     }
; 1865 : 
; 1866 :     return _Backout._Release();
; 1867 : }

	mov	rax, r9
	ret	0
??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@H@2@@std@@YAPEAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@_KPEAHAEAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy_n<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@_KPEAH@std@@YAPEAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@_KPEAH@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Dest$ = 24
??$_Copy_n_unchecked4@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@_KPEAH@std@@YAPEAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@_KPEAH@Z PROC ; std::_Copy_n_unchecked4<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>,unsigned __int64,int *>, COMDAT

; 4458 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

	mov	r9, r8
	mov	r10, rdx

; 4474 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	SHORT $LN30@Copy_n_unc
	npad	5
$LL4@Copy_n_unc:

; 4475 :         *_Dest = *_First;

	mov	eax, DWORD PTR [rcx+28]
	mov	DWORD PTR [r9], eax
	add	r9, 4
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rcx+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN9@Copy_n_unc

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rcx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN8@Copy_n_unc
	npad	2
$LL7@Copy_n_unc:
	cmp	rcx, QWORD PTR [rax+16]
	jne	SHORT $LN8@Copy_n_unc

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rcx, rax
	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL7@Copy_n_unc
$LN8@Copy_n_unc:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rcx, rax

; 58   :         } else {

	jmp	SHORT $LN10@Copy_n_unc
$LN9@Copy_n_unc:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	r8, QWORD PTR [rax]

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rcx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	cmp	BYTE PTR [r8+25], 0
	jne	SHORT $LN10@Copy_n_unc
	npad	11
$LL13@Copy_n_unc:
	mov	rdx, QWORD PTR [r8]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rcx, r8
	mov	r8, rdx
	cmp	BYTE PTR [rdx+25], 0
	je	SHORT $LL13@Copy_n_unc
$LN10@Copy_n_unc:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4474 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	sub	r10, 1
	jne	SHORT $LL4@Copy_n_unc
$LN30@Copy_n_unc:

; 4476 :     }
; 4477 : 
; 4478 :     return _Dest;
; 4479 : }

	mov	rax, r9
	ret	0
??$_Copy_n_unchecked4@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@_KPEAH@std@@YAPEAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@_KPEAH@Z ENDP ; std::_Copy_n_unchecked4<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>,unsigned __int64,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z
_TEXT	SEGMENT
$T2 = 32
_Loc$1$ = 48
$T10 = 48
_Loc$11 = 64
$T1 = 88
this$ = 176
_First$ = 184
_Last$ = 192
??$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Insert_range_unchecked<std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *>, COMDAT

; 1257 :     void _Insert_range_unchecked(_Iter _First, const _Sent _Last) {

$LN128:

; 1259 :         for (; _First != _Last; ++_First) {

	cmp	rdx, r8
	je	$LN125@Insert_ran
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H

; 1257 :     void _Insert_range_unchecked(_Iter _First, const _Sent _Last) {

	mov	rbp, r8
	mov	rbx, rdx
	mov	r14, rcx

; 1258 :         const auto _Myhead = _Get_scary()->_Myhead;

	mov	r15, QWORD PTR [rcx]
	mov	r12, 329406144173384850			; 0492492492492492H
	xor	r13d, r13d
	npad	10
$LL4@Insert_ran:

; 1044 :             _Loc = _Find_hint(_Hint, _In_place_key_extractor::_Extract(_Vals...));

	mov	r9, rbx
	mov	r8, r15
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, r14
	call	??$_Find_hint@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Find_hint<std::vector<int,std::allocator<int> > >
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR _Loc$1$[rsp], xmm0
	movsd	xmm0, QWORD PTR [rax+16]
	movsd	QWORD PTR _Loc$11[rsp+16], xmm0

; 1045 :             if (_Loc._Duplicate) {

	cmp	BYTE PTR _Loc$11[rsp+16], 0
	jne	SHORT $LN2@Insert_ran

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

	cmp	QWORD PTR [r14+8], r12
	je	$LN119@Insert_ran

; 1050 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

	mov	rdi, QWORD PTR [r14]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR $T2[rsp], r14

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T2[rsp+8], r13

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax
	mov	QWORD PTR $T2[rsp+8], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rcx, QWORD PTR [rax+32]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	call	??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [rsi], rdi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [rsi+8], rdi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [rsi+16], rdi

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [rsi+24], 0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR $T2[rsp+8], r13
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1066 :         return _Scary->_Insert_node(_Loc._Location, _Inserted);

	movups	xmm0, XMMWORD PTR _Loc$1$[rsp]
	movaps	XMMWORD PTR $T10[rsp], xmm0
	mov	r8, rsi
	lea	rdx, QWORD PTR $T10[rsp]
	mov	rcx, r14
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Insert_node
$LN2@Insert_ran:

; 1259 :         for (; _First != _Last; ++_First) {

	add	rbx, 24
	cmp	rbx, rbp
	jne	$LL4@Insert_ran

; 1260 :             _Emplace_hint(_Myhead, *_First);
; 1261 :         }
; 1262 :     }

	mov	rbx, QWORD PTR [rsp+192]
	add	rsp, 112				; 00000070H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
$LN125@Insert_ran:
	ret	0
$LN119@Insert_ran:

; 1630 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN124@Insert_ran:
??$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Insert_range_unchecked<std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
_Loc$1$ = 48
$T10 = 48
_Loc$11 = 64
$T1 = 88
this$ = 176
_First$ = 184
_Last$ = 192
?dtor$2@?0???$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z@4HA PROC ; `std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Insert_range_unchecked<std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *>'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
?dtor$2@?0???$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z@4HA ENDP ; `std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Insert_range_unchecked<std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
_Loc$1$ = 48
$T10 = 48
_Loc$11 = 64
$T1 = 88
this$ = 176
_First$ = 184
_Last$ = 192
?dtor$1@?0???$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z@4HA PROC ; `std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Insert_range_unchecked<std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *>'::`1'::dtor$1
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0???$_Insert_range_unchecked@PEAV?$vector@HV?$allocator@H@std@@@std@@PEAV12@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXPEAV?$vector@HV?$allocator@H@std@@@1@QEAV21@@Z@4HA ENDP ; `std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Insert_range_unchecked<std::vector<int,std::allocator<int> > *,std::vector<int,std::allocator<int> > *>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> >, COMDAT

; 957  :     // check that [_First, _Last) forms an iterator range
; 958  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 959  :         _Verify_range(_First, _Last);
; 960  :     }
; 961  : }

	ret	0
??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXAEBV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$move@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z PROC ; std::move<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> &>, COMDAT

; 1450 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1451 : }

	ret	0
??$move@AEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@AEAV10@@Z ENDP ; std::move<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_T$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_T$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z PROC ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> >, COMDAT

; 980  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 981  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 982  :         return _It + 0;
; 983  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 984  :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 985  :     } else {
; 986  :         return static_cast<_Iter&&>(_It);

	mov	rax, rcx

; 987  :     }
; 988  : }

	ret	0
??$_Get_unwrapped@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_T$$QEAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z ENDP ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::_Uninitialized_copy_n<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 1839 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN48:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _Backout$[rsp], xmm0

; 1766 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR _Backout$[rsp], r8
	mov	QWORD PTR _Backout$[rsp+8], r8
	mov	QWORD PTR _Backout$[rsp+16], r9

; 1862 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	test	rdx, rdx
	je	SHORT $LN3@Uninitiali
$LL4@Uninitiali:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 43   :         return _Ptr->_Myval;

	lea	rdx, QWORD PTR [rbx+32]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rcx, rdi
	call	??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >

; 1778 :         ++_Last;

	add	rdi, 24
	mov	QWORD PTR _Backout$[rsp+8], rdi
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rbx+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN10@Uninitiali

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN9@Uninitiali
	npad	4
$LL8@Uninitiali:
	cmp	rbx, QWORD PTR [rax+16]
	jne	SHORT $LN9@Uninitiali

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rbx, rax

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL8@Uninitiali
$LN9@Uninitiali:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rbx, rax

; 58   :         } else {

	jmp	SHORT $LN11@Uninitiali
$LN10@Uninitiali:

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rbx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [rax]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN11@Uninitiali
	npad	12
$LL14@Uninitiali:

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rcx

; 60   :         }
; 61   : 
; 62   :         return *this;
; 63   :     }
; 64   : 
; 65   :     _Tree_unchecked_const_iterator operator++(int) noexcept {
; 66   :         _Tree_unchecked_const_iterator _Tmp = *this;
; 67   :         ++*this;
; 68   :         return _Tmp;
; 69   :     }
; 70   : 
; 71   :     _Tree_unchecked_const_iterator& operator--() noexcept {
; 72   :         if (_Ptr->_Isnil) {
; 73   :             _Ptr = _Ptr->_Right; // end() ==> rightmost
; 74   :         } else if (_Ptr->_Left->_Isnil) { // climb looking for left subtree
; 75   :             _Nodeptr _Pnode;
; 76   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Left) {
; 77   :                 _Ptr = _Pnode; // ==> parent while left subtree
; 78   :             }
; 79   : 
; 80   :             if (!_Ptr->_Isnil) { // decrement non-begin()
; 81   :                 _Ptr = _Pnode; // ==> parent if not head
; 82   :             }
; 83   :         } else {
; 84   :             _Ptr = _Mytree::_Max(_Ptr->_Left); // ==> largest of left subtree
; 85   :         }
; 86   : 
; 87   :         return *this;
; 88   :     }
; 89   : 
; 90   :     _Tree_unchecked_const_iterator operator--(int) noexcept {
; 91   :         _Tree_unchecked_const_iterator _Tmp = *this;
; 92   :         --*this;
; 93   :         return _Tmp;
; 94   :     }
; 95   : 
; 96   :     _NODISCARD bool operator==(const _Tree_unchecked_const_iterator& _Right) const noexcept {
; 97   :         return _Ptr == _Right._Ptr;
; 98   :     }
; 99   : 
; 100  : #if !_HAS_CXX20
; 101  :     _NODISCARD bool operator!=(const _Tree_unchecked_const_iterator& _Right) const noexcept {
; 102  :         return !(*this == _Right);
; 103  :     }
; 104  : #endif // !_HAS_CXX20
; 105  : 
; 106  :     _NODISCARD bool operator==(_Default_sentinel) const noexcept {
; 107  :         return !!_Ptr->_Isnil; // TRANSITION, avoid warning C4800:
; 108  :                                // "Implicit conversion from 'char' to bool. Possible information loss" (/Wall)
; 109  :     }
; 110  : 
; 111  : #if !_HAS_CXX20
; 112  :     _NODISCARD bool operator!=(_Default_sentinel) const noexcept {
; 113  :         return !_Ptr->_Isnil;
; 114  :     }
; 115  : #endif // !_HAS_CXX20
; 116  : 
; 117  :     _Nodeptr _Ptr; // pointer to node
; 118  : };
; 119  : 
; 120  : template <class _Mytree>
; 121  : class _Tree_unchecked_iterator : public _Tree_unchecked_const_iterator<_Mytree> {
; 122  : public:
; 123  :     using _Mybase           = _Tree_unchecked_const_iterator<_Mytree>;
; 124  :     using iterator_category = bidirectional_iterator_tag;
; 125  : 
; 126  :     using _Nodeptr        = typename _Mytree::_Nodeptr;
; 127  :     using value_type      = typename _Mytree::value_type;
; 128  :     using difference_type = typename _Mytree::difference_type;
; 129  :     using pointer         = typename _Mytree::pointer;
; 130  :     using reference       = value_type&;
; 131  : 
; 132  :     using _Mybase::_Mybase;
; 133  : 
; 134  :     _NODISCARD reference operator*() const noexcept {
; 135  :         return const_cast<reference>(_Mybase::operator*());
; 136  :     }
; 137  : 
; 138  :     _NODISCARD pointer operator->() const noexcept {
; 139  :         return pointer_traits<pointer>::pointer_to(**this);
; 140  :     }
; 141  : 
; 142  :     _Tree_unchecked_iterator& operator++() noexcept {
; 143  :         _Mybase::operator++();
; 144  :         return *this;
; 145  :     }
; 146  : 
; 147  :     _Tree_unchecked_iterator operator++(int) noexcept {
; 148  :         _Tree_unchecked_iterator _Tmp = *this;
; 149  :         _Mybase::operator++();
; 150  :         return _Tmp;
; 151  :     }
; 152  : 
; 153  :     _Tree_unchecked_iterator& operator--() noexcept {
; 154  :         _Mybase::operator--();
; 155  :         return *this;
; 156  :     }
; 157  : 
; 158  :     _Tree_unchecked_iterator operator--(int) noexcept {
; 159  :         _Tree_unchecked_iterator _Tmp = *this;
; 160  :         _Mybase::operator--();
; 161  :         return _Tmp;
; 162  :     }
; 163  : };
; 164  : 
; 165  : template <class _Mytree>
; 166  : class _Tree_const_iterator : public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> {
; 167  : public:
; 168  :     using _Mybase           = _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>;
; 169  :     using iterator_category = bidirectional_iterator_tag;
; 170  : 
; 171  :     using _Nodeptr        = typename _Mytree::_Nodeptr;
; 172  :     using value_type      = typename _Mytree::value_type;
; 173  :     using difference_type = typename _Mytree::difference_type;
; 174  :     using pointer         = typename _Mytree::const_pointer;
; 175  :     using reference       = const value_type&;
; 176  : 
; 177  :     using _Mybase::_Mybase;
; 178  : 
; 179  :     _NODISCARD reference operator*() const noexcept {
; 180  : #if _ITERATOR_DEBUG_LEVEL == 2
; 181  :         const auto _Mycont = static_cast<const _Mytree*>(this->_Getcont());
; 182  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized map/set iterator");
; 183  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end map/set iterator");
; 184  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 185  : 
; 186  :         return this->_Ptr->_Myval;
; 187  :     }
; 188  : 
; 189  :     _NODISCARD pointer operator->() const noexcept {
; 190  :         return pointer_traits<pointer>::pointer_to(**this);
; 191  :     }
; 192  : 
; 193  :     _Tree_const_iterator& operator++() noexcept {
; 194  : #if _ITERATOR_DEBUG_LEVEL == 2
; 195  :         _STL_VERIFY(this->_Getcont(), "cannot increment value-initialized map/set iterator");
; 196  :         _STL_VERIFY(!this->_Ptr->_Isnil, "cannot increment end map/set iterator");
; 197  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 198  : 
; 199  :         _Mybase::operator++();
; 200  :         return *this;
; 201  :     }
; 202  : 
; 203  :     _Tree_const_iterator operator++(int) noexcept {
; 204  :         _Tree_const_iterator _Tmp = *this;
; 205  :         ++*this;
; 206  :         return _Tmp;
; 207  :     }
; 208  : 
; 209  :     _Tree_const_iterator& operator--() noexcept {
; 210  : #if _ITERATOR_DEBUG_LEVEL == 2
; 211  :         _STL_ASSERT(this->_Getcont(), "cannot decrement value-initialized map/set iterator");
; 212  :         _Nodeptr _Ptrsav = this->_Ptr;
; 213  :         _Mybase::operator--();
; 214  :         _STL_VERIFY(_Ptrsav != this->_Ptr, "cannot decrement begin map/set iterator");
; 215  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
; 216  :         _Mybase::operator--();
; 217  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 218  : 
; 219  :         return *this;
; 220  :     }
; 221  : 
; 222  :     _Tree_const_iterator operator--(int) noexcept {
; 223  :         _Tree_const_iterator _Tmp = *this;
; 224  :         --*this;
; 225  :         return _Tmp;
; 226  :     }
; 227  : 
; 228  :     _NODISCARD bool operator==(const _Tree_const_iterator& _Right) const noexcept {
; 229  : #if _ITERATOR_DEBUG_LEVEL == 2
; 230  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 231  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 232  : 
; 233  :         return this->_Ptr == _Right._Ptr;
; 234  :     }
; 235  : 
; 236  : #if !_HAS_CXX20
; 237  :     _NODISCARD bool operator!=(const _Tree_const_iterator& _Right) const noexcept {
; 238  :         return !(*this == _Right);
; 239  :     }
; 240  : #endif // !_HAS_CXX20
; 241  : 
; 242  : #if _ITERATOR_DEBUG_LEVEL == 2
; 243  :     friend void _Verify_range(const _Tree_const_iterator& _First, const _Tree_const_iterator& _Last) noexcept {
; 244  :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "map/set iterators in range are from different containers");
; 245  :     }
; 246  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 247  : 
; 248  :     using _Prevent_inheriting_unwrap = _Tree_const_iterator;
; 249  : 
; 250  :     _NODISCARD _Tree_unchecked_const_iterator<_Mytree> _Unwrapped() const noexcept {
; 251  :         return _Tree_unchecked_const_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));
; 252  :     }
; 253  : 
; 254  :     void _Seek_to(const _Tree_unchecked_const_iterator<_Mytree> _It) noexcept {
; 255  :         this->_Ptr = _It._Ptr;
; 256  :     }
; 257  : };
; 258  : 
; 259  : template <class _Mytree>
; 260  : class _Tree_iterator : public _Tree_const_iterator<_Mytree> {
; 261  : public:
; 262  :     using _Mybase           = _Tree_const_iterator<_Mytree>;
; 263  :     using iterator_category = bidirectional_iterator_tag;
; 264  : 
; 265  :     using _Nodeptr        = typename _Mytree::_Nodeptr;
; 266  :     using value_type      = typename _Mytree::value_type;
; 267  :     using difference_type = typename _Mytree::difference_type;
; 268  : 
; 269  :     using pointer   = typename _Mytree::pointer;
; 270  :     using reference = value_type&;
; 271  : 
; 272  :     using _Mybase::_Mybase;
; 273  : 
; 274  :     _NODISCARD reference operator*() const noexcept {
; 275  :         return const_cast<reference>(_Mybase::operator*());
; 276  :     }
; 277  : 
; 278  :     _NODISCARD pointer operator->() const noexcept {
; 279  :         return pointer_traits<pointer>::pointer_to(**this);
; 280  :     }
; 281  : 
; 282  :     _Tree_iterator& operator++() noexcept {
; 283  :         _Mybase::operator++();
; 284  :         return *this;
; 285  :     }
; 286  : 
; 287  :     _Tree_iterator operator++(int) noexcept {
; 288  :         _Tree_iterator _Tmp = *this;
; 289  :         _Mybase::operator++();
; 290  :         return _Tmp;
; 291  :     }
; 292  : 
; 293  :     _Tree_iterator& operator--() noexcept {
; 294  :         _Mybase::operator--();
; 295  :         return *this;
; 296  :     }
; 297  : 
; 298  :     _Tree_iterator operator--(int) noexcept {
; 299  :         _Tree_iterator _Tmp = *this;
; 300  :         _Mybase::operator--();
; 301  :         return _Tmp;
; 302  :     }
; 303  : 
; 304  :     using _Prevent_inheriting_unwrap = _Tree_iterator;
; 305  : 
; 306  :     _NODISCARD _Tree_unchecked_iterator<_Mytree> _Unwrapped() const noexcept {
; 307  :         return _Tree_unchecked_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));
; 308  :     }
; 309  : };
; 310  : 
; 311  : template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
; 312  :     class _Reference, class _Const_reference, class _Nodeptr_type>
; 313  : struct _Tree_iter_types {
; 314  :     using value_type      = _Value_type;
; 315  :     using size_type       = _Size_type;
; 316  :     using difference_type = _Difference_type;
; 317  :     using pointer         = _Pointer;
; 318  :     using const_pointer   = _Const_pointer;
; 319  :     using _Nodeptr        = _Nodeptr_type;
; 320  : };
; 321  : 
; 322  : template <class _Value_type, class _Voidptr>
; 323  : struct _Tree_node {
; 324  :     using _Nodeptr   = _Rebind_pointer_t<_Voidptr, _Tree_node>;
; 325  :     using value_type = _Value_type;
; 326  :     _Nodeptr _Left; // left subtree, or smallest element if head
; 327  :     _Nodeptr _Parent; // parent, or root of tree if head
; 328  :     _Nodeptr _Right; // right subtree, or largest element if head
; 329  :     char _Color; // _Red or _Black, _Black if head
; 330  :     char _Isnil; // true only if head (also nil) node; TRANSITION, should be bool
; 331  :     value_type _Myval = // the stored value, unused if head
; 332  :         _Returns_exactly<value_type>(); // fake a viable constructor to workaround GH-2749
; 333  : 
; 334  :     enum _Redbl { // colors for link to parent
; 335  :         _Red,
; 336  :         _Black
; 337  :     };
; 338  : 
; 339  :     _Tree_node()                             = default;
; 340  :     _Tree_node(const _Tree_node&)            = delete;
; 341  :     _Tree_node& operator=(const _Tree_node&) = delete;
; 342  : 
; 343  :     template <class _Alloc>
; 344  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {
; 345  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buyheadnode call");
; 346  :         const auto _Pnode = _Al.allocate(1);
; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);
; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);
; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);
; 350  :         _Pnode->_Color = _Black;
; 351  :         _Pnode->_Isnil = true;
; 352  :         return _Pnode;
; 353  :     }
; 354  : 
; 355  :     template <class _Alloc, class... _Valty>
; 356  :     static _Nodeptr _Buynode(_Alloc& _Al, _Nodeptr _Myhead, _Valty&&... _Val) {
; 357  :         // allocate a node with defaults and set links and value
; 358  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buynode call");
; 359  :         _Alloc_construct_ptr<_Alloc> _Newnode(_Al);
; 360  :         _Newnode._Allocate();
; 361  :         allocator_traits<_Alloc>::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);
; 362  :         _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);
; 363  :         _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);
; 364  :         _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);
; 365  :         _Newnode._Ptr->_Color = _Red;
; 366  :         _Newnode._Ptr->_Isnil = false;
; 367  :         return _Newnode._Release();
; 368  :     }
; 369  : 
; 370  :     template <class _Alloc>
; 371  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {
; 372  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 373  :         _Destroy_in_place(_Ptr->_Left);
; 374  :         _Destroy_in_place(_Ptr->_Parent);
; 375  :         _Destroy_in_place(_Ptr->_Right);
; 376  :         allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);
; 377  :     }
; 378  : 
; 379  :     template <class _Alloc>
; 380  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {
; 381  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode call");
; 382  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));
; 383  :         _Freenode0(_Al, _Ptr);
; 384  :     }
; 385  : };
; 386  : 
; 387  : template <class _Ty>
; 388  : struct _Tree_simple_types : _Simple_types<_Ty> {
; 389  :     using _Node    = _Tree_node<_Ty, void*>;
; 390  :     using _Nodeptr = _Node*;
; 391  : };
; 392  : 
; 393  : enum class _Tree_child {
; 394  :     _Right, // perf note: compare with _Right rather than _Left where possible for comparison with zero
; 395  :     _Left,
; 396  :     _Unused // indicates that tree child should never be used for insertion
; 397  : };
; 398  : 
; 399  : template <class _Nodeptr>
; 400  : struct _Tree_id {
; 401  :     _Nodeptr _Parent; // the leaf node under which a new node should be inserted
; 402  :     _Tree_child _Child;
; 403  : };
; 404  : 
; 405  : template <class _Nodeptr>
; 406  : struct _Tree_find_result {
; 407  :     _Tree_id<_Nodeptr> _Location;
; 408  :     _Nodeptr _Bound;
; 409  : };
; 410  : 
; 411  : template <class _Nodeptr>
; 412  : struct _Tree_find_hint_result {
; 413  :     _Tree_id<_Nodeptr> _Location;
; 414  :     bool _Duplicate;
; 415  : };
; 416  : 
; 417  : [[noreturn]] inline void _Throw_tree_length_error() {
; 418  :     _Xlength_error("map/set too long");
; 419  : }
; 420  : 
; 421  : template <class _Val_types>
; 422  : class _Tree_val : public _Container_base {
; 423  : public:
; 424  :     using _Nodeptr = typename _Val_types::_Nodeptr;
; 425  : 
; 426  :     using value_type      = typename _Val_types::value_type;
; 427  :     using size_type       = typename _Val_types::size_type;
; 428  :     using difference_type = typename _Val_types::difference_type;
; 429  :     using pointer         = typename _Val_types::pointer;
; 430  :     using const_pointer   = typename _Val_types::const_pointer;
; 431  :     using reference       = value_type&;
; 432  :     using const_reference = const value_type&;
; 433  : 
; 434  :     using _Unchecked_const_iterator = _Tree_unchecked_const_iterator<_Tree_val>;
; 435  :     using const_iterator            = _Tree_const_iterator<_Tree_val>;
; 436  : 
; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}
; 438  : 
; 439  :     enum _Redbl { // colors for link to parent
; 440  :         _Red,
; 441  :         _Black
; 442  :     };
; 443  : 
; 444  :     static _Nodeptr _Max(_Nodeptr _Pnode) noexcept { // return rightmost node in subtree at _Pnode
; 445  :         while (!_Pnode->_Right->_Isnil) {
; 446  :             _Pnode = _Pnode->_Right;
; 447  :         }
; 448  : 
; 449  :         return _Pnode;
; 450  :     }
; 451  : 
; 452  :     static _Nodeptr _Min(_Nodeptr _Pnode) noexcept { // return leftmost node in subtree at _Pnode
; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR [rcx]
	mov	rcx, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL14@Uninitiali
$LN11@Uninitiali:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1862 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

	sub	rsi, 1
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1772 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rdi
	mov	rcx, rdi
	call	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >

; 1863 :         _Backout._Emplace_back(*_UFirst);
; 1864 :     }
; 1865 : 
; 1866 :     return _Backout._Release();

	mov	rax, rdi

; 1867 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy_n<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>,std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
__$ArrayPad$ = 56
_First$ = 80
_Count$ = 88
_Dest$ = 96
_Al$ = 104
?dtor$0@?0???$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy_n<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>,std::allocator<std::vector<int,std::allocator<int> > > >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Backout$[rdx]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
?dtor$0@?0???$_Uninitialized_copy_n@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy_n<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>,std::allocator<std::vector<int,std::allocator<int> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@_KPEAV?$vector@HV?$allocator@H@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@_KPEAV?$vector@HV?$allocator@H@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@@Z PROC ; std::_Copy_n_unchecked4<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>,unsigned __int64,std::vector<int,std::allocator<int> > *>, COMDAT

; 4458 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbx, rcx

; 4474 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	test	rdx, rdx
	je	SHORT $LN30@Copy_n_unc
	npad	3
$LL4@Copy_n_unc:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 43   :         return _Ptr->_Myval;

	lea	rdx, QWORD PTR [rbx+32]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4475 :         *_Dest = *_First;

	mov	rcx, rdi
	call	??4?$vector@HV?$allocator@H@std@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<int,std::allocator<int> >::operator=
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rax, QWORD PTR [rbx+16]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4474 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	add	rdi, 24
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LN9@Copy_n_unc

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN31@Copy_n_unc
$LL7@Copy_n_unc:
	cmp	rbx, QWORD PTR [rax+16]
	jne	SHORT $LN31@Copy_n_unc

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	rbx, rax
	mov	rax, QWORD PTR [rax+8]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL7@Copy_n_unc
$LN31@Copy_n_unc:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

	mov	rbx, rax

; 58   :         } else {

	jmp	SHORT $LN14@Copy_n_unc
$LN9@Copy_n_unc:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	rdx, QWORD PTR [rax]

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

	mov	rbx, rax

; 453  :         while (!_Pnode->_Left->_Isnil) {

	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN14@Copy_n_unc
	npad	8
$LL13@Copy_n_unc:
	mov	rcx, QWORD PTR [rdx]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rbx, rdx
	mov	rdx, rcx
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL13@Copy_n_unc
$LN14@Copy_n_unc:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4474 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

	sub	rsi, 1
	jne	SHORT $LL4@Copy_n_unc
$LN30@Copy_n_unc:

; 4476 :     }
; 4477 : 
; 4478 :     return _Dest;
; 4479 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_n_unchecked4@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@_KPEAV?$vector@HV?$allocator@H@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@0@_KPEAV10@@Z ENDP ; std::_Copy_n_unchecked4<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>,unsigned __int64,std::vector<int,std::allocator<int> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$?8HV?$allocator@H@std@@@std@@YA_NAEBV?$vector@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$?8HV?$allocator@H@std@@@std@@YA_NAEBV?$vector@HV?$allocator@H@std@@@0@0@Z PROC ; std::operator==<int,std::allocator<int> >, COMDAT

; 2219 : _NODISCARD _CONSTEXPR20 bool operator==(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {

$LN24:
	sub	rsp, 40					; 00000028H

; 1867 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	r9, QWORD PTR [rdx]
	mov	r10, QWORD PTR [rcx]
	mov	r8, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rdx+8]
	sub	r8, r10
	sub	rax, r9

; 2220 :     if (_Left.size() != _Right.size()) {

	xor	rax, r8
	test	rax, -4
	je	SHORT $LN2@operator

; 2221 :         return false;

	xor	al, al

; 2230 : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@operator:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5149 :     return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));

	mov	rdx, r9
	mov	rcx, r10
	call	memcmp

; 5172 :             return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;

	test	eax, eax
	sete	al
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2230 : }

	add	rsp, 40					; 00000028H
	ret	0
??$?8HV?$allocator@H@std@@@std@@YA_NAEBV?$vector@HV?$allocator@H@std@@@0@0@Z ENDP ; std::operator==<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
;	COMDAT ??$exchange@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@0@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@0@Z PROC ; std::exchange<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *,std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * &>, COMDAT

; 755  :     // assign _New_val to _Val, return previous _Val
; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 758  :     return _Old_val;
; 759  : }

	ret	0
??$exchange@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@0@Z ENDP ; std::exchange<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *,std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Ptr$ = 56
??$_Freenode@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU01@@Z PROC ; std::_Tree_node<std::vector<int,std::allocator<int> >,void *>::_Freenode<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >, COMDAT

; 380  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

$LN61:
	push	rbx
	sub	rsp, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdx+32]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 380  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

	mov	rbx, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN11@Freenode

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdx+48]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@Freenode

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN24@Freenode

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN27@Freenode:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+32], rax

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+40], rax

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+48], rax
$LN11@Freenode:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	mov	rcx, rbx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 384  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN24@Freenode:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN58@Freenode:
??$_Freenode@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU01@@Z ENDP ; std::_Tree_node<std::vector<int,std::allocator<int> >,void *>::_Freenode<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *>, COMDAT

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
;	COMDAT ??$exchange@PEAU?$_Tree_node@HPEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@0@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$_Tree_node@HPEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@0@Z PROC ; std::exchange<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>, COMDAT

; 755  :     // assign _New_val to _Val, return previous _Val
; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 758  :     return _Old_val;
; 759  : }

	ret	0
??$exchange@PEAU?$_Tree_node@HPEAX@std@@AEAPEAU12@@std@@YAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@0@Z ENDP ; std::exchange<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU01@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
??$_Freenode@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU01@@Z PROC ; std::_Tree_node<int,void *>::_Freenode<std::allocator<std::_Tree_node<int,void *> > >, COMDAT

; 380  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

	mov	rcx, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	jmp	??3@YAXPEAX_K@Z				; operator delete
??$_Freenode@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@?$_Tree_node@HPEAX@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU01@@Z ENDP ; std::_Tree_node<int,void *>::_Freenode<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAU?$_Tree_node@HPEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@HPEAX@0@@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAU?$_Tree_node@HPEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@HPEAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>, COMDAT

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	ret	0
??$_Destroy_in_place@PEAU?$_Tree_node@HPEAX@std@@@std@@YAXAEAPEAU?$_Tree_node@HPEAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Construct_in_place@V?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAXAEAV?$vector@HV?$allocator@H@std@@@0@$$QEAV10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@V?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAXAEAV?$vector@HV?$allocator@H@std@@@0@$$QEAV10@@Z PROC ; std::_Construct_in_place<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > >, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [rdx+16]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]
	mov	rax, QWORD PTR [rdx]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 267  : }

	ret	0
??$_Construct_in_place@V?$vector@HV?$allocator@H@std@@@std@@V12@@std@@YAXAEAV?$vector@HV?$allocator@H@std@@@0@$$QEAV10@@Z ENDP ; std::_Construct_in_place<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$construct@V?$vector@HV?$allocator@H@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@$$QEAV31@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@V?$vector@HV?$allocator@H@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@$$QEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > >, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r9, QWORD PTR [r8+16]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8+8]
	mov	rax, QWORD PTR [r8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+16], r10
	mov	QWORD PTR [r8+8], r10
	mov	QWORD PTR [r8], r10
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rdx], rax
	mov	QWORD PTR [rdx+8], rcx
	mov	QWORD PTR [rdx+16], r9
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 679  :     }

	ret	0
??$construct@V?$vector@HV?$allocator@H@std@@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@$$QEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > * const &>, COMDAT

; 980  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 981  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 982  :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 983  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 984  :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 985  :     } else {
; 986  :         return static_cast<_Iter&&>(_It);
; 987  :     }
; 988  : }

	ret	0
??$_Get_unwrapped@AEBQEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TAEBQEAV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::vector<int,std::allocator<int> > *,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 1902 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN37:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	r10, rdx

; 1903 :     // move [_First, _Last) to raw _Dest, using _Al
; 1904 :     // note: only called internally from elsewhere in the STL
; 1905 :     using _Ptrval     = typename _Alloc::value_type*;
; 1906 :     auto _UFirst      = _Get_unwrapped(_First);
; 1907 :     const auto _ULast = _Get_unwrapped(_Last);
; 1908 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1909 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1910 : #if _HAS_CXX20
; 1911 :         if (!_STD is_constant_evaluated())
; 1912 : #endif // _HAS_CXX20
; 1913 :         {
; 1914 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1915 :             return _Dest + (_ULast - _UFirst);
; 1916 :         }
; 1917 :     }
; 1918 : 
; 1919 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1920 :     for (; _UFirst != _ULast; ++_UFirst) {

	cmp	rcx, rdx
	je	SHORT $LN3@Uninitiali

; 1902 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	mov	rax, rbx
	lea	r8, QWORD PTR [rcx+8]
	sub	rax, rcx
	xor	r11d, r11d
	npad	2
$LL4@Uninitiali:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rcx, QWORD PTR [r8-8]
	mov	r9, QWORD PTR [r8+8]
	mov	rdx, QWORD PTR [r8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [r8+8], r11
	mov	QWORD PTR [r8], r11
	mov	QWORD PTR [r8-8], r11
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rbx], rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1778 :         ++_Last;

	add	rbx, 24
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r8+rax], rdx
	mov	QWORD PTR [rax+r8+8], r9
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1778 :         ++_Last;

	lea	r8, QWORD PTR [r8+24]

; 1903 :     // move [_First, _Last) to raw _Dest, using _Al
; 1904 :     // note: only called internally from elsewhere in the STL
; 1905 :     using _Ptrval     = typename _Alloc::value_type*;
; 1906 :     auto _UFirst      = _Get_unwrapped(_First);
; 1907 :     const auto _ULast = _Get_unwrapped(_Last);
; 1908 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1909 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1910 : #if _HAS_CXX20
; 1911 :         if (!_STD is_constant_evaluated())
; 1912 : #endif // _HAS_CXX20
; 1913 :         {
; 1914 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1915 :             return _Dest + (_ULast - _UFirst);
; 1916 :         }
; 1917 :     }
; 1918 : 
; 1919 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1920 :     for (; _UFirst != _ULast; ++_UFirst) {

	lea	rcx, QWORD PTR [r8-8]
	cmp	rcx, r10
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1772 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, rbx
	mov	rcx, rbx
	call	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >

; 1921 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1922 :     }
; 1923 : 
; 1924 :     return _Backout._Release();

	mov	rax, rbx

; 1925 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninitialized_move@PEAV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@0PEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::vector<int,std::allocator<int> > *,std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAH@std@@YA?A_TAEBQEAH@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAH@std@@YA?A_TAEBQEAH@Z PROC	; std::_Get_unwrapped<int * const &>, COMDAT

; 980  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 981  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 982  :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 983  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 984  :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 985  :     } else {
; 986  :         return static_cast<_Iter&&>(_It);
; 987  :     }
; 988  : }

	ret	0
??$_Get_unwrapped@AEBQEAH@std@@YA?A_TAEBQEAH@Z ENDP	; std::_Get_unwrapped<int * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAHV?$allocator@H@std@@@std@@YAPEAHQEAH0PEAHAEAV?$allocator@H@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAHV?$allocator@H@std@@@std@@YAPEAHQEAH0PEAHAEAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,std::allocator<int> >, COMDAT

; 1902 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN18:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1915 :             return _Dest + (_ULast - _UFirst);

	sar	rbx, 2
	lea	rax, QWORD PTR [rdi+rbx*4]

; 1916 :         }
; 1917 :     }
; 1918 : 
; 1919 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1920 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1921 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1922 :     }
; 1923 : 
; 1924 :     return _Backout._Release();
; 1925 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEAHV?$allocator@H@std@@@std@@YAPEAHQEAH0PEAHAEAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Zero_range@PEAH@std@@YAPEAHQEAH0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
??$_Zero_range@PEAH@std@@YAPEAHQEAH0@Z PROC		; std::_Zero_range<int *>, COMDAT

; 1992 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1993 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
; 1994 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
; 1995 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdx
	mov	rbx, rdx
	sub	r8, rcx
	xor	edx, edx
	call	memset

; 1996 :     return _Last;

	mov	rax, rbx

; 1997 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Zero_range@PEAH@std@@YAPEAHQEAH0@Z ENDP		; std::_Zero_range<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<>, COMDAT

; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	mov	DWORD PTR [rax], edx

; 1777 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
; 1778 :         ++_Last;

	add	QWORD PTR [rcx+8], 4

; 1779 :     }

	ret	0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Emplace_back@AEBH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAXAEBH@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEBH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAXAEBH@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>, COMDAT

; 1777 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax

; 1778 :         ++_Last;

	add	QWORD PTR [rcx+8], 4

; 1779 :     }

	ret	0
??$_Emplace_back@AEBH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAXAEBH@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Copy_memmove@PEBHPEAH@std@@YAPEAHPEBH0PEAH@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEBHPEAH@std@@YAPEAHPEBH0PEAH@Z PROC	; std::_Copy_memmove<int const *,int *>, COMDAT

; 4428 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4429 :     auto _FirstPtr              = _To_address(_First);
; 4430 :     auto _LastPtr               = _To_address(_Last);
; 4431 :     auto _DestPtr               = _To_address(_Dest);
; 4432 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4433 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4434 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4437 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4438 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4439 :     } else {
; 4440 :         return _Dest + (_LastPtr - _FirstPtr);
; 4441 :     }
; 4442 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEBHPEAH@std@@YAPEAHPEBH0PEAH@Z ENDP	; std::_Copy_memmove<int const *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_To_address@PEBH@std@@YA?A_PAEBQEBH@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEBH@std@@YA?A_PAEBQEBH@Z PROC		; std::_To_address<int const *>, COMDAT

; 4307 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4308 :     return _Val;

	mov	rax, QWORD PTR [rcx]

; 4309 : }

	ret	0
??$_To_address@PEBH@std@@YA?A_PAEBQEBH@Z ENDP		; std::_To_address<int const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Construct_in_place@HAEBH@std@@YAXAEAHAEBH@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@HAEBH@std@@YAXAEAHAEBH@Z PROC	; std::_Construct_in_place<int,int const &>, COMDAT

; 259  : #if _HAS_CXX20
; 260  :     if (_STD is_constant_evaluated()) {
; 261  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 262  :     } else
; 263  : #endif // _HAS_CXX20
; 264  :     {
; 265  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax

; 266  :     }
; 267  : }

	ret	0
??$_Construct_in_place@HAEBH@std@@YAXAEAHAEBH@Z ENDP	; std::_Construct_in_place<int,int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$construct@HAEBH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAHAEBH@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@HAEBH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAHAEBH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>, COMDAT

; 671  : #if _HAS_CXX20
; 672  :         if (_STD is_constant_evaluated()) {
; 673  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 674  :         } else
; 675  : #endif // _HAS_CXX20
; 676  :         {
; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax

; 678  :         }
; 679  :     }

	ret	0
??$construct@HAEBH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAHAEBH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$move@AEAPEAH@std@@YA$$QEAPEAHAEAPEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAPEAH@std@@YA$$QEAPEAHAEAPEAH@Z PROC		; std::move<int * &>, COMDAT

; 1450 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1451 : }

	ret	0
??$move@AEAPEAH@std@@YA$$QEAPEAHAEAPEAH@Z ENDP		; std::move<int * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z PROC	; std::_Copy_memmove<int *,int *>, COMDAT

; 4428 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 4429 :     auto _FirstPtr              = _To_address(_First);
; 4430 :     auto _LastPtr               = _To_address(_Last);
; 4431 :     auto _DestPtr               = _To_address(_Dest);
; 4432 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4433 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4434 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4437 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4438 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4439 :     } else {
; 4440 :         return _Dest + (_LastPtr - _FirstPtr);
; 4441 :     }
; 4442 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEAHPEAH@std@@YAPEAHPEAH00@Z ENDP	; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Emplace_back@AEAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAXAEAH@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@AEAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAXAEAH@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>, COMDAT

; 1777 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax

; 1778 :         ++_Last;

	add	QWORD PTR [rcx+8], 4

; 1779 :     }

	ret	0
??$_Emplace_back@AEAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAXAEAH@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Is_all_bits_zero@H@std@@YA_NAEBH@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Is_all_bits_zero@H@std@@YA_NAEBH@Z PROC		; std::_Is_all_bits_zero<int>, COMDAT

; 4924 :     // checks if scalar type has all bits set to zero
; 4925 :     _STL_INTERNAL_STATIC_ASSERT(is_scalar_v<_Ty> && !is_member_pointer_v<_Ty>);
; 4926 :     if constexpr (is_same_v<_Ty, nullptr_t>) {
; 4927 :         return true;
; 4928 :     } else {
; 4929 :         constexpr _Ty _Zero{};
; 4930 :         return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

	cmp	DWORD PTR [rcx], 0
	sete	al

; 4931 :     }
; 4932 : }

	ret	0
??$_Is_all_bits_zero@H@std@@YA_NAEBH@Z ENDP		; std::_Is_all_bits_zero<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Fill_zero_memset@PEAH@std@@YAXPEAH_K@Z
_TEXT	SEGMENT
_Dest$ = 8
_Count$dead$ = 16
??$_Fill_zero_memset@PEAH@std@@YAXPEAH_K@Z PROC		; std::_Fill_zero_memset<int *>, COMDAT

; 4919 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

	xor	edx, edx
	mov	r8d, 200				; 000000c8H
	jmp	memset
??$_Fill_zero_memset@PEAH@std@@YAXPEAH_K@Z ENDP		; std::_Fill_zero_memset<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAAEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@0@AEBU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAAEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@0@AEBU10@@Z PROC ; std::forward<std::less<std::vector<int,std::allocator<int> > > const &>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@AEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAAEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@0@AEBU10@@Z ENDP ; std::forward<std::less<std::vector<int,std::allocator<int> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QEAU_Zero_then_variadic_args_t@0@AEAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@AEBU?$less@H@std@@@std@@YAAEBU?$less@H@0@AEBU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBU?$less@H@std@@@std@@YAAEBU?$less@H@0@AEBU10@@Z PROC ; std::forward<std::less<int> const &>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@AEBU?$less@H@std@@@std@@YAAEBU?$less@H@0@AEBU10@@Z ENDP ; std::forward<std::less<int> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 127  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN17:
	sub	rsp, 40					; 00000028H

; 128  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 130  :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN16@Allocate_m

; 77   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 132  :     }
; 133  : 
; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN7@Allocate_m

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 138  : 
; 139  : #ifdef _DEBUG
; 140  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 141  : #endif // _DEBUG
; 142  :     return _Ptr;
; 143  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@Allocate_m:

; 132  :     }
; 133  : 
; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN16@Allocate_m:

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN14@Allocate_m:
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *,std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * const &>, COMDAT

; 259  : #if _HAS_CXX20
; 260  :     if (_STD is_constant_evaluated()) {
; 261  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 262  :     } else
; 263  : #endif // _HAS_CXX20
; 264  :     {
; 265  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 266  :     }
; 267  : }

	ret	0
??$_Construct_in_place@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *,std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_Tree_node@HPEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@HPEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_Tree_node@HPEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@HPEAX@0@AEBQEAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>, COMDAT

; 259  : #if _HAS_CXX20
; 260  :     if (_STD is_constant_evaluated()) {
; 261  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 262  :     } else
; 263  : #endif // _HAS_CXX20
; 264  :     {
; 265  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 266  :     }
; 267  : }

	ret	0
??$_Construct_in_place@PEAU?$_Tree_node@HPEAX@std@@AEBQEAU12@@std@@YAXAEAPEAU?$_Tree_node@HPEAX@0@AEBQEAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$dead$ = 8
??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<56>, COMDAT

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {
; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	mov	eax, 56					; 00000038H

; 66   : }

	ret	0
??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<56>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Refancy@PEAV?$vector@HV?$allocator@H@std@@@std@@$0A@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEAV?$vector@HV?$allocator@H@std@@@std@@$0A@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@@Z PROC ; std::_Refancy<std::vector<int,std::allocator<int> > *,0>, COMDAT

; 287  :     return _Ptr;

	mov	rax, rcx

; 288  : }

	ret	0
??$_Refancy@PEAV?$vector@HV?$allocator@H@std@@@std@@$0A@@std@@YAPEAV?$vector@HV?$allocator@H@std@@@0@PEAV10@@Z ENDP ; std::_Refancy<std::vector<int,std::allocator<int> > *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$dead$ = 8
??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<32>, COMDAT

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {
; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	mov	eax, 32					; 00000020H

; 66   : }

	ret	0
??$_Get_size_of_n@$0CA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<24>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
	sub	rsp, 40					; 00000028H

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	rcx, rax
	ja	SHORT $LN6@Get_size_o

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	lea	rax, QWORD PTR [rcx+rcx*2]
	shl	rax, 3

; 66   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Get_size_o:

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN4@Get_size_o:
??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<24>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$addressof@$$CBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEBV?$vector@HV?$allocator@H@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEBV?$vector@HV?$allocator@H@std@@@0@AEBV10@@Z PROC ; std::addressof<std::vector<int,std::allocator<int> > const >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 282  : }

	ret	0
??$addressof@$$CBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEBV?$vector@HV?$allocator@H@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::vector<int,std::allocator<int> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@H@std@@@std@@YAXAEAV?$allocator@H@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@H@std@@@std@@YAXAEAV?$allocator@H@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<int> >, COMDAT

; 1037 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1038 :         _Left = _Right;
; 1039 :     }
; 1040 : }

	ret	0
??$_Pocca@V?$allocator@H@std@@@std@@YAXAEAV?$allocator@H@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z
_TEXT	SEGMENT
this$ = 80
_First$ = 88
_Newsize$ = 96
??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z PROC ; std::vector<int,std::allocator<int> >::_Assign_counted_range<int *>, COMDAT

; 1379 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

$LN68:
	push	rbx
	push	rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1380 :         // assign elements from counted range _First + [0, _Newsize)
; 1381 :         auto& _Al         = _Getal();
; 1382 :         auto& _My_data    = _Mypair._Myval2;
; 1383 :         pointer& _Myfirst = _My_data._Myfirst;
; 1384 :         pointer& _Mylast  = _My_data._Mylast;
; 1385 :         pointer& _Myend   = _My_data._Myend;
; 1386 : 
; 1387 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1388 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1389 : 
; 1390 :         _My_data._Orphan_all();
; 1391 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

	mov	rdi, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rax, QWORD PTR [rcx+16]
	mov	r15, rdx
	sub	rax, rdi
	mov	r14, rcx
	sar	rax, 2

; 1392 :         if (_Newsize > _Oldcapacity) {

	cmp	r8, rax
	jbe	SHORT $LN5@Assign_cou

; 1393 :             _Clear_and_reserve_geometric(_Newsize);

	mov	rdx, r8
	call	?_Clear_and_reserve_geometric@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Clear_and_reserve_geometric

; 1394 :             if constexpr (_Nothrow_construct) {
; 1395 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);

	mov	rdi, QWORD PTR [r14]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rbp*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	mov	rdx, r15
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1401 :             return;

	jmp	SHORT $LN65@Assign_cou
$LN5@Assign_cou:
	mov	QWORD PTR [rsp+104], rsi

; 1402 :         }
; 1403 : 
; 1404 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rsi, QWORD PTR [rcx+8]

; 1405 :         if (_Newsize > _Oldsize) {

	mov	rcx, rdi
	sub	rsi, rdi
	sar	rsi, 2
	cmp	rbp, rsi
	jbe	SHORT $LN6@Assign_cou
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rsi*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1426 :                 _Mylast = _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

	mov	rdi, QWORD PTR [r14+8]
	lea	rdx, QWORD PTR [rbx+r15]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	sub	rbp, rsi

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, rdi

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rbp*4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1432 :         } else {

	jmp	SHORT $LN64@Assign_cou
$LN6@Assign_cou:

; 1433 :             const pointer _Newlast = _Myfirst + _Newsize;

	lea	rbx, QWORD PTR [r8*4]
$LN64@Assign_cou:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove
	mov	rsi, QWORD PTR [rsp+104]
$LN65@Assign_cou:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 1439 :     }

	lea	rax, QWORD PTR [rbx+rdi]
	mov	QWORD PTR [r14+8], rax
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
??$_Assign_counted_range@PEAH@?$vector@HV?$allocator@H@std@@@std@@AEAAXPEAH_K@Z ENDP ; std::vector<int,std::allocator<int> >::_Assign_counted_range<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAX_K@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAX_K@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release, COMDAT

; 1782 :         _First = _Last;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx], rax

; 1783 :         return _Last;
; 1784 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAPEAV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 1772 :         _Destroy_range(_First, _Last, _Al);

	mov	rdx, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR [rcx]
	jmp	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPEAV?$vector@HV?$allocator@H@std@@@0@QEAV10@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 1766 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@PEAV?$vector@HV?$allocator@H@std@@@1@AEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >, COMDAT

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??0?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@QEAA@XZ PROC ; std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >, COMDAT

; 935  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAA@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Tree_val<std::_Tree_simple_types<int> >, COMDAT

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAA@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Tree_val<std::_Tree_simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??0?$allocator@U?$_Tree_node@HPEAX@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$_Tree_node@HPEAX@std@@@std@@QEAA@XZ PROC ; std::allocator<std::_Tree_node<int,void *> >::allocator<std::_Tree_node<int,void *> >, COMDAT

; 935  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@U?$_Tree_node@HPEAX@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::_Tree_node<int,void *> >::allocator<std::_Tree_node<int,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QEBAPEBHXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QEBAPEBHXZ PROC ; std::vector<int,std::allocator<int> >::_Unchecked_end, COMDAT

; 1857 :         return _Mypair._Myval2._Mylast;

	mov	rax, QWORD PTR [rcx+8]

; 1858 :     }

	ret	0
?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QEBAPEBHXZ ENDP ; std::vector<int,std::allocator<int> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QEBAPEBHXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QEBAPEBHXZ PROC ; std::vector<int,std::allocator<int> >::_Unchecked_begin, COMDAT

; 1849 :         return _Mypair._Myval2._Myfirst;

	mov	rax, QWORD PTR [rcx]

; 1850 :     }

	ret	0
?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QEBAPEBHXZ ENDP ; std::vector<int,std::allocator<int> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@HV?$allocator@H@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rdx]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r10d, r10d
	mov	r9, QWORD PTR [rdx+16]

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r10
	mov	QWORD PTR [rdx+8], r10
	mov	QWORD PTR [rdx], r10
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rax

; 699  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 700  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 701  :     }

	mov	rax, rcx

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9

; 699  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 700  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 701  :     }

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z
_TEXT	SEGMENT
$T2 = 32
_Loc$ = 32
_Loc$1$ = 64
$T9 = 64
$T1 = 80
this$ = 144
_Hint$ = 152
<_Vals_0>$ = 160
??$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Emplace_hint<int &>, COMDAT

; 1038 :     _Nodeptr _Emplace_hint(const _Nodeptr _Hint, _Valtys&&... _Vals) {

$LN83:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rsi, r8
	mov	rdi, rcx

; 1039 :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 1040 :         const auto _Scary             = _Get_scary();
; 1041 :         _Tree_find_hint_result<_Nodeptr> _Loc;
; 1042 :         _Nodeptr _Inserted;
; 1043 :         if constexpr (!_Multi && _In_place_key_extractor::_Extractable) {
; 1044 :             _Loc = _Find_hint(_Hint, _In_place_key_extractor::_Extract(_Vals...));

	mov	r9, r8
	mov	r8, rdx
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_hint<int>
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR _Loc$1$[rsp], xmm0
	movups	XMMWORD PTR _Loc$[rsp], xmm0
	movsd	xmm0, QWORD PTR [rax+16]
	movsd	QWORD PTR _Loc$[rsp+16], xmm0

; 1045 :             if (_Loc._Duplicate) {

	cmp	BYTE PTR _Loc$[rsp+16], 0
	je	SHORT $LN2@Emplace_hi

; 1046 :                 return _Loc._Location._Parent;

	mov	rax, QWORD PTR _Loc$[rsp]

; 1067 :     }

	add	rsp, 112				; 00000070H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN2@Emplace_hi:

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	QWORD PTR [rdi+8], rax
	je	SHORT $LN81@Emplace_hi

; 1047 :             }
; 1048 : 
; 1049 :             _Check_grow_by_1();
; 1050 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

	mov	rbx, QWORD PTR [rdi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR $T2[rsp], rdi

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T2[rsp+8], 0

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	npad	1
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	edx, DWORD PTR [rsi]
	mov	DWORD PTR [rax+28], edx

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [rax], rbx

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [rax+8], rbx

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [rax+16], rbx

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [rax+24], 0

; 1051 :             // nothrow hereafter
; 1052 :         } else {
; 1053 :             _Tree_temp_node<_Alnode> _Newnode(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...);
; 1054 :             _Loc = _Find_hint(_Hint, _Traits::_Kfn(_Newnode._Ptr->_Myval));
; 1055 :             if constexpr (!_Multi) {
; 1056 :                 if (_Loc._Duplicate) {
; 1057 :                     return _Loc._Location._Parent;
; 1058 :                 }
; 1059 :             }
; 1060 : 
; 1061 :             _Check_grow_by_1();
; 1062 :             // nothrow hereafter
; 1063 :             _Inserted = _Newnode._Release();
; 1064 :         }
; 1065 : 
; 1066 :         return _Scary->_Insert_node(_Loc._Location, _Inserted);

	movups	xmm0, XMMWORD PTR _Loc$1$[rsp]
	movaps	XMMWORD PTR $T9[rsp], xmm0
	mov	r8, rax
	lea	rdx, QWORD PTR $T9[rsp]
	mov	rcx, rdi
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@U?$_Tree_id@PEAU?$_Tree_node@HPEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Insert_node

; 1067 :     }

	add	rsp, 112				; 00000070H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN81@Emplace_hi:

; 1630 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN79@Emplace_hi:
??$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Emplace_hint<int &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
_Loc$ = 32
_Loc$1$ = 64
$T9 = 64
$T1 = 80
this$ = 144
_Hint$ = 152
<_Vals_0>$ = 160
?dtor$2@?0???$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z@4HA PROC ; `std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Emplace_hint<int &>'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
?dtor$2@?0???$_Emplace_hint@AEAH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@HPEAX@1@QEAU21@AEAH@Z@4HA ENDP ; `std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Emplace_hint<int &>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
$T2 = 32
_Loc$ = 32
_Loc$1$ = 64
$T10 = 64
$T1 = 80
this$ = 144
_Hint$ = 152
<_Vals_0>$ = 160
??$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Emplace_hint<std::vector<int,std::allocator<int> > &>, COMDAT

; 1038 :     _Nodeptr _Emplace_hint(const _Nodeptr _Hint, _Valtys&&... _Vals) {

$LN116:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	rbp, r8
	mov	rsi, rcx

; 1039 :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 1040 :         const auto _Scary             = _Get_scary();
; 1041 :         _Tree_find_hint_result<_Nodeptr> _Loc;
; 1042 :         _Nodeptr _Inserted;
; 1043 :         if constexpr (!_Multi && _In_place_key_extractor::_Extractable) {
; 1044 :             _Loc = _Find_hint(_Hint, _In_place_key_extractor::_Extract(_Vals...));

	mov	r9, r8
	mov	r8, rdx
	lea	rdx, QWORD PTR $T1[rsp]
	call	??$_Find_hint@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Find_hint<std::vector<int,std::allocator<int> > >
	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR _Loc$1$[rsp], xmm0
	movups	XMMWORD PTR _Loc$[rsp], xmm0
	movsd	xmm0, QWORD PTR [rax+16]
	movsd	QWORD PTR _Loc$[rsp+16], xmm0

; 1045 :             if (_Loc._Duplicate) {

	cmp	BYTE PTR _Loc$[rsp+16], 0
	je	SHORT $LN2@Emplace_hi

; 1046 :                 return _Loc._Location._Parent;

	mov	rax, QWORD PTR _Loc$[rsp]

; 1067 :     }

	mov	rbx, QWORD PTR [rsp+168]
	add	rsp, 112				; 00000070H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN2@Emplace_hi:

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 329406144173384850			; 0492492492492492H
	cmp	QWORD PTR [rsi+8], rax
	je	SHORT $LN114@Emplace_hi

; 1047 :             }
; 1048 : 
; 1049 :             _Check_grow_by_1();
; 1050 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

	mov	rbx, QWORD PTR [rsi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR $T2[rsp], rsi

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR $T2[rsp+8], 0

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
	mov	QWORD PTR $T2[rsp+8], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rcx, QWORD PTR [rax+32]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbp
	call	??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	QWORD PTR [rdi], rbx

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	QWORD PTR [rdi+8], rbx

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	QWORD PTR [rdi+16], rbx

; 811  :         this->_Ptr->_Color = _Red;

	mov	WORD PTR [rdi+24], 0

; 1051 :             // nothrow hereafter
; 1052 :         } else {
; 1053 :             _Tree_temp_node<_Alnode> _Newnode(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...);
; 1054 :             _Loc = _Find_hint(_Hint, _Traits::_Kfn(_Newnode._Ptr->_Myval));
; 1055 :             if constexpr (!_Multi) {
; 1056 :                 if (_Loc._Duplicate) {
; 1057 :                     return _Loc._Location._Parent;
; 1058 :                 }
; 1059 :             }
; 1060 : 
; 1061 :             _Check_grow_by_1();
; 1062 :             // nothrow hereafter
; 1063 :             _Inserted = _Newnode._Release();
; 1064 :         }
; 1065 : 
; 1066 :         return _Scary->_Insert_node(_Loc._Location, _Inserted);

	movups	xmm0, XMMWORD PTR _Loc$1$[rsp]
	movaps	XMMWORD PTR $T10[rsp], xmm0
	mov	r8, rdi
	lea	rdx, QWORD PTR $T10[rsp]
	mov	rcx, rsi
	call	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@QEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Insert_node

; 1067 :     }

	mov	rbx, QWORD PTR [rsp+168]
	add	rsp, 112				; 00000070H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN114@Emplace_hi:

; 1630 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN112@Emplace_hi:
??$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Emplace_hint<std::vector<int,std::allocator<int> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
_Loc$ = 32
_Loc$1$ = 64
$T10 = 64
$T1 = 80
this$ = 144
_Hint$ = 152
<_Vals_0>$ = 160
?dtor$2@?0???$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z@4HA PROC ; `std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Emplace_hint<std::vector<int,std::allocator<int> > &>'::`1'::dtor$2
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
?dtor$2@?0???$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z@4HA ENDP ; `std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Emplace_hint<std::vector<int,std::allocator<int> > &>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
_Loc$ = 32
_Loc$1$ = 64
$T10 = 64
$T1 = 80
this$ = 144
_Hint$ = 152
<_Vals_0>$ = 160
?dtor$1@?0???$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z@4HA PROC ; `std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Emplace_hint<std::vector<int,std::allocator<int> > &>'::`1'::dtor$1
	lea	rcx, QWORD PTR $T2[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0???$_Emplace_hint@AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@QEAU21@AEAV?$vector@HV?$allocator@H@std@@@1@@Z@4HA ENDP ; `std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Emplace_hint<std::vector<int,std::allocator<int> > &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Emplace_back@AEBV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEBV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
<_Vals_0>$ = 56
??$_Emplace_back@AEBV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEBV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>, COMDAT

; 1776 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR [rcx+8]
	call	??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >

; 1777 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
; 1778 :         ++_Last;

	add	QWORD PTR [rbx+8], 24

; 1779 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Emplace_back@AEBV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXAEBV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$equal@PEBHPEBH@std@@YA_NQEBH00@Z
_TEXT	SEGMENT
__$ArrayPad$ = 32
_First1$ = 64
_Last1$ = 72
_First2$ = 80
??$equal@PEBHPEBH@std@@YA_NQEBH00@Z PROC		; std::equal<int const *,int const *>, COMDAT

; 5192 : _NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {

$LN17:
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 5149 :     return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));

	sub	rdx, rcx

; 5192 : _NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {

	mov	rax, r8

; 5149 :     return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));

	mov	r8, rdx
	mov	rdx, rax
	call	memcmp

; 5172 :             return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;

	test	eax, eax
	sete	al

; 5193 :     // compare [_First1, _Last1) to [_First2, ...)
; 5194 :     return _STD equal(_First1, _Last1, _First2, equal_to<>{});
; 5195 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
??$equal@PEBHPEBH@std@@YA_NQEBH00@Z ENDP		; std::equal<int const *,int const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::destroy<std::vector<int,std::allocator<int> > >, COMDAT

; 682  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdx]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 682  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	mov	rbx, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN9@destroy

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rdx+16]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN25@destroy

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN22@destroy

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN25@destroy:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+8], rax

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+16], rax
$LN9@destroy:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 688  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN22@destroy:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN35@destroy:
??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::destroy<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$addressof@H@std@@YAPEAHAEAH@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@H@std@@YAPEAHAEAH@Z PROC			; std::addressof<int>, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 282  : }

	ret	0
??$addressof@H@std@@YAPEAHAEAH@Z ENDP			; std::addressof<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$destroy@H@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@QEAH@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$dead$ = 16
??$destroy@H@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@QEAH@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::destroy<int>, COMDAT

; 683  : #if _HAS_CXX20
; 684  :         _STD destroy_at(_Ptr);
; 685  : #else // _HAS_CXX20
; 686  :         _Ptr->~_Uty();
; 687  : #endif // _HAS_CXX20
; 688  :     }

	ret	0
??$destroy@H@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@QEAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::destroy<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Voidify_iter@PEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEAXPEAV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEAXPEAV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>, COMDAT

; 235  :     if constexpr (is_pointer_v<_Iter>) {
; 236  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, rcx

; 237  :     } else {
; 238  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 239  :     }
; 240  : }

	ret	0
??$_Voidify_iter@PEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPEAXPEAV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Emplace_back@V?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@V?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > >, COMDAT

; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	r10, QWORD PTR [rcx+8]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	xor	r11d, r11d
	mov	r9, QWORD PTR [rdx+16]

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	r8, QWORD PTR [rdx+8]
	mov	rax, QWORD PTR [rdx]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rdx+16], r11
	mov	QWORD PTR [rdx+8], r11
	mov	QWORD PTR [rdx], r11
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [r10], rax
	mov	QWORD PTR [r10+8], r8
	mov	QWORD PTR [r10+16], r9
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1778 :         ++_Last;

	add	QWORD PTR [rcx+8], 24

; 1779 :     }

	ret	0
??$_Emplace_back@V?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAX$$QEAV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAX$$QEAH@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAX$$QEAH@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int>, COMDAT

; 1777 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	r8, QWORD PTR [rcx+8]
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax

; 1778 :         ++_Last;

	add	QWORD PTR [rcx+8], 4

; 1779 :     }

	ret	0
??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QEAAX$$QEAH@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$construct@H$$V@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
??$construct@H$$V@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int>, COMDAT

; 671  : #if _HAS_CXX20
; 672  :         if (_STD is_constant_evaluated()) {
; 673  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 674  :         } else
; 675  : #endif // _HAS_CXX20
; 676  :         {
; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	xor	eax, eax
	mov	DWORD PTR [rdx], eax

; 678  :         }
; 679  :     }

	ret	0
??$construct@H$$V@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Voidify_iter@PEAH@std@@YAPEAXPEAH@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAH@std@@YAPEAXPEAH@Z PROC		; std::_Voidify_iter<int *>, COMDAT

; 235  :     if constexpr (is_pointer_v<_Iter>) {
; 236  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, rcx

; 237  :     } else {
; 238  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 239  :     }
; 240  : }

	ret	0
??$_Voidify_iter@PEAH@std@@YAPEAXPEAH@Z ENDP		; std::_Voidify_iter<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@AEAH@std@@YAAEAHAEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAH@std@@YAAEAHAEAH@Z PROC			; std::forward<int &>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@AEAH@std@@YAAEAHAEAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$construct@HAEAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAHAEAH@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@HAEAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAHAEAH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>, COMDAT

; 671  : #if _HAS_CXX20
; 672  :         if (_STD is_constant_evaluated()) {
; 673  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 674  :         } else
; 675  : #endif // _HAS_CXX20
; 676  :         {
; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax

; 678  :         }
; 679  :     }

	ret	0
??$construct@HAEAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAHAEAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$addressof@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *>, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 282  : }

	ret	0
??$addressof@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Voidify_iter@PEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAPEAXPEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAPEAXPEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@@Z PROC ; std::_Voidify_iter<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * *>, COMDAT

; 235  :     if constexpr (is_pointer_v<_Iter>) {
; 236  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, rcx

; 237  :     } else {
; 238  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 239  :     }
; 240  : }

	ret	0
??$_Voidify_iter@PEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAPEAXPEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@@Z ENDP ; std::_Voidify_iter<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * const &>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@AEBQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAAEBQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$addressof@PEAU?$_Tree_node@HPEAX@std@@@std@@YAPEAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_Tree_node@HPEAX@std@@@std@@YAPEAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_Tree_node<int,void *> *>, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 282  : }

	ret	0
??$addressof@PEAU?$_Tree_node@HPEAX@std@@@std@@YAPEAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_Tree_node<int,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Voidify_iter@PEAPEAU?$_Tree_node@HPEAX@std@@@std@@YAPEAXPEAPEAU?$_Tree_node@HPEAX@0@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAPEAU?$_Tree_node@HPEAX@std@@@std@@YAPEAXPEAPEAU?$_Tree_node@HPEAX@0@@Z PROC ; std::_Voidify_iter<std::_Tree_node<int,void *> * *>, COMDAT

; 235  :     if constexpr (is_pointer_v<_Iter>) {
; 236  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, rcx

; 237  :     } else {
; 238  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 239  :     }
; 240  : }

	ret	0
??$_Voidify_iter@PEAPEAU?$_Tree_node@HPEAX@std@@@std@@YAPEAXPEAPEAU?$_Tree_node@HPEAX@0@@Z ENDP ; std::_Voidify_iter<std::_Tree_node<int,void *> * *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@AEBQEAU?$_Tree_node@HPEAX@std@@@std@@YAAEBQEAU?$_Tree_node@HPEAX@0@AEBQEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAU?$_Tree_node@HPEAX@std@@@std@@YAAEBQEAU?$_Tree_node@HPEAX@0@AEBQEAU10@@Z PROC ; std::forward<std::_Tree_node<int,void *> * const &>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@AEBQEAU?$_Tree_node@HPEAX@std@@@std@@YAAEBQEAU?$_Tree_node@HPEAX@0@AEBQEAU10@@Z ENDP ; std::forward<std::_Tree_node<int,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$_Uninitialized_copy_n@PEAHV?$allocator@H@std@@@std@@YAPEAHPEAH_K0AEAV?$allocator@H@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy_n@PEAHV?$allocator@H@std@@@std@@YAPEAHPEAH_K0AEAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy_n<int *,std::allocator<int> >, COMDAT

; 1839 :     _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN20:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rdx*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1856 :             _Dest += _Count;

	lea	rax, QWORD PTR [rbx+rdi]

; 1857 :             return _Dest;
; 1858 :         }
; 1859 :     }
; 1860 : 
; 1861 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1862 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {
; 1863 :         _Backout._Emplace_back(*_UFirst);
; 1864 :     }
; 1865 : 
; 1866 :     return _Backout._Release();
; 1867 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_copy_n@PEAHV?$allocator@H@std@@@std@@YAPEAHPEAH_K0AEAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy_n<int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Copy_memmove_n@PEAHPEAH@std@@YAPEAHPEAH_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_memmove_n@PEAHPEAH@std@@YAPEAHPEAH_K0@Z PROC	; std::_Copy_memmove_n<int *,int *>, COMDAT

; 4445 : _OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Count, _OutCtgIt _Dest) {

$LN6:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rdx*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4437 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4438 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]

; 4447 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4448 :         return _Result;
; 4449 :     } else { // _Result is unused so the compiler can optimize it away
; 4450 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Count);
; 4451 :     }
; 4452 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove_n@PEAHPEAH@std@@YAPEAHPEAH_K0@Z ENDP	; std::_Copy_memmove_n<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Copy_n_unchecked4@PEAH_KPEAH@std@@YAPEAHPEAH_K0@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Dest$ = 64
??$_Copy_n_unchecked4@PEAH_KPEAH@std@@YAPEAHPEAH_K0@Z PROC ; std::_Copy_n_unchecked4<int *,unsigned __int64,int *>, COMDAT

; 4458 : _CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {

$LN11:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8

; 4446 :     const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);

	lea	rbx, QWORD PTR [rdx*4]

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 4437 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4438 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 4459 :     // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
; 4460 :     // note: has callers outside the copy family
; 4461 : #ifdef __cpp_lib_concepts
; 4462 :     _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
; 4463 : #endif // __cpp_lib_concepts
; 4464 : 
; 4465 :     if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
; 4466 : #if _HAS_CXX20
; 4467 :         if (!_STD is_constant_evaluated())
; 4468 : #endif // _HAS_CXX20
; 4469 :         {
; 4470 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
; 4471 :         }
; 4472 :     }
; 4473 : 
; 4474 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {
; 4475 :         *_Dest = *_First;
; 4476 :     }
; 4477 : 
; 4478 :     return _Dest;
; 4479 : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_n_unchecked4@PEAH_KPEAH@std@@YAPEAHPEAH_K0@Z ENDP ; std::_Copy_n_unchecked4<int *,unsigned __int64,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
;	COMDAT ??$exchange@PEAH$$T@std@@YAPEAHAEAPEAH$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAH$$T@std@@YAPEAHAEAPEAH$$QEA$$T@Z PROC	; std::exchange<int *,std::nullptr_t>, COMDAT

; 755  :     // assign _New_val to _Val, return previous _Val
; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 758  :     return _Old_val;
; 759  : }

	ret	0
??$exchange@PEAH$$T@std@@YAPEAHAEAPEAH$$QEA$$T@Z ENDP	; std::exchange<int *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$?0V?$allocator@H@std@@PEAHPEAHPEAH@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@H@1@$$QEAPEAH22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@H@std@@PEAHPEAHPEAH@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@H@1@$$QEAPEAH22@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int>,int *,int *,int *>, COMDAT

; 1497 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, QWORD PTR <_Val2_2>$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR <_Val2_1>$[rsp]
	mov	rdx, QWORD PTR [rax]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rcx], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1497 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx+8], rdx
	mov	QWORD PTR [rcx+16], r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1497 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	ret	0
??$?0V?$allocator@H@std@@PEAHPEAHPEAH@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@H@1@$$QEAPEAH22@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int>,int *,int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_set@V?$vector@HV?$allocator@H@std@@@std@@V12@@std@@SAAEBV?$vector@HV?$allocator@H@std@@@2@AEBV32@@Z
_TEXT	SEGMENT
_Val$ = 8
?_Extract@?$_In_place_key_extract_set@V?$vector@HV?$allocator@H@std@@@std@@V12@@std@@SAAEBV?$vector@HV?$allocator@H@std@@@2@AEBV32@@Z PROC ; std::_In_place_key_extract_set<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > >::_Extract, COMDAT

; 2063 :         return _Val;

	mov	rax, rcx

; 2064 :     }

	ret	0
?_Extract@?$_In_place_key_extract_set@V?$vector@HV?$allocator@H@std@@@std@@V12@@std@@SAAEBV?$vector@HV?$allocator@H@std@@@2@AEBV32@@Z ENDP ; std::_In_place_key_extract_set<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > >::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >, COMDAT

; 818  :     ~_Tree_temp_node() {

$LN69:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 819  :         if (this->_Ptr) {

	mov	rbx, QWORD PTR [rcx+8]
	mov	rdi, rcx
	test	rbx, rbx
	je	SHORT $LN38@Tree_temp_
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2042 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rbx+32]
	test	rcx, rcx
	je	SHORT $LN38@Tree_temp_

; 2043 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2044 :             _ASAN_VECTOR_REMOVE;
; 2045 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rdx, QWORD PTR [rbx+48]
	sub	rdx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 946  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -4

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN54@Tree_temp_

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN51@Tree_temp_

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN54@Tree_temp_:

; 255  :         ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2047 :             _Myfirst = nullptr;

	xor	eax, eax
	mov	QWORD PTR [rbx+32], rax

; 2048 :             _Mylast  = nullptr;

	mov	QWORD PTR [rbx+40], rax

; 2049 :             _Myend   = nullptr;

	mov	QWORD PTR [rbx+48], rax
$LN38@Tree_temp_:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1133 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rdi+8]
	test	rcx, rcx
	je	SHORT $LN14@Tree_temp_

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	call	??3@YAXPEAX_K@Z				; operator delete
$LN14@Tree_temp_:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 825  :     }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN51@Tree_temp_:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN66@Tree_temp_:
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Release, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx+8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx+8], 0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1125 :     }

	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_set@HH@std@@SAAEBHAEBH@Z
_TEXT	SEGMENT
_Val$ = 8
?_Extract@?$_In_place_key_extract_set@HH@std@@SAAEBHAEBH@Z PROC ; std::_In_place_key_extract_set<int,int>::_Extract, COMDAT

; 2063 :         return _Val;

	mov	rax, rcx

; 2064 :     }

	ret	0
?_Extract@?$_In_place_key_extract_set@HH@std@@SAAEBHAEBH@Z ENDP ; std::_In_place_key_extract_set<int,int>::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1133 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN14@Tree_temp_

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN14@Tree_temp_:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 825  :     }

	ret	0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::_Release, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility

; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR [rcx+8]

; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	QWORD PTR [rcx+8], 0
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1125 :     }

	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@QEAU32@@Z
_TEXT	SEGMENT
this$ = 8
_Loc$ = 16
_Newnode$ = 24
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@QEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Insert_node, COMDAT

; 647  :         ++_Mysize;

	inc	QWORD PTR [rcx+8]
	mov	r9, r8

; 648  :         const auto _Head  = _Myhead;

	mov	r11, QWORD PTR [rcx]
	mov	r10, rcx

; 649  :         _Newnode->_Parent = _Loc._Parent;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8+8], rax

; 650  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

	cmp	rax, r11
	jne	SHORT $LN5@Insert_nod

; 651  :             _Head->_Left     = _Newnode;

	mov	QWORD PTR [r11], r8

; 712  :         return _Newnode;
; 713  :     }

	mov	rax, r8
	mov	QWORD PTR [r11+8], r8
	mov	QWORD PTR [r11+16], r8
	mov	BYTE PTR [r8+24], 1
	ret	0
$LN5@Insert_nod:

; 652  :             _Head->_Parent   = _Newnode;
; 653  :             _Head->_Right    = _Newnode;
; 654  :             _Newnode->_Color = _Black; // the root is black
; 655  :             return _Newnode;
; 656  :         }
; 657  : 
; 658  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 659  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

	cmp	DWORD PTR [rdx+8], 0
	jne	SHORT $LN6@Insert_nod

; 660  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 661  :             _Loc._Parent->_Right = _Newnode;

	mov	QWORD PTR [rax+16], r9

; 662  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

	cmp	rax, QWORD PTR [r11+16]
	jne	SHORT $LN9@Insert_nod

; 663  :                 _Head->_Right = _Newnode;

	mov	QWORD PTR [r11+16], r9

; 664  :             }
; 665  :         } else { // add to left of _Loc._Parent

	jmp	SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 666  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 667  :             _Loc._Parent->_Left = _Newnode;

	mov	QWORD PTR [rax], r9

; 668  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

	cmp	rax, QWORD PTR [r11]
	jne	SHORT $LN9@Insert_nod

; 669  :                 _Head->_Left = _Newnode;

	mov	QWORD PTR [r11], r9
$LN9@Insert_nod:

; 670  :             }
; 671  :         }
; 672  : 
; 673  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

	mov	rcx, QWORD PTR [r8+8]
	mov	rax, r9
	cmp	BYTE PTR [rcx+24], 0
	jne	$LN3@Insert_nod
	npad	1
$LL2@Insert_nod:

; 674  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

	mov	rdx, QWORD PTR [rax+8]
	mov	r8, QWORD PTR [rdx+8]
	mov	rcx, QWORD PTR [r8]
	cmp	rdx, rcx
	jne	$LN10@Insert_nod

; 675  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

	mov	rcx, QWORD PTR [r8+16]

; 676  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

	cmp	BYTE PTR [rcx+24], 0
	jne	SHORT $LN12@Insert_nod

; 677  :                     _Pnode->_Parent->_Color          = _Black;

	mov	BYTE PTR [rdx+24], 1

; 678  :                     _Parent_sibling->_Color          = _Black;

	mov	BYTE PTR [rcx+24], 1

; 679  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rdx+24], 0

; 680  :                     _Pnode                           = _Pnode->_Parent->_Parent;

	mov	rcx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rcx+8]

; 681  :                 } else { // parent's sibling has red and black children

	jmp	$LN32@Insert_nod
$LN12@Insert_nod:

; 682  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

	mov	r8, QWORD PTR [rdx+16]
	cmp	rax, r8
	jne	SHORT $LN51@Insert_nod

; 462  :         _Wherenode->_Right = _Pnode->_Left;

	mov	rcx, QWORD PTR [r8]

; 683  :                         _Pnode = _Pnode->_Parent;

	mov	rax, rdx

; 462  :         _Wherenode->_Right = _Pnode->_Left;

	mov	QWORD PTR [rdx+16], rcx

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [r8]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN34@Insert_nod

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	QWORD PTR [rcx+8], rdx
$LN34@Insert_nod:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rcx

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rcx, QWORD PTR [r10]
	cmp	rdx, QWORD PTR [rcx+8]
	jne	SHORT $LN35@Insert_nod

; 471  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rcx+8], r8
	jmp	SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	rcx, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rcx]
	jne	SHORT $LN37@Insert_nod

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rcx], r8

; 474  :         } else {

	jmp	SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 475  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rcx+16], r8
$LN38@Insert_nod:

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

	mov	QWORD PTR [r8], rdx

; 479  :         _Wherenode->_Parent = _Pnode;

	mov	QWORD PTR [rdx+8], r8
$LN51@Insert_nod:

; 684  :                         _Lrotate(_Pnode);
; 685  :                     }
; 686  : 
; 687  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

	mov	rcx, QWORD PTR [rax+8]
	mov	BYTE PTR [rcx+24], 1

; 688  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rdx+24], 0

; 689  :                     _Rrotate(_Pnode->_Parent->_Parent);

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]

; 483  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	r8, QWORD PTR [rdx]

; 484  :         _Wherenode->_Left = _Pnode->_Right;

	mov	rcx, QWORD PTR [r8+16]
	mov	QWORD PTR [rdx], rcx

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

	mov	rcx, QWORD PTR [r8+16]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN20@Insert_nod

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	QWORD PTR [rcx+8], rdx
$LN20@Insert_nod:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rcx

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rcx, QWORD PTR [r10]
	cmp	rdx, QWORD PTR [rcx+8]
	jne	SHORT $LN21@Insert_nod

; 493  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rcx+8], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [r8+16], rdx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

	jmp	$LN53@Insert_nod
$LN21@Insert_nod:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	rcx, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	jne	SHORT $LN23@Insert_nod

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rcx+16], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [r8+16], rdx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

	jmp	$LN53@Insert_nod
$LN23@Insert_nod:

; 497  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rcx], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [r8+16], rdx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

	jmp	$LN53@Insert_nod
$LN10@Insert_nod:

; 692  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 693  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

	cmp	BYTE PTR [rcx+24], 0
	jne	SHORT $LN15@Insert_nod

; 694  :                     _Pnode->_Parent->_Color          = _Black;

	mov	BYTE PTR [rdx+24], 1

; 695  :                     _Parent_sibling->_Color          = _Black;

	mov	BYTE PTR [rcx+24], 1

; 696  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rdx+24], 0

; 697  :                     _Pnode                           = _Pnode->_Parent->_Parent;

	mov	rcx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rcx+8]

; 698  :                 } else { // parent's sibling has red and black children

	jmp	$LN32@Insert_nod
$LN15@Insert_nod:

; 699  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

	mov	r8, QWORD PTR [rdx]
	cmp	rax, r8
	jne	SHORT $LN46@Insert_nod

; 484  :         _Wherenode->_Left = _Pnode->_Right;

	mov	rcx, QWORD PTR [r8+16]

; 700  :                         _Pnode = _Pnode->_Parent;

	mov	rax, rdx

; 484  :         _Wherenode->_Left = _Pnode->_Right;

	mov	QWORD PTR [rdx], rcx

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

	mov	rcx, QWORD PTR [r8+16]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN41@Insert_nod

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	QWORD PTR [rcx+8], rdx
$LN41@Insert_nod:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rcx

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rcx, QWORD PTR [r10]
	cmp	rdx, QWORD PTR [rcx+8]
	jne	SHORT $LN42@Insert_nod

; 493  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rcx+8], r8
	jmp	SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	rcx, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	jne	SHORT $LN44@Insert_nod

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rcx+16], r8

; 496  :         } else {

	jmp	SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 497  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rcx], r8
$LN45@Insert_nod:

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [r8+16], rdx

; 501  :         _Wherenode->_Parent = _Pnode;

	mov	QWORD PTR [rdx+8], r8
$LN46@Insert_nod:

; 701  :                         _Rrotate(_Pnode);
; 702  :                     }
; 703  : 
; 704  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

	mov	rcx, QWORD PTR [rax+8]
	mov	BYTE PTR [rcx+24], 1

; 705  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rdx+24], 0

; 706  :                     _Lrotate(_Pnode->_Parent->_Parent);

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]

; 461  :         _Nodeptr _Pnode    = _Wherenode->_Right;

	mov	r8, QWORD PTR [rdx+16]

; 462  :         _Wherenode->_Right = _Pnode->_Left;

	mov	rcx, QWORD PTR [r8]
	mov	QWORD PTR [rdx+16], rcx

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [r8]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN27@Insert_nod

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	QWORD PTR [rcx+8], rdx
$LN27@Insert_nod:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rcx

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rcx, QWORD PTR [r10]
	cmp	rdx, QWORD PTR [rcx+8]
	jne	SHORT $LN28@Insert_nod

; 471  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rcx+8], r8
	jmp	SHORT $LN31@Insert_nod
$LN28@Insert_nod:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	rcx, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rcx]
	jne	SHORT $LN30@Insert_nod

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rcx], r8

; 474  :         } else {

	jmp	SHORT $LN31@Insert_nod
$LN30@Insert_nod:

; 475  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rcx+16], r8
$LN31@Insert_nod:

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

	mov	QWORD PTR [r8], rdx
$LN53@Insert_nod:

; 670  :             }
; 671  :         }
; 672  : 
; 673  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

	mov	QWORD PTR [rdx+8], r8
$LN32@Insert_nod:
	mov	rcx, QWORD PTR [rax+8]
	cmp	BYTE PTR [rcx+24], 0
	je	$LL2@Insert_nod
$LN3@Insert_nod:

; 707  :                 }
; 708  :             }
; 709  :         }
; 710  : 
; 711  :         _Head->_Parent->_Color = _Black; // root is always black

	mov	rax, QWORD PTR [r11+8]
	mov	BYTE PTR [rax+24], 1

; 712  :         return _Newnode;
; 713  :     }

	mov	rax, r9
	ret	0
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@U?$_Tree_id@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@QEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Check_grow_by_1, COMDAT

; 1628 :     void _Check_grow_by_1() {

$LN7:
	sub	rsp, 40					; 00000028H

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 329406144173384850			; 0492492492492492H
	cmp	QWORD PTR [rcx+8], rax
	je	SHORT $LN6@Check_grow

; 1631 :         }
; 1632 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Check_grow:

; 1630 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN4@Check_grow:
?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@U?$_Tree_id@PEAU?$_Tree_node@HPEAX@std@@@2@QEAU32@@Z
_TEXT	SEGMENT
this$ = 8
_Loc$ = 16
_Newnode$ = 24
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@U?$_Tree_id@PEAU?$_Tree_node@HPEAX@std@@@2@QEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Insert_node, COMDAT

; 647  :         ++_Mysize;

	inc	QWORD PTR [rcx+8]
	mov	r9, r8

; 648  :         const auto _Head  = _Myhead;

	mov	r11, QWORD PTR [rcx]
	mov	r10, rcx

; 649  :         _Newnode->_Parent = _Loc._Parent;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8+8], rax

; 650  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

	cmp	rax, r11
	jne	SHORT $LN5@Insert_nod

; 651  :             _Head->_Left     = _Newnode;

	mov	QWORD PTR [r11], r8

; 712  :         return _Newnode;
; 713  :     }

	mov	rax, r8
	mov	QWORD PTR [r11+8], r8
	mov	QWORD PTR [r11+16], r8
	mov	BYTE PTR [r8+24], 1
	ret	0
$LN5@Insert_nod:

; 652  :             _Head->_Parent   = _Newnode;
; 653  :             _Head->_Right    = _Newnode;
; 654  :             _Newnode->_Color = _Black; // the root is black
; 655  :             return _Newnode;
; 656  :         }
; 657  : 
; 658  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 659  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

	cmp	DWORD PTR [rdx+8], 0
	jne	SHORT $LN6@Insert_nod

; 660  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 661  :             _Loc._Parent->_Right = _Newnode;

	mov	QWORD PTR [rax+16], r9

; 662  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

	cmp	rax, QWORD PTR [r11+16]
	jne	SHORT $LN9@Insert_nod

; 663  :                 _Head->_Right = _Newnode;

	mov	QWORD PTR [r11+16], r9

; 664  :             }
; 665  :         } else { // add to left of _Loc._Parent

	jmp	SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 666  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 667  :             _Loc._Parent->_Left = _Newnode;

	mov	QWORD PTR [rax], r9

; 668  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

	cmp	rax, QWORD PTR [r11]
	jne	SHORT $LN9@Insert_nod

; 669  :                 _Head->_Left = _Newnode;

	mov	QWORD PTR [r11], r9
$LN9@Insert_nod:

; 670  :             }
; 671  :         }
; 672  : 
; 673  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

	mov	rcx, QWORD PTR [r8+8]
	mov	rax, r9
	cmp	BYTE PTR [rcx+24], 0
	jne	$LN3@Insert_nod
	npad	1
$LL2@Insert_nod:

; 674  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

	mov	rdx, QWORD PTR [rax+8]
	mov	r8, QWORD PTR [rdx+8]
	mov	rcx, QWORD PTR [r8]
	cmp	rdx, rcx
	jne	$LN10@Insert_nod

; 675  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

	mov	rcx, QWORD PTR [r8+16]

; 676  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

	cmp	BYTE PTR [rcx+24], 0
	jne	SHORT $LN12@Insert_nod

; 677  :                     _Pnode->_Parent->_Color          = _Black;

	mov	BYTE PTR [rdx+24], 1

; 678  :                     _Parent_sibling->_Color          = _Black;

	mov	BYTE PTR [rcx+24], 1

; 679  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rdx+24], 0

; 680  :                     _Pnode                           = _Pnode->_Parent->_Parent;

	mov	rcx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rcx+8]

; 681  :                 } else { // parent's sibling has red and black children

	jmp	$LN32@Insert_nod
$LN12@Insert_nod:

; 682  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

	mov	r8, QWORD PTR [rdx+16]
	cmp	rax, r8
	jne	SHORT $LN51@Insert_nod

; 462  :         _Wherenode->_Right = _Pnode->_Left;

	mov	rcx, QWORD PTR [r8]

; 683  :                         _Pnode = _Pnode->_Parent;

	mov	rax, rdx

; 462  :         _Wherenode->_Right = _Pnode->_Left;

	mov	QWORD PTR [rdx+16], rcx

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [r8]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN34@Insert_nod

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	QWORD PTR [rcx+8], rdx
$LN34@Insert_nod:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rcx

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rcx, QWORD PTR [r10]
	cmp	rdx, QWORD PTR [rcx+8]
	jne	SHORT $LN35@Insert_nod

; 471  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rcx+8], r8
	jmp	SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	rcx, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rcx]
	jne	SHORT $LN37@Insert_nod

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rcx], r8

; 474  :         } else {

	jmp	SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 475  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rcx+16], r8
$LN38@Insert_nod:

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

	mov	QWORD PTR [r8], rdx

; 479  :         _Wherenode->_Parent = _Pnode;

	mov	QWORD PTR [rdx+8], r8
$LN51@Insert_nod:

; 684  :                         _Lrotate(_Pnode);
; 685  :                     }
; 686  : 
; 687  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

	mov	rcx, QWORD PTR [rax+8]
	mov	BYTE PTR [rcx+24], 1

; 688  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rdx+24], 0

; 689  :                     _Rrotate(_Pnode->_Parent->_Parent);

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]

; 483  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	r8, QWORD PTR [rdx]

; 484  :         _Wherenode->_Left = _Pnode->_Right;

	mov	rcx, QWORD PTR [r8+16]
	mov	QWORD PTR [rdx], rcx

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

	mov	rcx, QWORD PTR [r8+16]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN20@Insert_nod

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	QWORD PTR [rcx+8], rdx
$LN20@Insert_nod:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rcx

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rcx, QWORD PTR [r10]
	cmp	rdx, QWORD PTR [rcx+8]
	jne	SHORT $LN21@Insert_nod

; 493  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rcx+8], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [r8+16], rdx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

	jmp	$LN53@Insert_nod
$LN21@Insert_nod:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	rcx, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	jne	SHORT $LN23@Insert_nod

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rcx+16], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [r8+16], rdx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

	jmp	$LN53@Insert_nod
$LN23@Insert_nod:

; 497  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rcx], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [r8+16], rdx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

	jmp	$LN53@Insert_nod
$LN10@Insert_nod:

; 692  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 693  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

	cmp	BYTE PTR [rcx+24], 0
	jne	SHORT $LN15@Insert_nod

; 694  :                     _Pnode->_Parent->_Color          = _Black;

	mov	BYTE PTR [rdx+24], 1

; 695  :                     _Parent_sibling->_Color          = _Black;

	mov	BYTE PTR [rcx+24], 1

; 696  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rdx+24], 0

; 697  :                     _Pnode                           = _Pnode->_Parent->_Parent;

	mov	rcx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rcx+8]

; 698  :                 } else { // parent's sibling has red and black children

	jmp	$LN32@Insert_nod
$LN15@Insert_nod:

; 699  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

	mov	r8, QWORD PTR [rdx]
	cmp	rax, r8
	jne	SHORT $LN46@Insert_nod

; 484  :         _Wherenode->_Left = _Pnode->_Right;

	mov	rcx, QWORD PTR [r8+16]

; 700  :                         _Pnode = _Pnode->_Parent;

	mov	rax, rdx

; 484  :         _Wherenode->_Left = _Pnode->_Right;

	mov	QWORD PTR [rdx], rcx

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

	mov	rcx, QWORD PTR [r8+16]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN41@Insert_nod

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	QWORD PTR [rcx+8], rdx
$LN41@Insert_nod:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rcx

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rcx, QWORD PTR [r10]
	cmp	rdx, QWORD PTR [rcx+8]
	jne	SHORT $LN42@Insert_nod

; 493  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rcx+8], r8
	jmp	SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	rcx, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rcx+16]
	jne	SHORT $LN44@Insert_nod

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rcx+16], r8

; 496  :         } else {

	jmp	SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 497  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rcx], r8
$LN45@Insert_nod:

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

	mov	QWORD PTR [r8+16], rdx

; 501  :         _Wherenode->_Parent = _Pnode;

	mov	QWORD PTR [rdx+8], r8
$LN46@Insert_nod:

; 701  :                         _Rrotate(_Pnode);
; 702  :                     }
; 703  : 
; 704  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

	mov	rcx, QWORD PTR [rax+8]
	mov	BYTE PTR [rcx+24], 1

; 705  :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	mov	BYTE PTR [rdx+24], 0

; 706  :                     _Lrotate(_Pnode->_Parent->_Parent);

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]

; 461  :         _Nodeptr _Pnode    = _Wherenode->_Right;

	mov	r8, QWORD PTR [rdx+16]

; 462  :         _Wherenode->_Right = _Pnode->_Left;

	mov	rcx, QWORD PTR [r8]
	mov	QWORD PTR [rdx+16], rcx

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

	mov	rcx, QWORD PTR [r8]
	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN27@Insert_nod

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	QWORD PTR [rcx+8], rdx
$LN27@Insert_nod:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rcx, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rcx

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rcx, QWORD PTR [r10]
	cmp	rdx, QWORD PTR [rcx+8]
	jne	SHORT $LN28@Insert_nod

; 471  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rcx+8], r8
	jmp	SHORT $LN31@Insert_nod
$LN28@Insert_nod:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	rcx, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rcx]
	jne	SHORT $LN30@Insert_nod

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rcx], r8

; 474  :         } else {

	jmp	SHORT $LN31@Insert_nod
$LN30@Insert_nod:

; 475  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rcx+16], r8
$LN31@Insert_nod:

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

	mov	QWORD PTR [r8], rdx
$LN53@Insert_nod:

; 670  :             }
; 671  :         }
; 672  : 
; 673  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

	mov	QWORD PTR [rdx+8], r8
$LN32@Insert_nod:
	mov	rcx, QWORD PTR [rax+8]
	cmp	BYTE PTR [rcx+24], 0
	je	$LL2@Insert_nod
$LN3@Insert_nod:

; 707  :                 }
; 708  :             }
; 709  :         }
; 710  : 
; 711  :         _Head->_Parent->_Color = _Black; // root is always black

	mov	rax, QWORD PTR [r11+8]
	mov	BYTE PTR [rax+24], 1

; 712  :         return _Newnode;
; 713  :     }

	mov	rax, r9
	ret	0
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAPEAU?$_Tree_node@HPEAX@2@U?$_Tree_id@PEAU?$_Tree_node@HPEAX@std@@@2@QEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Check_grow_by_1, COMDAT

; 1628 :     void _Check_grow_by_1() {

$LN7:
	sub	rsp, 40					; 00000028H

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

	mov	rax, 576460752303423487			; 07ffffffffffffffH
	cmp	QWORD PTR [rcx+8], rax
	je	SHORT $LN6@Check_grow

; 1631 :         }
; 1632 :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN6@Check_grow:

; 1630 :             _Throw_tree_length_error();

	call	?_Throw_tree_length_error@std@@YAXXZ	; std::_Throw_tree_length_error
	int	3
$LN4@Check_grow:
?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAA@PEAH00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAA@PEAH00@Z PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT

; 401  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r9
	ret	0
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QEAA@PEAH00@Z ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >, COMDAT

; 1133 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN10@Tree_temp_

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN10@Tree_temp_:
	ret	0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >, COMDAT

; 1133 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN10@Tree_temp_

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN10@Tree_temp_:
	ret	0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >, COMDAT

; 1133 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@Alloc_cons

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN8@Alloc_cons:

; 1134 :             _Al.deallocate(_Ptr, 1);
; 1135 :         }
; 1136 :     }

	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >, COMDAT

; 1133 :         if (_Ptr) {

	mov	rcx, QWORD PTR [rcx+8]
	test	rcx, rcx
	je	SHORT $LN8@Alloc_cons

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN8@Alloc_cons:

; 1134 :             _Al.deallocate(_Ptr, 1);
; 1135 :         }
; 1136 :     }

	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_Wherenode$ = 16
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Rrotate, COMDAT

; 483  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	r8, QWORD PTR [rdx]

; 484  :         _Wherenode->_Left = _Pnode->_Right;

	mov	rax, QWORD PTR [r8+16]
	mov	QWORD PTR [rdx], rax

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

	mov	rax, QWORD PTR [r8+16]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN2@Rrotate

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	QWORD PTR [rax+8], rdx
$LN2@Rrotate:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rax

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rax, QWORD PTR [rcx]
	cmp	rdx, QWORD PTR [rax+8]
	jne	SHORT $LN3@Rrotate

; 493  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rax+8], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;
; 501  :         _Wherenode->_Parent = _Pnode;
; 502  :     }

	mov	QWORD PTR [r8+16], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
$LN3@Rrotate:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	rax, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rax+16]
	jne	SHORT $LN5@Rrotate

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rax+16], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;
; 501  :         _Wherenode->_Parent = _Pnode;
; 502  :     }

	mov	QWORD PTR [r8+16], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
$LN5@Rrotate:

; 496  :         } else {
; 497  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rax], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;
; 501  :         _Wherenode->_Parent = _Pnode;
; 502  :     }

	mov	QWORD PTR [r8+16], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_Wherenode$ = 16
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Lrotate, COMDAT

; 461  :         _Nodeptr _Pnode    = _Wherenode->_Right;

	mov	r8, QWORD PTR [rdx+16]

; 462  :         _Wherenode->_Right = _Pnode->_Left;

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx+16], rax

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR [r8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN2@Lrotate

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	QWORD PTR [rax+8], rdx
$LN2@Lrotate:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rax

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rax, QWORD PTR [rcx]
	cmp	rdx, QWORD PTR [rax+8]
	jne	SHORT $LN3@Lrotate

; 471  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rax+8], r8

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;
; 479  :         _Wherenode->_Parent = _Pnode;
; 480  :     }

	mov	QWORD PTR [r8], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
$LN3@Lrotate:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	rax, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rax]
	jne	SHORT $LN5@Lrotate

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rax], r8

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;
; 479  :         _Wherenode->_Parent = _Pnode;
; 480  :     }

	mov	QWORD PTR [r8], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
$LN5@Lrotate:

; 474  :         } else {
; 475  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rax+16], r8

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;
; 479  :         _Wherenode->_Parent = _Pnode;
; 480  :     }

	mov	QWORD PTR [r8], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::max_size, COMDAT

; 1197 :         return (_STD min)(

	mov	rax, 329406144173384850			; 0492492492492492H

; 1198 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1199 :     }

	ret	0
?max_size@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXPEAU?$_Tree_node@HPEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_Wherenode$ = 16
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXPEAU?$_Tree_node@HPEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Rrotate, COMDAT

; 483  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	r8, QWORD PTR [rdx]

; 484  :         _Wherenode->_Left = _Pnode->_Right;

	mov	rax, QWORD PTR [r8+16]
	mov	QWORD PTR [rdx], rax

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

	mov	rax, QWORD PTR [r8+16]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN2@Rrotate

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	QWORD PTR [rax+8], rdx
$LN2@Rrotate:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rax

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rax, QWORD PTR [rcx]
	cmp	rdx, QWORD PTR [rax+8]
	jne	SHORT $LN3@Rrotate

; 493  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rax+8], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;
; 501  :         _Wherenode->_Parent = _Pnode;
; 502  :     }

	mov	QWORD PTR [r8+16], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
$LN3@Rrotate:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	rax, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rax+16]
	jne	SHORT $LN5@Rrotate

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rax+16], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;
; 501  :         _Wherenode->_Parent = _Pnode;
; 502  :     }

	mov	QWORD PTR [r8+16], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
$LN5@Rrotate:

; 496  :         } else {
; 497  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rax], r8

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;
; 501  :         _Wherenode->_Parent = _Pnode;
; 502  :     }

	mov	QWORD PTR [r8+16], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXPEAU?$_Tree_node@HPEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXPEAU?$_Tree_node@HPEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_Wherenode$ = 16
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXPEAU?$_Tree_node@HPEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Lrotate, COMDAT

; 461  :         _Nodeptr _Pnode    = _Wherenode->_Right;

	mov	r8, QWORD PTR [rdx+16]

; 462  :         _Wherenode->_Right = _Pnode->_Left;

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx+16], rax

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

	mov	rax, QWORD PTR [r8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN2@Lrotate

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	QWORD PTR [rax+8], rdx
$LN2@Lrotate:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [r8+8], rax

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

	mov	rax, QWORD PTR [rcx]
	cmp	rdx, QWORD PTR [rax+8]
	jne	SHORT $LN3@Lrotate

; 471  :             _Myhead->_Parent = _Pnode;

	mov	QWORD PTR [rax+8], r8

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;
; 479  :         _Wherenode->_Parent = _Pnode;
; 480  :     }

	mov	QWORD PTR [r8], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
$LN3@Lrotate:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	rax, QWORD PTR [rdx+8]
	cmp	rdx, QWORD PTR [rax]
	jne	SHORT $LN5@Lrotate

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	QWORD PTR [rax], r8

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;
; 479  :         _Wherenode->_Parent = _Pnode;
; 480  :     }

	mov	QWORD PTR [r8], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
$LN5@Lrotate:

; 474  :         } else {
; 475  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	QWORD PTR [rax+16], r8

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;
; 479  :         _Wherenode->_Parent = _Pnode;
; 480  :     }

	mov	QWORD PTR [r8], rdx
	mov	QWORD PTR [rdx+8], r8
	ret	0
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QEAAXPEAU?$_Tree_node@HPEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::max_size, COMDAT

; 1197 :         return (_STD min)(

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 1198 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1199 :     }

	ret	0
?max_size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Getal, COMDAT

; 1963 :         return _Mypair._Myval2._Get_first();

	mov	rax, rcx

; 1964 :     }

	ret	0
?_Getal@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::max_size, COMDAT

; 691  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 329406144173384850			; 0492492492492492H

; 692  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >::deallocate, COMDAT

; 943  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	mov	rcx, rdx

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 56					; 00000038H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@QEAAXQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getal, COMDAT

; 1963 :         return _Mypair._Myval2._Get_first();

	mov	rax, rcx

; 1964 :     }

	ret	0
?_Getal@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBAAEBV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@HPEAX@std@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@HPEAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::max_size, COMDAT

; 691  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 576460752303423487			; 07ffffffffffffffH

; 692  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@HPEAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@HPEAX@std@@@std@@QEAAXQEAU?$_Tree_node@HPEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$allocator@U?$_Tree_node@HPEAX@std@@@std@@QEAAXQEAU?$_Tree_node@HPEAX@2@_K@Z PROC ; std::allocator<std::_Tree_node<int,void *> >::deallocate, COMDAT

; 943  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	mov	rcx, rdx

; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	edx, 32					; 00000020H
	jmp	??3@YAXPEAX_K@Z				; operator delete
?deallocate@?$allocator@U?$_Tree_node@HPEAX@std@@@std@@QEAAXQEAU?$_Tree_node@HPEAX@2@_K@Z ENDP ; std::allocator<std::_Tree_node<int,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QEBAAEBV?$allocator@U?$_Tree_node@HPEAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z
_TEXT	SEGMENT
_Loc$15 = 0
this$ = 64
__$ReturnUdt$ = 72
_Hint$ = 80
_Keyval$ = 88
??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_hint<int>, COMDAT

; 1494 :     _Tree_find_hint_result<_Nodeptr> _Find_hint(const _Nodeptr _Hint, const _Keyty& _Keyval) const {

$LN129:
	push	rbx
	push	rdi
	push	r15
	sub	rsp, 32					; 00000020H

; 1495 :         const auto& _Comp = _Getcomp();
; 1496 :         const auto _Head  = _Get_scary()->_Myhead;
; 1497 :         if constexpr (_Multi) { // insert even if duplicate
; 1498 :             if (_Hint->_Isnil) {
; 1499 :                 // insert at end if greater than or equal to last element
; 1500 :                 if (_Head->_Parent->_Isnil || !_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Head->_Right->_Myval))) {
; 1501 :                     return {{_Head->_Right, _Tree_child::_Right}, false};
; 1502 :                 }
; 1503 : 
; 1504 :                 // _Hint is end(); it must be closer to the end of equivalents
; 1505 :                 return {_Find_upper_bound(_Keyval)._Location, false};
; 1506 :             }
; 1507 : 
; 1508 :             if (_Hint == _Head->_Left) {
; 1509 :                 // insert at beginning if less than or equal to first element
; 1510 :                 if (!_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint->_Myval), _Keyval)) {
; 1511 :                     return {{_Hint, _Tree_child::_Left}, false};
; 1512 :                 }
; 1513 : 
; 1514 :                 // _Hint is begin(); it must be closer to the beginning of equivalents
; 1515 :                 return {_Find_lower_bound(_Keyval)._Location, false};
; 1516 :             }
; 1517 : 
; 1518 :             if (!_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint->_Myval), _Keyval)) {
; 1519 :                 // _Val <= *_Hint
; 1520 :                 const auto _Prev = (--(_Unchecked_const_iterator(_Hint, nullptr)))._Ptr;
; 1521 :                 if (!_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Prev->_Myval))) {
; 1522 :                     // _Val <= *_Hint and _Val >= *prev(_Hint); insert here
; 1523 :                     if (_Prev->_Right->_Isnil) {
; 1524 :                         return {{_Prev, _Tree_child::_Right}, false};
; 1525 :                     } else {
; 1526 :                         return {{_Hint, _Tree_child::_Left}, false};
; 1527 :                     }
; 1528 :                 }
; 1529 : 
; 1530 :                 // _Val goes before *_Hint; _Hint must be closer to the end of equivalents
; 1531 :                 return {_Find_upper_bound(_Keyval)._Location, false};
; 1532 :             }
; 1533 : 
; 1534 :             // _Val goes after *_Hint; _Hint must be closer to the beginning of equivalents
; 1535 :             return {_Find_lower_bound(_Keyval)._Location, false};
; 1536 :         } else { // insert only if unique
; 1537 :             if (_Hint->_Isnil) { // insert at end if after last element

	cmp	BYTE PTR [r8+25], 0
	mov	r15, r9
	mov	rbx, QWORD PTR [rcx]
	mov	r10, r8
	je	SHORT $LN2@Find_hint

; 1539 :                 if (_Head->_Parent->_Isnil || _DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Head->_Right->_Myval), _Keyval)) {

	mov	rax, QWORD PTR [rbx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN94@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 143  :         return _Left < _Right;

	mov	rax, QWORD PTR [rbx+16]
	mov	r11d, DWORD PTR [r9]
	cmp	DWORD PTR [rax+28], r11d
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1539 :                 if (_Head->_Parent->_Isnil || _DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Head->_Right->_Myval), _Keyval)) {

	jge	$LN16@Find_hint
$LN94@Find_hint:

; 1540 :                     return {{_Head->_Right, _Tree_child::_Right}, false};

	mov	rax, QWORD PTR [rbx+16]
	xor	ecx, ecx
	mov	QWORD PTR [rdx], rax

; 1580 :         }
; 1581 :     }

	mov	rax, rdx
	mov	BYTE PTR [rdx+16], cl
	mov	DWORD PTR [rdx+8], ecx
	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
$LN2@Find_hint:

; 1541 :                 }
; 1542 :             } else if (_Hint == _Head->_Left) {

	mov	r9d, DWORD PTR [r9]
	mov	r11d, r9d
	mov	eax, DWORD PTR [r8+28]
	cmp	r10, QWORD PTR [rbx]
	jne	SHORT $LN6@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 143  :         return _Left < _Right;

	cmp	r9d, eax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1544 :                 if (_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Hint->_Myval))) {

	jge	$LN16@Find_hint

; 1545 :                     return {{_Hint, _Tree_child::_Left}, false};

	mov	QWORD PTR [rdx], r10

; 1580 :         }
; 1581 :     }

	mov	rax, rdx
	mov	DWORD PTR [rdx+8], 1
	mov	BYTE PTR [rdx+16], 0
	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
$LN6@Find_hint:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 143  :         return _Left < _Right;

	cmp	r9d, eax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1547 :             } else if (_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Hint->_Myval))) {

	jge	$LN9@Find_hint

; 74   :         } else if (_Ptr->_Left->_Isnil) { // climb looking for left subtree

	mov	r8, QWORD PTR [r8]

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

	mov	rax, r10

; 74   :         } else if (_Ptr->_Left->_Isnil) { // climb looking for left subtree

	cmp	BYTE PTR [r8+25], 0
	je	SHORT $LN48@Find_hint

; 75   :             _Nodeptr _Pnode;
; 76   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Left) {

	mov	r8, QWORD PTR [r10+8]
	mov	rcx, r10
	cmp	BYTE PTR [r8+25], 0
	jne	SHORT $LN96@Find_hint
	mov	QWORD PTR [rsp+64], rbp

; 1539 :                 if (_Head->_Parent->_Isnil || _DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Head->_Right->_Myval), _Keyval)) {

	mov	r9, r10

; 76   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Left) {

	mov	QWORD PTR [rsp+72], rsi

; 1539 :                 if (_Head->_Parent->_Isnil || _DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Head->_Right->_Myval), _Keyval)) {

	mov	rdi, r10

; 76   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Left) {

	mov	QWORD PTR [rsp+80], r14
	npad	6
$LL44@Find_hint:
	mov	rsi, r8
	mov	rbp, r8
	mov	r14, r8
	mov	rcx, rdi
	cmp	r9, QWORD PTR [r8]
	jne	SHORT $LN123@Find_hint

; 77   :                 _Ptr = _Pnode; // ==> parent while left subtree

	mov	rax, r8
	mov	r8, QWORD PTR [r8+8]
	mov	r9, rax
	mov	rdi, rax
	mov	rcx, rax
	cmp	BYTE PTR [r8+25], 0
	je	SHORT $LL44@Find_hint
$LN123@Find_hint:
	mov	rsi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+80]
$LN96@Find_hint:

; 78   :             }
; 79   : 
; 80   :             if (!_Ptr->_Isnil) { // decrement non-begin()
; 81   :                 _Ptr = _Pnode; // ==> parent if not head
; 82   :             }
; 83   :         } else {

	cmp	BYTE PTR [rax+25], 0
	cmovne	r8, rcx
	jmp	SHORT $LN54@Find_hint
$LN48@Find_hint:

; 445  :         while (!_Pnode->_Right->_Isnil) {

	mov	rax, QWORD PTR [r8+16]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN54@Find_hint
	npad	5
$LL53@Find_hint:

; 446  :             _Pnode = _Pnode->_Right;

	mov	r8, rax
	mov	rax, QWORD PTR [rax+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL53@Find_hint
$LN54@Find_hint:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 143  :         return _Left < _Right;

	cmp	DWORD PTR [r8+28], r11d
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1550 :                 if (_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Prev->_Myval), _Keyval)) {

	jge	$LN16@Find_hint

; 1551 :                     // _Val < *_Hint and _Val > *prev(_Hint); insert here
; 1552 :                     if (_Prev->_Right->_Isnil) {

	mov	rax, QWORD PTR [r8+16]
	movzx	ecx, BYTE PTR [rax+25]
	mov	rax, rdx
	mov	BYTE PTR [rdx+16], 0
	test	cl, cl
	je	SHORT $LN12@Find_hint

; 1553 :                         return {{_Prev, _Tree_child::_Right}, false};

	xor	ecx, ecx
	mov	QWORD PTR [rdx], r8
	mov	DWORD PTR [rdx+8], ecx

; 1580 :         }
; 1581 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
$LN12@Find_hint:

; 1554 :                     } else {
; 1555 :                         return {{_Hint, _Tree_child::_Left}, false};

	mov	QWORD PTR [rdx], r10
	mov	DWORD PTR [rdx+8], 1

; 1580 :         }
; 1581 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
$LN9@Find_hint:

; 1556 :                     }
; 1557 :                 }
; 1558 :             } else if (_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint->_Myval), _Keyval)) {

	jle	$LN14@Find_hint

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rcx, QWORD PTR [r8+16]
	movzx	edi, BYTE PTR [rcx+25]
	test	dil, dil
	je	SHORT $LN65@Find_hint

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rcx, QWORD PTR [r8+8]
	cmp	BYTE PTR [rcx+25], 0
	jne	$LN17@Find_hint

; 1539 :                 if (_Head->_Parent->_Isnil || _DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Head->_Right->_Myval), _Keyval)) {

	mov	rax, r10
$LL63@Find_hint:

; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	r8, rcx
	cmp	rax, QWORD PTR [rcx+16]
	jne	SHORT $LN70@Find_hint
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, r8
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LL63@Find_hint

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree
; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())
; 58   :         } else {

	jmp	SHORT $LN70@Find_hint
$LN65@Find_hint:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	r8, QWORD PTR [rcx]
	cmp	BYTE PTR [r8+25], 0
	jne	SHORT $LN70@Find_hint
	npad	12
$LL69@Find_hint:
	mov	rax, QWORD PTR [r8]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rcx, r8
	mov	r8, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL69@Find_hint
$LN70@Find_hint:

; 1561 :                 if (_Next->_Isnil || _DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Next->_Myval))) {

	cmp	BYTE PTR [rcx+25], 0
	jne	SHORT $LN17@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 143  :         return _Left < _Right;

	cmp	r9d, DWORD PTR [rcx+28]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1561 :                 if (_Next->_Isnil || _DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Next->_Myval))) {

	jl	SHORT $LN17@Find_hint
$LN16@Find_hint:

; 1611 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rax, QWORD PTR [rbx+8]
	xor	ecx, ecx
	mov	QWORD PTR _Loc$15[rsp], rax
	mov	DWORD PTR _Loc$15[rsp+8], ecx

; 1612 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1613 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rax+25], cl
	jne	SHORT $LN23@Find_hint
	npad	2
$LL22@Find_hint:

; 1614 :             _Result._Location._Parent = _Trynode;

	mov	QWORD PTR _Loc$15[rsp], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 143  :         return _Left < _Right;

	cmp	DWORD PTR [rax+28], r11d
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1615 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	jge	SHORT $LN24@Find_hint

; 1616 :                 _Result._Location._Child = _Tree_child::_Right;
; 1617 :                 _Trynode                 = _Trynode->_Right;

	mov	rax, QWORD PTR [rax+16]
	mov	DWORD PTR _Loc$15[rsp+8], ecx

; 1618 :             } else {

	jmp	SHORT $LN25@Find_hint
$LN24@Find_hint:

; 1619 :                 _Result._Location._Child = _Tree_child::_Left;
; 1620 :                 _Result._Bound           = _Trynode;

	mov	rbx, rax
	mov	DWORD PTR _Loc$15[rsp+8], 1

; 1621 :                 _Trynode                 = _Trynode->_Left;

	mov	rax, QWORD PTR [rax]
$LN25@Find_hint:

; 1612 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1613 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rax+25], cl
	je	SHORT $LL22@Find_hint
$LN23@Find_hint:

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rbx+25], cl
	jne	SHORT $LN31@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 143  :         return _Left < _Right;

	mov	eax, DWORD PTR [rbx+28]
	cmp	DWORD PTR [r15], eax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	jl	SHORT $LN31@Find_hint

; 1580 :         }
; 1581 :     }

	mov	QWORD PTR [rdx], rbx
	mov	rax, rdx
	mov	DWORD PTR [rdx+8], 2
	mov	BYTE PTR [rdx+16], 1
	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
$LN31@Find_hint:

; 1572 :             }
; 1573 : 
; 1574 :             const auto _Loc = _Find_lower_bound(_Keyval);
; 1575 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
; 1576 :                 return {{_Loc._Bound, _Tree_child::_Unused}, true};
; 1577 :             }
; 1578 : 
; 1579 :             return {_Loc._Location, false};

	movups	xmm0, XMMWORD PTR _Loc$15[rsp]
	mov	BYTE PTR [rdx+16], cl

; 1580 :         }
; 1581 :     }

	mov	rax, rdx
	movups	XMMWORD PTR [rdx], xmm0
	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
$LN17@Find_hint:

; 1562 :                     // _Val > *_Hint and _Val < *next(_Hint); insert here
; 1563 :                     if (_Hint->_Right->_Isnil) {

	mov	BYTE PTR [rdx+16], 0
	mov	rax, rdx
	test	dil, dil
	je	SHORT $LN18@Find_hint

; 1564 :                         return {{_Hint, _Tree_child::_Right}, false};

	xor	ecx, ecx
	mov	QWORD PTR [rdx], r10
	mov	DWORD PTR [rdx+8], ecx

; 1580 :         }
; 1581 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
$LN18@Find_hint:

; 1565 :                     }
; 1566 : 
; 1567 :                     return {{_Next, _Tree_child::_Left}, false};

	mov	QWORD PTR [rdx], rcx
	mov	DWORD PTR [rdx+8], 1

; 1580 :         }
; 1581 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
$LN14@Find_hint:

; 1568 :                 }
; 1569 :             } else {
; 1570 :                 // _Val is equivalent to *_Hint; don't insert
; 1571 :                 return {{_Hint, _Tree_child::_Right}, true};

	xor	ecx, ecx
	mov	QWORD PTR [rdx], r10

; 1580 :         }
; 1581 :     }

	mov	DWORD PTR [rdx+8], ecx
	mov	rax, rdx
	mov	BYTE PTR [rdx+16], 1
	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
??$_Find_hint@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@HPEAX@std@@@1@QEAU?$_Tree_node@HPEAX@1@AEBH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_hint<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
this$ = 64
_Al_$ = 72
_Myhead$ = 80
<_Vals_0>$ = 88
??$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > ><int &>, COMDAT

; 806  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

$LN45:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	eax, eax

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rax

; 77   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+32]
	call	??2@YAPEAX_K@Z				; operator new

; 1129 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rsi+8], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	mov	ecx, DWORD PTR [rbx]
	mov	DWORD PTR [rax+28], ecx

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rcx], rdi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rcx+8], rdi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rcx+16], rdi

; 811  :         this->_Ptr->_Color = _Red;

	mov	rcx, QWORD PTR [rsi+8]
	mov	BYTE PTR [rcx+24], 0
	mov	rcx, QWORD PTR [rsi+8]
	mov	BYTE PTR [rcx+25], 0

; 812  :         this->_Ptr->_Isnil = false;
; 813  :     }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > ><int &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 64
_Al_$ = 72
_Myhead$ = 80
<_Vals_0>$ = 88
?dtor$1@?0???$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > ><int &>'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
?dtor$1@?0???$?0AEAH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@PEAU?$_Tree_node@HPEAX@1@AEAH@Z@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > ><int &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Find_hint@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
_Loc$39 = 0
this$ = 80
__$ReturnUdt$ = 88
_Hint$ = 96
_Keyval$ = 104
??$_Find_hint@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Find_hint<std::vector<int,std::allocator<int> > >, COMDAT

; 1494 :     _Tree_find_hint_result<_Nodeptr> _Find_hint(const _Nodeptr _Hint, const _Keyty& _Keyval) const {

$LN359:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1495 :         const auto& _Comp = _Getcomp();
; 1496 :         const auto _Head  = _Get_scary()->_Myhead;
; 1497 :         if constexpr (_Multi) { // insert even if duplicate
; 1498 :             if (_Hint->_Isnil) {
; 1499 :                 // insert at end if greater than or equal to last element
; 1500 :                 if (_Head->_Parent->_Isnil || !_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Head->_Right->_Myval))) {
; 1501 :                     return {{_Head->_Right, _Tree_child::_Right}, false};
; 1502 :                 }
; 1503 : 
; 1504 :                 // _Hint is end(); it must be closer to the end of equivalents
; 1505 :                 return {_Find_upper_bound(_Keyval)._Location, false};
; 1506 :             }
; 1507 : 
; 1508 :             if (_Hint == _Head->_Left) {
; 1509 :                 // insert at beginning if less than or equal to first element
; 1510 :                 if (!_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint->_Myval), _Keyval)) {
; 1511 :                     return {{_Hint, _Tree_child::_Left}, false};
; 1512 :                 }
; 1513 : 
; 1514 :                 // _Hint is begin(); it must be closer to the beginning of equivalents
; 1515 :                 return {_Find_lower_bound(_Keyval)._Location, false};
; 1516 :             }
; 1517 : 
; 1518 :             if (!_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint->_Myval), _Keyval)) {
; 1519 :                 // _Val <= *_Hint
; 1520 :                 const auto _Prev = (--(_Unchecked_const_iterator(_Hint, nullptr)))._Ptr;
; 1521 :                 if (!_DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Prev->_Myval))) {
; 1522 :                     // _Val <= *_Hint and _Val >= *prev(_Hint); insert here
; 1523 :                     if (_Prev->_Right->_Isnil) {
; 1524 :                         return {{_Prev, _Tree_child::_Right}, false};
; 1525 :                     } else {
; 1526 :                         return {{_Hint, _Tree_child::_Left}, false};
; 1527 :                     }
; 1528 :                 }
; 1529 : 
; 1530 :                 // _Val goes before *_Hint; _Hint must be closer to the end of equivalents
; 1531 :                 return {_Find_upper_bound(_Keyval)._Location, false};
; 1532 :             }
; 1533 : 
; 1534 :             // _Val goes after *_Hint; _Hint must be closer to the beginning of equivalents
; 1535 :             return {_Find_lower_bound(_Keyval)._Location, false};
; 1536 :         } else { // insert only if unique
; 1537 :             if (_Hint->_Isnil) { // insert at end if after last element

	cmp	BYTE PTR [r8+25], 0
	mov	r12, r9
	mov	rbp, QWORD PTR [rcx]
	mov	r14, r8
	mov	r10, rdx
	je	SHORT $LN2@Find_hint

; 1538 :                 // insert at end if greater than last element
; 1539 :                 if (_Head->_Parent->_Isnil || _DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Head->_Right->_Myval), _Keyval)) {

	mov	rax, QWORD PTR [rbp+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN5@Find_hint
	mov	rax, QWORD PTR [rbp+16]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2329 :         return _STD lexicographical_compare(

	lea	r15, QWORD PTR [r9+8]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5464 :     auto _UFirst1      = _Get_unwrapped(_First1);

	mov	rcx, QWORD PTR [rax+32]

; 5465 :     const auto _ULast1 = _Get_unwrapped(_Last1);

	mov	r11, QWORD PTR [rax+40]

; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);

	mov	rax, QWORD PTR [r9]

; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);

	mov	r9, QWORD PTR [r15]

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	cmp	rcx, r11
	je	SHORT $LN292@Find_hint
	npad	2
$LL80@Find_hint:
	cmp	rax, r9
	je	$LN212@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	edx, DWORD PTR [rcx]
	cmp	edx, DWORD PTR [rax]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {

	jl	SHORT $LN5@Find_hint

; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {

	jg	$LN212@Find_hint

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	add	rcx, 4
	add	rax, 4
	cmp	rcx, r11
	jne	SHORT $LL80@Find_hint
$LN292@Find_hint:

; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;

	cmp	rax, r9
	je	$LN212@Find_hint
$LN5@Find_hint:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1540 :                     return {{_Head->_Right, _Tree_child::_Right}, false};

	mov	rcx, QWORD PTR [rbp+16]
	xor	edi, edi
	mov	QWORD PTR [r10], rcx
	mov	BYTE PTR [r10+16], dil
	jmp	$LN354@Find_hint
$LN2@Find_hint:

; 1541 :                 }
; 1542 :             } else if (_Hint == _Head->_Left) {

	lea	r15, QWORD PTR [r9+8]
	mov	rcx, QWORD PTR [r9]
	mov	rbx, QWORD PTR [r15]
	cmp	r14, QWORD PTR [rbp]
	jne	SHORT $LN6@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);

	mov	rax, QWORD PTR [r8+32]

; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);

	mov	r9, QWORD PTR [r8+40]

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	cmp	rcx, rbx
	je	SHORT $LN291@Find_hint
	npad	6
$LL100@Find_hint:
	cmp	rax, r9
	je	$LN212@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	edx, DWORD PTR [rcx]
	cmp	edx, DWORD PTR [rax]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {

	jl	SHORT $LN293@Find_hint

; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {

	jg	$LN212@Find_hint

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	add	rcx, 4
	add	rax, 4
	cmp	rcx, rbx
	jne	SHORT $LL100@Find_hint
$LN291@Find_hint:

; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;

	cmp	rax, r9
	je	$LN212@Find_hint
$LN293@Find_hint:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1545 :                     return {{_Hint, _Tree_child::_Left}, false};

	mov	QWORD PTR [r10], r14
	mov	DWORD PTR [r10+8], 1
	mov	BYTE PTR [r10+16], 0
	jmp	$LN355@Find_hint
$LN6@Find_hint:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);

	mov	rdx, QWORD PTR [r14+32]
	mov	r8, rcx

; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);

	mov	rdi, QWORD PTR [r14+40]
	mov	rax, rdx

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	cmp	rcx, rbx
	je	SHORT $LN290@Find_hint
$LL120@Find_hint:
	cmp	rax, rdi
	je	$LN9@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	r9d, DWORD PTR [r8]
	cmp	r9d, DWORD PTR [rax]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {

	jl	SHORT $LN235@Find_hint

; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {

	jg	$LN9@Find_hint

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	add	r8, 4
	add	rax, 4
	cmp	r8, rbx
	jne	SHORT $LL120@Find_hint
$LN290@Find_hint:

; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;

	cmp	rax, rdi
	je	$LN9@Find_hint
$LN235@Find_hint:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 74   :         } else if (_Ptr->_Left->_Isnil) { // climb looking for left subtree

	mov	rdx, QWORD PTR [r14]
	mov	rax, r14
	cmp	BYTE PTR [rdx+25], 0
	je	SHORT $LN138@Find_hint

; 75   :             _Nodeptr _Pnode;
; 76   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Left) {

	mov	rdx, QWORD PTR [r14+8]
	mov	r8, r14
	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN300@Find_hint
	mov	r9, r14
	mov	r11, r14
	npad	1
$LL134@Find_hint:
	mov	rbx, rdx
	mov	rdi, rdx
	mov	rsi, rdx
	mov	r8, r11
	cmp	r9, QWORD PTR [rdx]
	jne	SHORT $LN300@Find_hint

; 77   :                 _Ptr = _Pnode; // ==> parent while left subtree

	mov	rax, rdx
	mov	rdx, QWORD PTR [rdx+8]
	mov	r9, rax
	mov	r11, rax
	mov	r8, rax
	cmp	BYTE PTR [rdx+25], 0
	je	SHORT $LL134@Find_hint
$LN300@Find_hint:

; 78   :             }
; 79   : 
; 80   :             if (!_Ptr->_Isnil) { // decrement non-begin()
; 81   :                 _Ptr = _Pnode; // ==> parent if not head
; 82   :             }
; 83   :         } else {

	cmp	BYTE PTR [rax+25], 0
	cmovne	rdx, r8
	jmp	SHORT $LN144@Find_hint
$LN138@Find_hint:

; 445  :         while (!_Pnode->_Right->_Isnil) {

	mov	rax, QWORD PTR [rdx+16]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN144@Find_hint
	npad	5
$LL143@Find_hint:

; 446  :             _Pnode = _Pnode->_Right;

	mov	rdx, rax
	mov	rax, QWORD PTR [rax+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL143@Find_hint
$LN144@Find_hint:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5464 :     auto _UFirst1      = _Get_unwrapped(_First1);

	mov	rax, QWORD PTR [rdx+32]

; 5465 :     const auto _ULast1 = _Get_unwrapped(_Last1);

	mov	rbx, QWORD PTR [rdx+40]

; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);

	mov	r11, QWORD PTR [r15]

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	cmp	rax, rbx
	je	SHORT $LN289@Find_hint
	npad	3
$LL155@Find_hint:
	cmp	rcx, r11
	je	$LN212@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	r8d, DWORD PTR [rax]
	cmp	r8d, DWORD PTR [rcx]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {

	jl	SHORT $LN295@Find_hint

; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {

	jg	$LN212@Find_hint

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	add	rax, 4
	add	rcx, 4
	cmp	rax, rbx
	jne	SHORT $LL155@Find_hint
$LN289@Find_hint:

; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;

	cmp	rcx, r11
	je	$LN212@Find_hint
$LN295@Find_hint:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1552 :                     if (_Prev->_Right->_Isnil) {

	mov	rax, QWORD PTR [rdx+16]
	movzx	ecx, BYTE PTR [rax+25]
	mov	rax, r10
	mov	BYTE PTR [r10+16], 0
	test	cl, cl
	je	SHORT $LN12@Find_hint

; 1553 :                         return {{_Prev, _Tree_child::_Right}, false};

	xor	edi, edi
	mov	QWORD PTR [r10], rdx
	mov	DWORD PTR [r10+8], edi
	jmp	$LN1@Find_hint
$LN12@Find_hint:

; 1554 :                     } else {
; 1555 :                         return {{_Hint, _Tree_child::_Left}, false};

	mov	QWORD PTR [r10], r14
	mov	DWORD PTR [r10+8], 1
	jmp	$LN1@Find_hint
$LN9@Find_hint:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);

	mov	rax, rcx

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	cmp	rdx, rdi
	je	SHORT $LN288@Find_hint
$LL175@Find_hint:
	cmp	rax, rbx
	je	$LN14@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	r8d, DWORD PTR [rdx]
	cmp	r8d, DWORD PTR [rax]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {

	jl	SHORT $LN296@Find_hint

; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {

	jg	$LN14@Find_hint

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	add	rdx, 4
	add	rax, 4
	cmp	rdx, rdi
	jne	SHORT $LL175@Find_hint
$LN288@Find_hint:

; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;

	cmp	rax, rbx
	je	$LN14@Find_hint
$LN296@Find_hint:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	rdx, QWORD PTR [r14+16]
	movzx	edi, BYTE PTR [rdx+25]
	test	dil, dil
	je	SHORT $LN191@Find_hint

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	rdx, QWORD PTR [r14+8]
	cmp	BYTE PTR [rdx+25], 0
	jne	$LN17@Find_hint
	mov	rax, r14
$LL189@Find_hint:
	mov	r8, rdx
	cmp	rax, QWORD PTR [rdx+16]
	jne	SHORT $LN196@Find_hint
	mov	rdx, QWORD PTR [rdx+8]
	mov	rax, r8
	cmp	BYTE PTR [rdx+25], 0
	je	SHORT $LL189@Find_hint

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree
; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())
; 58   :         } else {

	jmp	SHORT $LN196@Find_hint
$LN191@Find_hint:

; 453  :         while (!_Pnode->_Left->_Isnil) {

	mov	r8, QWORD PTR [rdx]
	cmp	BYTE PTR [r8+25], 0
	jne	SHORT $LN196@Find_hint
	npad	12
$LL195@Find_hint:
	mov	rax, QWORD PTR [r8]

; 454  :             _Pnode = _Pnode->_Left;

	mov	rdx, r8
	mov	r8, rax
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL195@Find_hint
$LN196@Find_hint:

; 1556 :                     }
; 1557 :                 }
; 1558 :             } else if (_DEBUG_LT_PRED(_Comp, _Traits::_Kfn(_Hint->_Myval), _Keyval)) {
; 1559 :                 // _Val > *_Hint
; 1560 :                 const auto _Next = (++(_Unchecked_const_iterator(_Hint, nullptr)))._Ptr;
; 1561 :                 if (_Next->_Isnil || _DEBUG_LT_PRED(_Comp, _Keyval, _Traits::_Kfn(_Next->_Myval))) {

	cmp	BYTE PTR [rdx+25], 0
	jne	$LN17@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);

	mov	rax, QWORD PTR [rdx+32]

; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);

	mov	r11, QWORD PTR [rdx+40]

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	cmp	rcx, rbx
	je	SHORT $LN287@Find_hint
$LL207@Find_hint:
	cmp	rax, r11
	je	SHORT $LN212@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	r8d, DWORD PTR [rcx]
	cmp	r8d, DWORD PTR [rax]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {

	jl	$LN17@Find_hint

; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {

	jg	SHORT $LN212@Find_hint

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	add	rcx, 4
	add	rax, 4
	cmp	rcx, rbx
	jne	SHORT $LL207@Find_hint
$LN287@Find_hint:

; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;

	cmp	rax, r11
	jne	$LN17@Find_hint
$LN212@Find_hint:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1611 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	r9, QWORD PTR [rbp+8]
	xor	edi, edi
	mov	QWORD PTR _Loc$39[rsp], r9
	mov	DWORD PTR _Loc$39[rsp+8], edi

; 1612 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1613 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [r9+25], dil
	jne	SHORT $LN23@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2329 :         return _STD lexicographical_compare(

	mov	rsi, QWORD PTR [r12]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);

	mov	rbx, QWORD PTR [r15]
	npad	6
$LL22@Find_hint:

; 5464 :     auto _UFirst1      = _Get_unwrapped(_First1);

	mov	rcx, QWORD PTR [r9+32]

; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);

	mov	rax, rsi
	mov	r11, QWORD PTR [r9+40]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1614 :             _Result._Location._Parent = _Trynode;

	mov	QWORD PTR _Loc$39[rsp], r9
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	cmp	rcx, r11
	je	SHORT $LN286@Find_hint
$LL36@Find_hint:
	cmp	rax, rbx
	je	SHORT $LN24@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	edx, DWORD PTR [rcx]
	cmp	edx, DWORD PTR [rax]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {

	jl	SHORT $LN297@Find_hint

; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {

	jg	SHORT $LN24@Find_hint

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	add	rcx, 4
	add	rax, 4
	cmp	rcx, r11
	jne	SHORT $LL36@Find_hint
$LN286@Find_hint:

; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;

	cmp	rax, rbx
	je	SHORT $LN24@Find_hint
$LN297@Find_hint:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1617 :                 _Trynode                 = _Trynode->_Right;

	mov	r9, QWORD PTR [r9+16]
	mov	DWORD PTR _Loc$39[rsp+8], edi

; 1618 :             } else {

	jmp	SHORT $LN25@Find_hint
$LN24@Find_hint:

; 1619 :                 _Result._Location._Child = _Tree_child::_Left;
; 1620 :                 _Result._Bound           = _Trynode;

	mov	rbp, r9
	mov	DWORD PTR _Loc$39[rsp+8], 1

; 1621 :                 _Trynode                 = _Trynode->_Left;

	mov	r9, QWORD PTR [r9]
$LN25@Find_hint:

; 1612 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1613 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [r9+25], dil
	je	SHORT $LL22@Find_hint
$LN23@Find_hint:

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rbp+25], dil
	jne	SHORT $LN49@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5464 :     auto _UFirst1      = _Get_unwrapped(_First1);

	mov	rcx, QWORD PTR [r12]

; 5465 :     const auto _ULast1 = _Get_unwrapped(_Last1);

	mov	r11, QWORD PTR [r15]

; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);

	mov	rax, QWORD PTR [rbp+32]

; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);

	mov	r9, QWORD PTR [rbp+40]

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	cmp	rcx, r11
	je	SHORT $LN285@Find_hint
	npad	5
$LL60@Find_hint:
	cmp	rax, r9
	je	SHORT $LN65@Find_hint
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	edx, DWORD PTR [rcx]
	cmp	edx, DWORD PTR [rax]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {

	jl	SHORT $LN49@Find_hint

; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {

	jg	SHORT $LN65@Find_hint

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	add	rcx, 4
	add	rax, 4
	cmp	rcx, r11
	jne	SHORT $LL60@Find_hint
$LN285@Find_hint:

; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;

	cmp	rax, r9
	jne	SHORT $LN49@Find_hint
$LN65@Find_hint:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1576 :                 return {{_Loc._Bound, _Tree_child::_Unused}, true};

	mov	QWORD PTR [r10], rbp
	mov	DWORD PTR [r10+8], 2
	mov	BYTE PTR [r10+16], 1
	jmp	SHORT $LN355@Find_hint
$LN49@Find_hint:

; 1577 :             }
; 1578 : 
; 1579 :             return {_Loc._Location, false};

	movups	xmm0, XMMWORD PTR _Loc$39[rsp]
	mov	BYTE PTR [r10+16], dil
	movups	XMMWORD PTR [r10], xmm0
	jmp	SHORT $LN355@Find_hint
$LN17@Find_hint:

; 1562 :                     // _Val > *_Hint and _Val < *next(_Hint); insert here
; 1563 :                     if (_Hint->_Right->_Isnil) {

	mov	BYTE PTR [r10+16], 0
	mov	rax, r10
	test	dil, dil
	je	SHORT $LN18@Find_hint

; 1564 :                         return {{_Hint, _Tree_child::_Right}, false};

	xor	edi, edi
	mov	QWORD PTR [r10], r14
	mov	DWORD PTR [r10+8], edi
	jmp	SHORT $LN1@Find_hint
$LN18@Find_hint:

; 1565 :                     }
; 1566 : 
; 1567 :                     return {{_Next, _Tree_child::_Left}, false};

	mov	QWORD PTR [r10], rdx
	mov	DWORD PTR [r10+8], 1
	jmp	SHORT $LN1@Find_hint
$LN14@Find_hint:

; 1568 :                 }
; 1569 :             } else {
; 1570 :                 // _Val is equivalent to *_Hint; don't insert
; 1571 :                 return {{_Hint, _Tree_child::_Right}, true};

	mov	QWORD PTR [r10], r14
	xor	edi, edi
	mov	BYTE PTR [r10+16], 1
$LN354@Find_hint:

; 1580 :         }
; 1581 :     }

	mov	DWORD PTR [r10+8], edi
$LN355@Find_hint:
	mov	rax, r10
$LN1@Find_hint:
	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
??$_Find_hint@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_hint_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Find_hint<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@AEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAAEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAAEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z PROC ; std::forward<std::vector<int,std::allocator<int> > &>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@AEAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAAEAV?$vector@HV?$allocator@H@std@@@0@AEAV10@@Z ENDP ; std::forward<std::vector<int,std::allocator<int> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
this$ = 64
_Al_$ = 72
_Myhead$ = 80
<_Vals_0>$ = 88
??$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > ><std::vector<int,std::allocator<int> > &>, COMDAT

; 806  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

$LN47:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	eax, eax

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rax

; 77   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+56]
	call	??2@YAPEAX_K@Z				; operator new

; 1129 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rsi+8], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 807  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

	lea	rcx, QWORD PTR [rax+32]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rdx, rbx
	call	??0?$vector@HV?$allocator@H@std@@@std@@QEAA@AEBV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rcx], rdi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rcx+8], rdi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

	mov	rcx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rcx+16], rdi

; 811  :         this->_Ptr->_Color = _Red;

	mov	rcx, QWORD PTR [rsi+8]
	mov	BYTE PTR [rcx+24], 0
	mov	rcx, QWORD PTR [rsi+8]
	mov	BYTE PTR [rcx+25], 0

; 812  :         this->_Ptr->_Isnil = false;
; 813  :     }

	mov	rax, rsi
	mov	rbx, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > ><std::vector<int,std::allocator<int> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 64
_Al_$ = 72
_Myhead$ = 80
<_Vals_0>$ = 88
?dtor$1@?0???$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > ><std::vector<int,std::allocator<int> > &>'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
?dtor$1@?0???$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > ><std::vector<int,std::allocator<int> > &>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
this$ = 64
_Al_$ = 72
_Myhead$ = 80
<_Vals_0>$ = 88
?dtor$0@?0???$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z@4HA PROC ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > ><std::vector<int,std::allocator<int> > &>'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
?dtor$0@?0???$?0AEAV?$vector@HV?$allocator@H@std@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEAV?$vector@HV?$allocator@H@std@@@1@@Z@4HA ENDP ; `std::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > ><std::vector<int,std::allocator<int> > &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@AEBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAAEBV?$vector@HV?$allocator@H@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAAEBV?$vector@HV?$allocator@H@std@@@0@AEBV10@@Z PROC ; std::forward<std::vector<int,std::allocator<int> > const &>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@AEBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAAEBV?$vector@HV?$allocator@H@std@@@0@AEBV10@@Z ENDP ; std::forward<std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>, COMDAT

; 670  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN65:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 670  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	rsi, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 670  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	rbx, r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax

; 683  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rdx, QWORD PTR [r8+8]
	sub	rdx, QWORD PTR [r8]
	sar	rdx, 2

; 2063 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN36@construct

; 2004 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN63@construct

; 2006 :         }
; 2007 : 
; 2008 :         _Buy_raw(_Newcapacity);

	mov	rcx, rsi
	mov	QWORD PTR [rsp+48], rdi
	call	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4432 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

	mov	rdx, QWORD PTR [rbx]

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rbx, QWORD PTR [rbx+8]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2072 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1819 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 2
	lea	rax, QWORD PTR [rdi+rbx*4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2072 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+48]
	mov	QWORD PTR [rsi+8], rax
$LN36@construct:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 679  :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN63@construct:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2005 :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
	int	3
$LN61@construct:
??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEBV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEBV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEBH@std@@YA?A_TAEBQEBH@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEBH@std@@YA?A_TAEBQEBH@Z PROC	; std::_Get_unwrapped<int const * const &>, COMDAT

; 980  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 981  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 982  :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 983  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 984  :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 985  :     } else {
; 986  :         return static_cast<_Iter&&>(_It);
; 987  :     }
; 988  : }

	ret	0
??$_Get_unwrapped@AEBQEBH@std@@YA?A_TAEBQEBH@Z ENDP	; std::_Get_unwrapped<int const * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Idl_distance@PEBHPEBH@std@@YA?A_PAEBQEBH0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@PEBHPEBH@std@@YA?A_PAEBQEBH0@Z PROC	; std::_Idl_distance<int const *,int const *>, COMDAT

; 1125 :     // tries to get the distance between _First and _Last if they are random-access iterators
; 1126 :     if constexpr (_Is_ranges_random_iter_v<_Iter>) {
; 1127 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 1128 :     } else {
; 1129 :         return _Distance_unknown{};
; 1130 :     }
; 1131 : }

	ret	0
??$_Idl_distance@PEBHPEBH@std@@YA?A_PAEBQEBH0@Z ENDP	; std::_Idl_distance<int const *,int const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Get_unwrapped_n@AEBQEBH_J@std@@YA?A_TAEBQEBH_J@Z
_TEXT	SEGMENT
_It$ = 8
_Off$dead$ = 16
??$_Get_unwrapped_n@AEBQEBH_J@std@@YA?A_TAEBQEBH_J@Z PROC ; std::_Get_unwrapped_n<int const * const &,__int64>, COMDAT

; 1046 :     if constexpr (is_pointer_v<decay_t<_Iter>>) {
; 1047 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1048 :     } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
; 1049 :         // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
; 1050 :         using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
; 1051 :         using _CDiff     = common_type_t<_Diff, _IDiff>;
; 1052 :         const auto _COff = static_cast<_CDiff>(_Off);
; 1053 : 
; 1054 :         _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 1055 :                         && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 1056 :             "integer overflow");
; 1057 :         (void) _COff;
; 1058 : 
; 1059 :         _It._Verify_offset(static_cast<_IDiff>(_Off));
; 1060 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1061 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1062 :         // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
; 1063 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1064 :     } else {
; 1065 :         // pass through iterator that doesn't participate in checking
; 1066 :         return static_cast<_Iter&&>(_It);
; 1067 :     }
; 1068 : }

	ret	0
??$_Get_unwrapped_n@AEBQEBH_J@std@@YA?A_TAEBQEBH_J@Z ENDP ; std::_Get_unwrapped_n<int const * const &,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$equal@PEBHPEBHU?$equal_to@X@std@@@std@@YA_NQEBH00U?$equal_to@X@0@@Z
_TEXT	SEGMENT
_First1$ = 48
_Last1$ = 56
_First2$ = 64
_Pred$dead$ = 72
??$equal@PEBHPEBHU?$equal_to@X@std@@@std@@YA_NQEBH00U?$equal_to@X@0@@Z PROC ; std::equal<int const *,int const *,std::equal_to<void> >, COMDAT

; 5161 : _NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {

$LN15:
	sub	rsp, 40					; 00000028H

; 5149 :     return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));

	sub	rdx, rcx

; 5161 : _NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {

	mov	rax, r8

; 5149 :     return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));

	mov	r8, rdx
	mov	rdx, rax
	call	memcmp

; 5162 :     // compare [_First1, _Last1) to [_First2, ...)
; 5163 :     _Adl_verify_range(_First1, _Last1);
; 5164 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5165 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5166 :     auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
; 5167 :     if constexpr (_Equal_memcmp_is_safe<decltype(_UFirst1), decltype(_UFirst2), _Pr>) {
; 5168 : #if _HAS_CXX20
; 5169 :         if (!_STD is_constant_evaluated())
; 5170 : #endif // _HAS_CXX20
; 5171 :         {
; 5172 :             return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;

	test	eax, eax
	sete	al

; 5173 :         }
; 5174 :     }
; 5175 : 
; 5176 :     for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
; 5177 :         if (!_Pred(*_UFirst1, *_UFirst2)) {
; 5178 :             return false;
; 5179 :         }
; 5180 :     }
; 5181 : 
; 5182 :     return true;
; 5183 : }

	add	rsp, 40					; 00000028H
	ret	0
??$equal@PEBHPEBHU?$equal_to@X@std@@@std@@YA_NQEBH00U?$equal_to@X@0@@Z ENDP ; std::equal<int const *,int const *,std::equal_to<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@H@std@@YA$$QEAHAEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@H@std@@YA$$QEAHAEAH@Z PROC			; std::forward<int>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@H@std@@YA$$QEAHAEAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH$$QEAH@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH$$QEAH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>, COMDAT

; 671  : #if _HAS_CXX20
; 672  :         if (_STD is_constant_evaluated()) {
; 673  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 674  :         } else
; 675  : #endif // _HAS_CXX20
; 676  :         {
; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax

; 678  :         }
; 679  :     }

	ret	0
??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAEAV?$allocator@H@1@QEAH$$QEAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@PEAH@std@@YA$$QEAPEAHAEAPEAH@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAH@std@@YA$$QEAPEAHAEAPEAH@Z PROC		; std::forward<int *>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@PEAH@std@@YA$$QEAPEAHAEAPEAH@Z ENDP		; std::forward<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
;	COMDAT ??$exchange@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *,std::nullptr_t>, COMDAT

; 755  :     // assign _New_val to _Val, return previous _Val
; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 758  :     return _Old_val;
; 759  : }

	ret	0
??$exchange@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@$$T@std@@YAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\utility
;	COMDAT ??$exchange@PEAU?$_Tree_node@HPEAX@std@@$$T@std@@YAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAU?$_Tree_node@HPEAX@std@@$$T@std@@YAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Tree_node<int,void *> *,std::nullptr_t>, COMDAT

; 755  :     // assign _New_val to _Val, return previous _Val
; 756  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 757  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rdx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rdx

; 758  :     return _Old_val;
; 759  : }

	ret	0
??$exchange@PEAU?$_Tree_node@HPEAX@std@@$$T@std@@YAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Tree_node<int,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >, COMDAT

; 785  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN35:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	eax, eax

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rax

; 77   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+56]
	call	??2@YAPEAX_K@Z				; operator new

; 1129 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rbx+8], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 787  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z@4HA PROC ; `std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z@4HA ENDP ; `std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al_$ = 56
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >, COMDAT

; 785  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

$LN35:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	xor	eax, eax

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], rax

; 77   :         return ::operator new(_Bytes);

	lea	ecx, QWORD PTR [rax+32]
	call	??2@YAPEAX_K@Z				; operator new

; 1129 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rbx+8], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 787  :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Al_$ = 56
?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z@4HA PROC ; `std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
?dtor$0@?0???0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z@4HA ENDP ; `std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<int,void *> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator--, COMDAT

; 72   :         if (_Ptr->_Isnil) {

	mov	rdx, QWORD PTR [rcx]
	mov	r8, rcx
	cmp	BYTE PTR [rdx+25], 0
	je	SHORT $LN4@operator

; 73   :             _Ptr = _Ptr->_Right; // end() ==> rightmost

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx], rax

; 85   :         }
; 86   : 
; 87   :         return *this;
; 88   :     }

	mov	rax, rcx
	ret	0
$LN4@operator:

; 74   :         } else if (_Ptr->_Left->_Isnil) { // climb looking for left subtree

	mov	rcx, QWORD PTR [rdx]
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LN6@operator

; 75   :             _Nodeptr _Pnode;
; 76   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Left) {

	mov	rax, QWORD PTR [rdx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN3@operator
	mov	rcx, rdx
	mov	r9, rdx
$LL2@operator:
	mov	r10, rax
	mov	r11, rax
	mov	rdx, r9
	cmp	rcx, QWORD PTR [rax]
	jne	SHORT $LN3@operator
	mov	rcx, rax

; 77   :                 _Ptr = _Pnode; // ==> parent while left subtree

	mov	QWORD PTR [r8], rax
	mov	rax, QWORD PTR [rax+8]
	mov	r9, rcx
	mov	rdx, rcx
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 78   :             }
; 79   : 
; 80   :             if (!_Ptr->_Isnil) { // decrement non-begin()

	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN24@operator

; 81   :                 _Ptr = _Pnode; // ==> parent if not head

	mov	QWORD PTR [r8], rax

; 85   :         }
; 86   : 
; 87   :         return *this;
; 88   :     }

	mov	rax, r8
	ret	0
$LN6@operator:

; 445  :         while (!_Pnode->_Right->_Isnil) {

	mov	rax, QWORD PTR [rcx+16]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN12@operator
	npad	5
$LL11@operator:

; 446  :             _Pnode = _Pnode->_Right;

	mov	rcx, rax
	mov	rax, QWORD PTR [rax+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL11@operator
$LN12@operator:

; 82   :             }
; 83   :         } else {
; 84   :             _Ptr = _Mytree::_Max(_Ptr->_Left); // ==> largest of left subtree

	mov	QWORD PTR [r8], rcx
$LN24@operator:

; 85   :         }
; 86   : 
; 87   :         return *this;
; 88   :     }

	mov	rax, r8
	ret	0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??R?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEBA_NAEBV?$vector@HV?$allocator@H@std@@@1@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_Left$ = 16
_Right$ = 24
??R?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEBA_NAEBV?$vector@HV?$allocator@H@std@@@1@0@Z PROC ; std::less<std::vector<int,std::allocator<int> > >::operator(), COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5464 :     auto _UFirst1      = _Get_unwrapped(_First1);

	mov	rcx, QWORD PTR [rdx]

; 5465 :     const auto _ULast1 = _Get_unwrapped(_Last1);

	mov	r10, QWORD PTR [rdx+8]

; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);

	mov	rax, QWORD PTR [r8]

; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);

	mov	r9, QWORD PTR [r8+8]

; 5468 : 
; 5469 :     using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
; 5470 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5471 : #if _HAS_CXX20
; 5472 :         if (!_STD is_constant_evaluated())
; 5473 : #endif // _HAS_CXX20
; 5474 :         {
; 5475 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5476 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5477 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5478 :             return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
; 5479 :         }
; 5480 :     }
; 5481 : 
; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	cmp	rcx, r10
	je	SHORT $LN27@operator
$LL10@operator:
	cmp	rax, r9
	je	SHORT $LN15@operator
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	edx, DWORD PTR [rcx]
	cmp	edx, DWORD PTR [rax]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {

	jl	SHORT $LN22@operator

; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {

	jg	SHORT $LN15@operator

; 5468 : 
; 5469 :     using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
; 5470 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5471 : #if _HAS_CXX20
; 5472 :         if (!_STD is_constant_evaluated())
; 5473 : #endif // _HAS_CXX20
; 5474 :         {
; 5475 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5476 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5477 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5478 :             return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
; 5479 :         }
; 5480 :     }
; 5481 : 
; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	add	rcx, 4
	add	rax, 4
	cmp	rcx, r10
	jne	SHORT $LL10@operator
$LN27@operator:

; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;

	cmp	rax, r9
	je	SHORT $LN15@operator
$LN22@operator:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 144  :     }

	mov	al, 1
	ret	0
$LN15@operator:
	xor	al, al
	ret	0
??R?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@QEBA_NAEBV?$vector@HV?$allocator@H@std@@@1@0@Z ENDP ; std::less<std::vector<int,std::allocator<int> > >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_scary@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Get_scary, COMDAT

; 1971 :         return _STD addressof(_Mypair._Myval2._Myval2);

	mov	rax, rcx

; 1972 :     }

	ret	0
?_Get_scary@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getcomp@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Getcomp, COMDAT

; 1955 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1956 :     }

	ret	0
?_Getcomp@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBAAEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\set
;	COMDAT ?_Kfn@?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@SAAEBV?$vector@HV?$allocator@H@std@@@2@AEBV32@@Z
_TEXT	SEGMENT
_Val$ = 8
?_Kfn@?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@SAAEBV?$vector@HV?$allocator@H@std@@@2@AEBV32@@Z PROC ; std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0>::_Kfn, COMDAT

; 47   :         return _Val;

	mov	rax, rcx

; 48   :     }

	ret	0
?_Kfn@?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@SAAEBV?$vector@HV?$allocator@H@std@@@2@AEBV32@@Z ENDP ; std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0>::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator--, COMDAT

; 72   :         if (_Ptr->_Isnil) {

	mov	rdx, QWORD PTR [rcx]
	mov	r8, rcx
	cmp	BYTE PTR [rdx+25], 0
	je	SHORT $LN4@operator

; 73   :             _Ptr = _Ptr->_Right; // end() ==> rightmost

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx], rax

; 85   :         }
; 86   : 
; 87   :         return *this;
; 88   :     }

	mov	rax, rcx
	ret	0
$LN4@operator:

; 74   :         } else if (_Ptr->_Left->_Isnil) { // climb looking for left subtree

	mov	rcx, QWORD PTR [rdx]
	cmp	BYTE PTR [rcx+25], 0
	je	SHORT $LN6@operator

; 75   :             _Nodeptr _Pnode;
; 76   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Left) {

	mov	rax, QWORD PTR [rdx+8]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN3@operator
	mov	rcx, rdx
	mov	r9, rdx
$LL2@operator:
	mov	r10, rax
	mov	r11, rax
	mov	rdx, r9
	cmp	rcx, QWORD PTR [rax]
	jne	SHORT $LN3@operator
	mov	rcx, rax

; 77   :                 _Ptr = _Pnode; // ==> parent while left subtree

	mov	QWORD PTR [r8], rax
	mov	rax, QWORD PTR [rax+8]
	mov	r9, rcx
	mov	rdx, rcx
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 78   :             }
; 79   : 
; 80   :             if (!_Ptr->_Isnil) { // decrement non-begin()

	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN24@operator

; 81   :                 _Ptr = _Pnode; // ==> parent if not head

	mov	QWORD PTR [r8], rax

; 85   :         }
; 86   : 
; 87   :         return *this;
; 88   :     }

	mov	rax, r8
	ret	0
$LN6@operator:

; 445  :         while (!_Pnode->_Right->_Isnil) {

	mov	rax, QWORD PTR [rcx+16]
	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN12@operator
	npad	5
$LL11@operator:

; 446  :             _Pnode = _Pnode->_Right;

	mov	rcx, rax
	mov	rax, QWORD PTR [rax+16]
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL11@operator
$LN12@operator:

; 82   :             }
; 83   :         } else {
; 84   :             _Ptr = _Mytree::_Max(_Ptr->_Left); // ==> largest of left subtree

	mov	QWORD PTR [r8], rcx
$LN24@operator:

; 85   :         }
; 86   : 
; 87   :         return *this;
; 88   :     }

	mov	rax, r8
	ret	0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??R?$less@H@std@@QEBA_NAEBH0@Z
_TEXT	SEGMENT
this$dead$ = 8
_Left$ = 16
_Right$ = 24
??R?$less@H@std@@QEBA_NAEBH0@Z PROC			; std::less<int>::operator(), COMDAT

; 143  :         return _Left < _Right;

	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rdx], eax
	setl	al

; 144  :     }

	ret	0
??R?$less@H@std@@QEBA_NAEBH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_scary@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Get_scary, COMDAT

; 1971 :         return _STD addressof(_Mypair._Myval2._Myval2);

	mov	rax, rcx

; 1972 :     }

	ret	0
?_Get_scary@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBAPEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBAAEBU?$less@H@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getcomp@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBAAEBU?$less@H@2@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getcomp, COMDAT

; 1955 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1956 :     }

	ret	0
?_Getcomp@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBAAEBU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\set
;	COMDAT ?_Kfn@?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@SAAEBHAEBH@Z
_TEXT	SEGMENT
_Val$ = 8
?_Kfn@?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@SAAEBHAEBH@Z PROC ; std::_Tset_traits<int,std::less<int>,std::allocator<int>,0>::_Kfn, COMDAT

; 47   :         return _Val;

	mov	rax, rcx

; 48   :     }

	ret	0
?_Kfn@?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@SAAEBHAEBH@Z ENDP ; std::_Tset_traits<int,std::less<int>,std::allocator<int>,0>::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Allocate, COMDAT

; 1127 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN28:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], 0

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 56					; 00000038H
	call	??2@YAPEAX_K@Z				; operator new

; 1129 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rbx+8], rax

; 1130 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >, COMDAT

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], 0
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAAXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::_Allocate, COMDAT

; 1127 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

$LN28:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1128 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	QWORD PTR [rcx+8], 0

; 77   :         return ::operator new(_Bytes);

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new

; 1129 :         _Ptr = _Al.allocate(1);

	mov	QWORD PTR [rbx+8], rax

; 1130 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAAXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al_$ = 16
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >, COMDAT

; 1121 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	mov	QWORD PTR [rcx+8], 0
	ret	0
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@QEAA@AEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::vector<int,std::allocator<int> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::vector<int,std::allocator<int> > >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Max@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@PEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Max, COMDAT

; 445  :         while (!_Pnode->_Right->_Isnil) {

	mov	rdx, QWORD PTR [rcx+16]
	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN9@Max
	npad	6
$LL2@Max:

; 446  :             _Pnode = _Pnode->_Right;

	mov	rax, rdx
	mov	rdx, QWORD PTR [rdx+16]
	cmp	BYTE PTR [rdx+25], 0
	je	SHORT $LL2@Max

; 450  :     }

	ret	0
$LN9@Max:

; 447  :         }
; 448  : 
; 449  :         return _Pnode;

	mov	rax, rcx

; 450  :     }

	ret	0
?_Max@?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@2@PEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@H@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@H@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_first, COMDAT

; 1504 :         return *this;

	mov	rax, rcx

; 1505 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QEBAAEBU?$less@H@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<int,void *> >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPEAU?$_Tree_node@HPEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Max@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPEAU?$_Tree_node@HPEAX@2@PEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Max, COMDAT

; 445  :         while (!_Pnode->_Right->_Isnil) {

	mov	rdx, QWORD PTR [rcx+16]
	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN9@Max
	npad	6
$LL2@Max:

; 446  :             _Pnode = _Pnode->_Right;

	mov	rax, rdx
	mov	rdx, QWORD PTR [rdx+16]
	cmp	BYTE PTR [rdx+25], 0
	je	SHORT $LL2@Max

; 450  :     }

	ret	0
$LN9@Max:

; 447  :         }
; 448  : 
; 449  :         return _Pnode;

	mov	rax, rcx

; 450  :     }

	ret	0
?_Max@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPEAU?$_Tree_node@HPEAX@2@PEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Find_lower_bound@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@HPEAX@std@@@1@AEBH@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Keyval$ = 24
??$_Find_lower_bound@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@HPEAX@std@@@1@AEBH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_lower_bound<int>, COMDAT

; 1610 :         const auto _Scary = _Get_scary();
; 1611 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	r9, QWORD PTR [rcx]
	mov	DWORD PTR [rdx+8], 0
	mov	QWORD PTR [rdx+16], r9
	mov	rax, QWORD PTR [r9+8]
	mov	QWORD PTR [rdx], rax

; 1612 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1613 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [rax+25], 0
	jne	SHORT $LN12@Find_lower
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 143  :         return _Left < _Right;

	mov	r8d, DWORD PTR [r8]
	npad	2
$LL2@Find_lower:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1614 :             _Result._Location._Parent = _Trynode;

	mov	QWORD PTR [rdx], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 143  :         return _Left < _Right;

	cmp	DWORD PTR [rax+28], r8d
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1615 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

	jge	SHORT $LN4@Find_lower

; 1616 :                 _Result._Location._Child = _Tree_child::_Right;
; 1617 :                 _Trynode                 = _Trynode->_Right;

	mov	rax, QWORD PTR [rax+16]
	xor	ecx, ecx

; 1618 :             } else {

	jmp	SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1619 :                 _Result._Location._Child = _Tree_child::_Left;
; 1620 :                 _Result._Bound           = _Trynode;

	mov	QWORD PTR [rdx+16], rax

; 1621 :                 _Trynode                 = _Trynode->_Left;

	mov	ecx, 1
	mov	rax, QWORD PTR [rax]
$LN5@Find_lower:

; 1612 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1613 :         while (!_Trynode->_Isnil) {

	mov	DWORD PTR [rdx+8], ecx
	cmp	BYTE PTR [rax+25], 0
	je	SHORT $LL2@Find_lower
$LN12@Find_lower:

; 1622 :             }
; 1623 :         }
; 1624 : 
; 1625 :         return _Result;
; 1626 :     }

	mov	rax, rdx
	ret	0
??$_Find_lower_bound@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@HPEAX@std@@@1@AEBH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_lower_bound<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@HPEAX@1@AEBH@Z
_TEXT	SEGMENT
this$dead$ = 8
_Bound$ = 16
_Keyval$ = 24
??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@HPEAX@1@AEBH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Lower_bound_duplicate<int>, COMDAT

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN3@Lower_boun
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 143  :         return _Left < _Right;

	mov	eax, DWORD PTR [rdx+28]
	cmp	DWORD PTR [r8], eax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	jl	SHORT $LN3@Lower_boun
	mov	al, 1

; 1606 :     }

	ret	0
$LN3@Lower_boun:

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	xor	al, al

; 1606 :     }

	ret	0
??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@HPEAX@1@AEBH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Lower_bound_duplicate<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$construct@HAEAH@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@QEAHAEAH@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@HAEAH@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@QEAHAEAH@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int &>, COMDAT

; 671  : #if _HAS_CXX20
; 672  :         if (_STD is_constant_evaluated()) {
; 673  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 674  :         } else
; 675  : #endif // _HAS_CXX20
; 676  :         {
; 677  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax

; 678  :         }
; 679  :     }

	ret	0
??$construct@HAEAH@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@HPEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@HPEAX@std@@@1@QEAHAEAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_Tree_node@HPEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@HPEAX@0@0@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_Tree_node@HPEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@HPEAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>, COMDAT

; 259  : #if _HAS_CXX20
; 260  :     if (_STD is_constant_evaluated()) {
; 261  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 262  :     } else
; 263  : #endif // _HAS_CXX20
; 264  :     {
; 265  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 266  :     }
; 267  : }

	ret	0
??$_Construct_in_place@PEAU?$_Tree_node@HPEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@HPEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
;	COMDAT ??$?MHV?$allocator@H@std@@@std@@YA_NAEBV?$vector@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$?MHV?$allocator@H@std@@@std@@YA_NAEBV?$vector@HV?$allocator@H@std@@@0@0@Z PROC ; std::operator<<int,std::allocator<int> >, COMDAT
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5464 :     auto _UFirst1      = _Get_unwrapped(_First1);

	mov	r8, QWORD PTR [rcx]

; 5465 :     const auto _ULast1 = _Get_unwrapped(_Last1);

	mov	r10, QWORD PTR [rcx+8]

; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);

	mov	rax, QWORD PTR [rdx]

; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);

	mov	r9, QWORD PTR [rdx+8]

; 5468 : 
; 5469 :     using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
; 5470 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5471 : #if _HAS_CXX20
; 5472 :         if (!_STD is_constant_evaluated())
; 5473 : #endif // _HAS_CXX20
; 5474 :         {
; 5475 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5476 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5477 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5478 :             return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
; 5479 :         }
; 5480 :     }
; 5481 : 
; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	cmp	r8, r10
	je	SHORT $LN25@operator
$LL8@operator:
	cmp	rax, r9
	je	SHORT $LN13@operator
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	ecx, DWORD PTR [r8]
	cmp	ecx, DWORD PTR [rax]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {

	jl	SHORT $LN20@operator

; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {

	jg	SHORT $LN13@operator

; 5468 : 
; 5469 :     using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
; 5470 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5471 : #if _HAS_CXX20
; 5472 :         if (!_STD is_constant_evaluated())
; 5473 : #endif // _HAS_CXX20
; 5474 :         {
; 5475 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5476 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5477 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5478 :             return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
; 5479 :         }
; 5480 :     }
; 5481 : 
; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	add	r8, 4
	add	rax, 4
	cmp	r8, r10
	jne	SHORT $LL8@operator
$LN25@operator:

; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;

	cmp	rax, r9
	je	SHORT $LN13@operator
$LN20@operator:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2332 : }

	mov	al, 1
	ret	0
$LN13@operator:
	xor	al, al
	ret	0
??$?MHV?$allocator@H@std@@@std@@YA_NAEBV?$vector@HV?$allocator@H@std@@@0@0@Z ENDP ; std::operator<<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
this$ = 16
__$ReturnUdt$ = 24
_Keyval$ = 32
??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Find_lower_bound<std::vector<int,std::allocator<int> > >, COMDAT

; 1609 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

$LN47:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi

; 1610 :         const auto _Scary = _Get_scary();
; 1611 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

	mov	rax, QWORD PTR [rcx]
	xor	esi, esi
	mov	r11, rdx
	mov	r9, QWORD PTR [rax+8]
	mov	QWORD PTR [rdx], r9
	mov	DWORD PTR [rdx+8], esi
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx+16], rax

; 1612 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1613 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [r9+25], sil
	jne	SHORT $LN38@Find_lower
	mov	QWORD PTR [rsp+16], rbx
	npad	6
$LL2@Find_lower:

; 1614 :             _Result._Location._Parent = _Trynode;

	mov	QWORD PTR [r11], r9
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5464 :     auto _UFirst1      = _Get_unwrapped(_First1);

	mov	rcx, QWORD PTR [r9+32]

; 5465 :     const auto _ULast1 = _Get_unwrapped(_Last1);

	mov	rbx, QWORD PTR [r9+40]

; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);

	mov	rax, QWORD PTR [r8]

; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);

	mov	r10, QWORD PTR [r8+8]

; 5468 : 
; 5469 :     using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
; 5470 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5471 : #if _HAS_CXX20
; 5472 :         if (!_STD is_constant_evaluated())
; 5473 : #endif // _HAS_CXX20
; 5474 :         {
; 5475 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5476 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5477 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5478 :             return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
; 5479 :         }
; 5480 :     }
; 5481 : 
; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	cmp	rcx, rbx
	je	SHORT $LN36@Find_lower
$LL16@Find_lower:
	cmp	rax, r10
	je	SHORT $LN4@Find_lower
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	edx, DWORD PTR [rcx]
	cmp	edx, DWORD PTR [rax]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {

	jl	SHORT $LN37@Find_lower

; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {

	jg	SHORT $LN4@Find_lower

; 5468 : 
; 5469 :     using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
; 5470 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5471 : #if _HAS_CXX20
; 5472 :         if (!_STD is_constant_evaluated())
; 5473 : #endif // _HAS_CXX20
; 5474 :         {
; 5475 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5476 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5477 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5478 :             return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
; 5479 :         }
; 5480 :     }
; 5481 : 
; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	add	rcx, 4
	add	rax, 4
	cmp	rcx, rbx
	jne	SHORT $LL16@Find_lower
$LN36@Find_lower:

; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;

	cmp	rax, r10
	je	SHORT $LN4@Find_lower
$LN37@Find_lower:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1616 :                 _Result._Location._Child = _Tree_child::_Right;

	mov	DWORD PTR [r11+8], esi

; 1617 :                 _Trynode                 = _Trynode->_Right;

	mov	r9, QWORD PTR [r9+16]

; 1618 :             } else {

	jmp	SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1619 :                 _Result._Location._Child = _Tree_child::_Left;

	mov	DWORD PTR [r11+8], 1

; 1620 :                 _Result._Bound           = _Trynode;

	mov	QWORD PTR [r11+16], r9

; 1621 :                 _Trynode                 = _Trynode->_Left;

	mov	r9, QWORD PTR [r9]
$LN5@Find_lower:

; 1612 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1613 :         while (!_Trynode->_Isnil) {

	cmp	BYTE PTR [r9+25], sil
	je	SHORT $LL2@Find_lower
	mov	rbx, QWORD PTR [rsp+16]
$LN38@Find_lower:

; 1622 :             }
; 1623 :         }
; 1624 : 
; 1625 :         return _Result;
; 1626 :     }

	mov	rsi, QWORD PTR [rsp+32]
	mov	rax, r11
	pop	rdi
	ret	0
??$_Find_lower_bound@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA?AU?$_Tree_find_result@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Find_lower_bound<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree
;	COMDAT ??$_Lower_bound_duplicate@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Bound$ = 16
_Keyval$ = 24
??$_Lower_bound_duplicate@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Lower_bound_duplicate<std::vector<int,std::allocator<int> > >, COMDAT

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	cmp	BYTE PTR [rdx+25], 0
	jne	SHORT $LN3@Lower_boun
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5464 :     auto _UFirst1      = _Get_unwrapped(_First1);

	mov	rcx, QWORD PTR [r8]

; 5465 :     const auto _ULast1 = _Get_unwrapped(_Last1);

	mov	r10, QWORD PTR [r8+8]

; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);

	mov	rax, QWORD PTR [rdx+32]

; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);

	mov	r9, QWORD PTR [rdx+40]

; 5468 : 
; 5469 :     using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
; 5470 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5471 : #if _HAS_CXX20
; 5472 :         if (!_STD is_constant_evaluated())
; 5473 : #endif // _HAS_CXX20
; 5474 :         {
; 5475 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5476 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5477 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5478 :             return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
; 5479 :         }
; 5480 :     }
; 5481 : 
; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	cmp	rcx, r10
	je	SHORT $LN31@Lower_boun
	npad	6
$LL14@Lower_boun:
	cmp	rax, r9
	je	SHORT $LN19@Lower_boun
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	edx, DWORD PTR [rcx]
	cmp	edx, DWORD PTR [rax]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {

	jl	SHORT $LN3@Lower_boun

; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {

	jg	SHORT $LN19@Lower_boun

; 5468 : 
; 5469 :     using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
; 5470 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5471 : #if _HAS_CXX20
; 5472 :         if (!_STD is_constant_evaluated())
; 5473 : #endif // _HAS_CXX20
; 5474 :         {
; 5475 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5476 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5477 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5478 :             return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
; 5479 :         }
; 5480 :     }
; 5481 : 
; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	add	rcx, 4
	add	rax, 4
	cmp	rcx, r10
	jne	SHORT $LL14@Lower_boun
$LN31@Lower_boun:

; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;

	cmp	rax, r9
	jne	SHORT $LN3@Lower_boun
$LN19@Lower_boun:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xtree

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	mov	al, 1

; 1606 :     }

	ret	0
$LN3@Lower_boun:

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

	xor	al, al

; 1606 :     }

	ret	0
??$_Lower_bound_duplicate@V?$vector@HV?$allocator@H@std@@@std@@@?$_Tree@V?$_Tset_traits@V?$vector@HV?$allocator@H@std@@@std@@U?$less@V?$vector@HV?$allocator@H@std@@@std@@@2@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@@std@@IEBA_NQEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@1@AEBV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Tree<std::_Tset_traits<std::vector<int,std::allocator<int> >,std::less<std::vector<int,std::allocator<int> > >,std::allocator<std::vector<int,std::allocator<int> > >,0> >::_Lower_bound_duplicate<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory
;	COMDAT ??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > &>, COMDAT

; 670  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN65:
	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	sub	rsp, 32					; 00000020H
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	xor	eax, eax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 670  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	rsi, rdx
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx], rax
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 670  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	mov	rbx, r8
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rdx+8], rax
	mov	QWORD PTR [rdx+16], rax

; 683  :         const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);

	mov	rdx, QWORD PTR [r8+8]
	sub	rdx, QWORD PTR [r8]
	sar	rdx, 2

; 2063 :         if (_Count != 0) {

	test	rdx, rdx
	je	SHORT $LN36@construct

; 2004 :         if (_Newcapacity > max_size()) {

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	ja	SHORT $LN63@construct

; 2006 :         }
; 2007 : 
; 2008 :         _Buy_raw(_Newcapacity);

	mov	rcx, rsi
	mov	QWORD PTR [rsp+48], rdi
	call	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AEAAX_K@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4432 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

	mov	rdx, QWORD PTR [rbx]

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rbx, QWORD PTR [rbx+8]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2072 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsi]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 4435 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rdx

; 4436 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 1819 :                 _Dest += _ULast - _UFirst;

	sar	rbx, 2
	lea	rax, QWORD PTR [rdi+rbx*4]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2072 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	rdi, QWORD PTR [rsp+48]
	mov	QWORD PTR [rsi+8], rax
$LN36@construct:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xmemory

; 679  :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN63@construct:
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\vector

; 2005 :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
	int	3
$LN61@construct:
??$construct@V?$vector@HV?$allocator@H@std@@@std@@AEAV12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@1@QEAV?$vector@HV?$allocator@H@std@@@1@AEAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Construct_in_place@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@0@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *,std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * &>, COMDAT

; 259  : #if _HAS_CXX20
; 260  :     if (_STD is_constant_evaluated()) {
; 261  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 262  :     } else
; 263  : #endif // _HAS_CXX20
; 264  :     {
; 265  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 266  :     }
; 267  : }

	ret	0
??$_Construct_in_place@PEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@AEAPEAU12@@std@@YAXAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> *,std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Adl_verify_range@PEBHPEBH@std@@YAXAEBQEBH0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEBHPEBH@std@@YAXAEBQEBH0@Z PROC	; std::_Adl_verify_range<int const *,int const *>, COMDAT

; 957  :     // check that [_First, _Last) forms an iterator range
; 958  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 959  :         _Verify_range(_First, _Last);
; 960  :     }
; 961  : }

	ret	0
??$_Adl_verify_range@PEBHPEBH@std@@YAXAEBQEBH0@Z ENDP	; std::_Adl_verify_range<int const *,int const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$_Memcmp_ranges@PEBHPEBH@std@@YAHPEBH00@Z
_TEXT	SEGMENT
_First1$ = 8
_Last1$ = 16
_First2$ = 24
??$_Memcmp_ranges@PEBHPEBH@std@@YAHPEBH00@Z PROC	; std::_Memcmp_ranges<int const *,int const *>, COMDAT

; 5145 :     _STL_INTERNAL_STATIC_ASSERT(sizeof(_Iter_value_t<_CtgIt1>) == sizeof(_Iter_value_t<_CtgIt2>));
; 5146 :     const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
; 5147 :     const auto _Last1_ch  = reinterpret_cast<const char*>(_To_address(_Last1));
; 5148 :     const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
; 5149 :     return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));

	sub	rdx, rcx
	mov	rax, r8
	mov	r8, rdx
	mov	rdx, rax
	jmp	memcmp
??$_Memcmp_ranges@PEBHPEBH@std@@YAHPEBH00@Z ENDP	; std::_Memcmp_ranges<int const *,int const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$?RAEBHAEBH@?$equal_to@X@std@@QEBA_NAEBH0@Z
_TEXT	SEGMENT
this$dead$ = 8
_Left$ = 16
_Right$ = 24
??$?RAEBHAEBH@?$equal_to@X@std@@QEBA_NAEBH0@Z PROC	; std::equal_to<void>::operator()<int const &,int const &>, COMDAT

; 213  :         return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);

	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rdx], eax
	sete	al

; 214  :     }

	ret	0
??$?RAEBHAEBH@?$equal_to@X@std@@QEBA_NAEBH0@Z ENDP	; std::equal_to<void>::operator()<int const &,int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > const >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 282  : }

	ret	0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::vector<int,std::allocator<int> > > > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<int> > const >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 282  : }

	ret	0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPEBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<int> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_Tree_node@HPEAX@std@@@std@@YAAEAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_Tree_node@HPEAX@std@@@std@@YAAEAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_Tree_node<int,void *> * &>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@AEAPEAU?$_Tree_node@HPEAX@std@@@std@@YAAEAPEAU?$_Tree_node@HPEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_Tree_node<int,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$lexicographical_compare@PEBHPEBH@std@@YA_NQEBH000@Z
_TEXT	SEGMENT
_First1$ = 8
_Last1$ = 16
_First2$ = 24
_Last2$ = 32
??$lexicographical_compare@PEBHPEBH@std@@YA_NQEBH000@Z PROC ; std::lexicographical_compare<int const *,int const *>, COMDAT

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	cmp	rcx, rdx
	je	SHORT $LN23@lexicograp
$LL6@lexicograp:
	cmp	r8, r9
	je	SHORT $LN11@lexicograp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	eax, DWORD PTR [rcx]
	cmp	eax, DWORD PTR [r8]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {

	jl	SHORT $LN18@lexicograp

; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {

	jg	SHORT $LN11@lexicograp

; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	add	rcx, 4
	add	r8, 4
	cmp	rcx, rdx
	jne	SHORT $LL6@lexicograp
$LN23@lexicograp:

; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;

	cmp	r8, r9
	je	SHORT $LN11@lexicograp
$LN18@lexicograp:

; 5496 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5497 :     return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>{});
; 5498 : }

	mov	al, 1
	ret	0
$LN11@lexicograp:
	xor	al, al
	ret	0
??$lexicographical_compare@PEBHPEBH@std@@YA_NQEBH000@Z ENDP ; std::lexicographical_compare<int const *,int const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * &>, COMDAT

; 1439 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1440 : }

	ret	0
??$forward@AEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@V?$vector@HV?$allocator@H@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_Tree_node<std::vector<int,std::allocator<int> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility
;	COMDAT ??$lexicographical_compare@PEBHPEBHU?$less@X@std@@@std@@YA_NQEBH000U?$less@X@0@@Z
_TEXT	SEGMENT
_First1$ = 8
_Last1$ = 16
_First2$ = 24
_Last2$ = 32
_Pred$dead$ = 40
??$lexicographical_compare@PEBHPEBHU?$less@X@std@@@std@@YA_NQEBH000U?$less@X@0@@Z PROC ; std::lexicographical_compare<int const *,int const *,std::less<void> >, COMDAT

; 5461 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5462 :     _Adl_verify_range(_First1, _Last1);
; 5463 :     _Adl_verify_range(_First2, _Last2);
; 5464 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5465 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);
; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);
; 5468 : 
; 5469 :     using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
; 5470 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5471 : #if _HAS_CXX20
; 5472 :         if (!_STD is_constant_evaluated())
; 5473 : #endif // _HAS_CXX20
; 5474 :         {
; 5475 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5476 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5477 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5478 :             return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
; 5479 :         }
; 5480 :     }
; 5481 : 
; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	cmp	rcx, rdx
	je	SHORT $LN21@lexicograp
$LL4@lexicograp:
	cmp	r8, r9
	je	SHORT $LN9@lexicograp
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	eax, DWORD PTR [rcx]
	cmp	eax, DWORD PTR [r8]
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xutility

; 5483 :         if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {

	jl	SHORT $LN16@lexicograp

; 5484 :             return true;
; 5485 :         } else if (_Pred(*_UFirst2, *_UFirst1)) {

	jg	SHORT $LN9@lexicograp

; 5461 :     // order [_First1, _Last1) vs. [_First2, _Last2)
; 5462 :     _Adl_verify_range(_First1, _Last1);
; 5463 :     _Adl_verify_range(_First2, _Last2);
; 5464 :     auto _UFirst1      = _Get_unwrapped(_First1);
; 5465 :     const auto _ULast1 = _Get_unwrapped(_Last1);
; 5466 :     auto _UFirst2      = _Get_unwrapped(_First2);
; 5467 :     const auto _ULast2 = _Get_unwrapped(_Last2);
; 5468 : 
; 5469 :     using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
; 5470 :     if constexpr (!is_void_v<_Memcmp_pred>) {
; 5471 : #if _HAS_CXX20
; 5472 :         if (!_STD is_constant_evaluated())
; 5473 : #endif // _HAS_CXX20
; 5474 :         {
; 5475 :             const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
; 5476 :             const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
; 5477 :             const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
; 5478 :             return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
; 5479 :         }
; 5480 :     }
; 5481 : 
; 5482 :     for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it

	add	rcx, 4
	add	r8, 4
	cmp	rcx, rdx
	jne	SHORT $LL4@lexicograp
$LN21@lexicograp:

; 5486 :             return false;
; 5487 :         }
; 5488 :     }
; 5489 : 
; 5490 :     return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;

	cmp	r8, r9
	je	SHORT $LN9@lexicograp
$LN16@lexicograp:

; 5491 : }

	mov	al, 1
	ret	0
$LN9@lexicograp:
	xor	al, al
	ret	0
??$lexicographical_compare@PEBHPEBHU?$less@X@std@@@std@@YA_NQEBH000U?$less@X@0@@Z ENDP ; std::lexicographical_compare<int const *,int const *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\Visual Studio 2022\VC\Tools\MSVC\14.36.32532\include\xstddef
;	COMDAT ??$?RAEBHAEBH@?$less@X@std@@QEBA_NAEBH0@Z
_TEXT	SEGMENT
this$dead$ = 8
_Left$ = 16
_Right$ = 24
??$?RAEBHAEBH@?$less@X@std@@QEBA_NAEBH0@Z PROC		; std::less<void>::operator()<int const &,int const &>, COMDAT

; 249  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

	mov	eax, DWORD PTR [r8]
	cmp	DWORD PTR [rdx], eax
	setl	al

; 250  :     }

	ret	0
??$?RAEBHAEBH@?$less@X@std@@QEBA_NAEBH0@Z ENDP		; std::less<void>::operator()<int const &,int const &>
_TEXT	ENDS
END
